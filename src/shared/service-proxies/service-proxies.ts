/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.20.1.0 (NJsonSchema v9.11.0.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resolveTenantId(input: ResolveTenantIdInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendPasswordResetCode(input: SendPasswordResetCodeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordInput | null | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResetPasswordOutput.fromJS(resultData200) : new ResetPasswordOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendEmailActivationLink(input: SendEmailActivationLinkInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    activateEmail(input: ActivateEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    impersonate(input: ImpersonateInput | null | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    switchToLinkedAccount(input: SwitchToLinkedAccountInput | null | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(<any>response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchToLinkedAccountOutput.fromJS(resultData200) : new SwitchToLinkedAccountOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
    }
}

@Injectable()
export class AdjustPriceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    t_ADJUST_ASS_Search(input: T_ADJUST_ASS_ENTITY | null | undefined): Observable<PagedResultDtoOfT_ADJUST_ASS_ENTITY> {
        let url_ = this.baseUrl + "/api/AdjustPrice/T_ADJUST_ASS_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_ADJUST_ASS_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_ADJUST_ASS_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfT_ADJUST_ASS_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfT_ADJUST_ASS_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processT_ADJUST_ASS_Search(response: HttpResponseBase): Observable<PagedResultDtoOfT_ADJUST_ASS_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfT_ADJUST_ASS_ENTITY.fromJS(resultData200) : new PagedResultDtoOfT_ADJUST_ASS_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfT_ADJUST_ASS_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    t_ADJUST_ASS_Ins(input: T_ADJUST_ASS_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/AdjustPrice/T_ADJUST_ASS_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_ADJUST_ASS_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_ADJUST_ASS_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processT_ADJUST_ASS_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    t_ADJUST_ASS_Upd(input: T_ADJUST_ASS_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/AdjustPrice/T_ADJUST_ASS_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_ADJUST_ASS_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_ADJUST_ASS_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processT_ADJUST_ASS_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    t_ADJUST_ASS_ById(id: string | null | undefined): Observable<T_ADJUST_ASS_ENTITY> {
        let url_ = this.baseUrl + "/api/AdjustPrice/T_ADJUST_ASS_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_ADJUST_ASS_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_ADJUST_ASS_ById(<any>response_);
                } catch (e) {
                    return <Observable<T_ADJUST_ASS_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<T_ADJUST_ASS_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processT_ADJUST_ASS_ById(response: HttpResponseBase): Observable<T_ADJUST_ASS_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? T_ADJUST_ASS_ENTITY.fromJS(resultData200) : new T_ADJUST_ASS_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<T_ADJUST_ASS_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    t_ADJUST_ASS_Del(id: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/AdjustPrice/T_ADJUST_ASS_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_ADJUST_ASS_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_ADJUST_ASS_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processT_ADJUST_ASS_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    t_ADJUST_ASS_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/AdjustPrice/T_ADJUST_ASS_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_ADJUST_ASS_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_ADJUST_ASS_App(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processT_ADJUST_ASS_App(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class AllCodeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param cdName (optional) 
     * @param cdType (optional) 
     * @return Success
     */
    cM_ALLCODE_GetByCDNAME(cdName: string | null | undefined, cdType: string | null | undefined): Observable<CM_ALLCODE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/AllCode/CM_ALLCODE_GetByCDNAME?";
        if (cdName !== undefined)
            url_ += "cdName=" + encodeURIComponent("" + cdName) + "&"; 
        if (cdType !== undefined)
            url_ += "cdType=" + encodeURIComponent("" + cdType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALLCODE_GetByCDNAME(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALLCODE_GetByCDNAME(<any>response_);
                } catch (e) {
                    return <Observable<CM_ALLCODE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ALLCODE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALLCODE_GetByCDNAME(response: HttpResponseBase): Observable<CM_ALLCODE_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_ALLCODE_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ALLCODE_ENTITY[]>(<any>null);
    }

    /**
     * @param cdType (optional) 
     * @return Success
     */
    cM_ALLCODE_GetByCDTYPE(cdType: string | null | undefined): Observable<CM_ALLCODE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/AllCode/CM_ALLCODE_GetByCDTYPE?";
        if (cdType !== undefined)
            url_ += "cdType=" + encodeURIComponent("" + cdType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALLCODE_GetByCDTYPE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALLCODE_GetByCDTYPE(<any>response_);
                } catch (e) {
                    return <Observable<CM_ALLCODE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ALLCODE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALLCODE_GetByCDTYPE(response: HttpResponseBase): Observable<CM_ALLCODE_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_ALLCODE_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ALLCODE_ENTITY[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_ALLCODE_Search(input: CM_ALLCODE_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_ALLCODE_ENTITY> {
        let url_ = this.baseUrl + "/api/AllCode/CM_ALLCODE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALLCODE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALLCODE_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_ALLCODE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_ALLCODE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALLCODE_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_ALLCODE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_ALLCODE_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_ALLCODE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_ALLCODE_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_ALLCODE_Ins(input: CM_ALLCODE_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AllCode/CM_ALLCODE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALLCODE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALLCODE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALLCODE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_ALLCODE_Upd(input: CM_ALLCODE_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AllCode/CM_ALLCODE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALLCODE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALLCODE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALLCODE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_ALLCODE_ById(id: number | null | undefined): Observable<CM_ALLCODE_ENTITY> {
        let url_ = this.baseUrl + "/api/AllCode/CM_ALLCODE_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALLCODE_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALLCODE_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_ALLCODE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ALLCODE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALLCODE_ById(response: HttpResponseBase): Observable<CM_ALLCODE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_ALLCODE_ENTITY.fromJS(resultData200) : new CM_ALLCODE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ALLCODE_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_ALLCODE_Del(id: number | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/AllCode/CM_ALLCODE_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALLCODE_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALLCODE_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALLCODE_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCdname(): Observable<AllCodeDto[]> {
        let url_ = this.baseUrl + "/api/AllCode/GetAllCdname";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCdname(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCdname(<any>response_);
                } catch (e) {
                    return <Observable<AllCodeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AllCodeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCdname(response: HttpResponseBase): Observable<AllCodeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AllCodeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AllCodeDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_ALLCODE_Custom_Ins(input: CM_ALLCODE_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AllCode/CM_ALLCODE_Custom_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALLCODE_Custom_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALLCODE_Custom_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALLCODE_Custom_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }
}

@Injectable()
export class AnnouncementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param userReceiveMessages (optional) 
     * @return Success
     */
    sendMessageToClient(userReceiveMessages: SendAnnouncement_ENTITY | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Announcement/SendMessageToClient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userReceiveMessages);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMessageToClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMessageToClient(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendMessageToClient(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    sendUserUnCheckIn(): Observable<void> {
        let url_ = this.baseUrl + "/api/Announcement/SendUserUnCheckIn";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendUserUnCheckIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendUserUnCheckIn(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendUserUnCheckIn(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    sendUserUnCheckOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/Announcement/SendUserUnCheckOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendUserUnCheckOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendUserUnCheckOut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendUserUnCheckOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getAllUnRead(userId: number | null | undefined): Observable<HR_Announcement_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Announcement/GetAllUnRead?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUnRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUnRead(<any>response_);
                } catch (e) {
                    return <Observable<HR_Announcement_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_Announcement_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUnRead(response: HttpResponseBase): Observable<HR_Announcement_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HR_Announcement_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_Announcement_ENTITY[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllUnReadPagination(userId: number | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Observable<HR_Announcement_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Announcement/GetAllUnReadPagination?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUnReadPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUnReadPagination(<any>response_);
                } catch (e) {
                    return <Observable<HR_Announcement_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_Announcement_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUnReadPagination(response: HttpResponseBase): Observable<HR_Announcement_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HR_Announcement_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_Announcement_ENTITY[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param receiveId (optional) 
     * @return Success
     */
    getDetailAnnouncement(id: string | null | undefined, receiveId: number | null | undefined): Observable<HR_Announcement_ENTITY> {
        let url_ = this.baseUrl + "/api/Announcement/GetDetailAnnouncement?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (receiveId !== undefined)
            url_ += "receiveId=" + encodeURIComponent("" + receiveId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailAnnouncement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailAnnouncement(<any>response_);
                } catch (e) {
                    return <Observable<HR_Announcement_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_Announcement_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetailAnnouncement(response: HttpResponseBase): Observable<HR_Announcement_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HR_Announcement_ENTITY.fromJS(resultData200) : new HR_Announcement_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_Announcement_ENTITY>(<any>null);
    }

    /**
     * @param announceId (optional) 
     * @param userId (optional) 
     * @return Success
     */
    markAsRead(announceId: string | null | undefined, userId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Announcement/MarkAsRead?";
        if (announceId !== undefined)
            url_ += "announceId=" + encodeURIComponent("" + announceId) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    markAsReadAll(input: HR_Announcement_ENTITY[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Announcement/MarkAsReadAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsReadAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsReadAll(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAsReadAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param announceId (optional) 
     * @param userId (optional) 
     * @return Success
     */
    markAsDelete(announceId: string | null | undefined, userId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Announcement/MarkAsDelete?";
        if (announceId !== undefined)
            url_ += "announceId=" + encodeURIComponent("" + announceId) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAsDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    markAsDeleteAll(input: HR_Announcement_ENTITY[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Announcement/MarkAsDeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsDeleteAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsDeleteAll(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAsDeleteAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AppMenuServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllMenus(): Observable<AppMenuDto[]> {
        let url_ = this.baseUrl + "/api/AppMenu/GetAllMenus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMenus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMenus(<any>response_);
                } catch (e) {
                    return <Observable<AppMenuDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppMenuDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMenus(response: HttpResponseBase): Observable<AppMenuDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AppMenuDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppMenuDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    tL_MENU_Search(input: TL_MENU_ENTITY | null | undefined): Observable<PagedResultDtoOfTL_MENU_ENTITY> {
        let url_ = this.baseUrl + "/api/AppMenu/TL_MENU_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_MENU_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_MENU_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTL_MENU_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTL_MENU_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processTL_MENU_Search(response: HttpResponseBase): Observable<PagedResultDtoOfTL_MENU_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTL_MENU_ENTITY.fromJS(resultData200) : new PagedResultDtoOfTL_MENU_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTL_MENU_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    tL_MENU_Ins(input: TL_MENU_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AppMenu/TL_MENU_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_MENU_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_MENU_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processTL_MENU_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    tL_MENU_Upd(input: TL_MENU_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AppMenu/TL_MENU_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_MENU_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_MENU_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processTL_MENU_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    tL_MENU_ById(id: number | null | undefined): Observable<TL_MENU_ENTITY> {
        let url_ = this.baseUrl + "/api/AppMenu/TL_MENU_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_MENU_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_MENU_ById(<any>response_);
                } catch (e) {
                    return <Observable<TL_MENU_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<TL_MENU_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processTL_MENU_ById(response: HttpResponseBase): Observable<TL_MENU_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TL_MENU_ENTITY.fromJS(resultData200) : new TL_MENU_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TL_MENU_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    tL_MENU_Del(id: number | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/AppMenu/TL_MENU_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_MENU_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_MENU_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processTL_MENU_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    tL_MENU_App(id: number | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/AppMenu/TL_MENU_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_MENU_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_MENU_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processTL_MENU_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class AppPermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllAppPermissions(): Observable<FlatPermissionDto[]> {
        let url_ = this.baseUrl + "/api/AppPermission/GetAllAppPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAppPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAppPermissions(<any>response_);
                } catch (e) {
                    return <Observable<FlatPermissionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlatPermissionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAppPermissions(response: HttpResponseBase): Observable<FlatPermissionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FlatPermissionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlatPermissionDto[]>(<any>null);
    }
}

@Injectable()
export class AsposeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param info (optional) 
     * @return Success
     */
    getReport(info: ReportInfo | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Aspose/GetReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReport(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReport(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param info (optional) 
     * @return Success
     */
    getReportCustomFomart(info: ReportInfo | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Aspose/GetReportCustomFomart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportCustomFomart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportCustomFomart(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportCustomFomart(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param info (optional) 
     * @return Success
     */
    getReportFromHTML(info: ReportHtmlInfo | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Aspose/GetReportFromHTML";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportFromHTML(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportFromHTML(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportFromHTML(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param store (optional) 
     * @return Success
     */
    getDataFromStore(store: ReportInfo | null | undefined): Observable<ReportTable[]> {
        let url_ = this.baseUrl + "/api/Aspose/GetDataFromStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(store);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataFromStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataFromStore(<any>response_);
                } catch (e) {
                    return <Observable<ReportTable[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportTable[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataFromStore(response: HttpResponseBase): Observable<ReportTable[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReportTable.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportTable[]>(<any>null);
    }
}

@Injectable()
export class AttachFileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param refMaster (optional) 
     * @return Success
     */
    cM_ATTACH_FILE_By_RefMaster(refMaster: string | null | undefined): Observable<CM_ATTACH_FILE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/AttachFile/CM_ATTACH_FILE_By_RefMaster?";
        if (refMaster !== undefined)
            url_ += "refMaster=" + encodeURIComponent("" + refMaster) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ATTACH_FILE_By_RefMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ATTACH_FILE_By_RefMaster(<any>response_);
                } catch (e) {
                    return <Observable<CM_ATTACH_FILE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ATTACH_FILE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ATTACH_FILE_By_RefMaster(response: HttpResponseBase): Observable<CM_ATTACH_FILE_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_ATTACH_FILE_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ATTACH_FILE_ENTITY[]>(<any>null);
    }

    /**
     * @param refIds (optional) 
     * @return Success
     */
    cM_ATTACH_FILE_By_RefId(refIds: string[] | null | undefined): Observable<CM_ATTACH_FILE_MODEL[]> {
        let url_ = this.baseUrl + "/api/AttachFile/CM_ATTACH_FILE_By_RefId?";
        if (refIds !== undefined)
            refIds && refIds.forEach(item => { url_ += "refIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ATTACH_FILE_By_RefId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ATTACH_FILE_By_RefId(<any>response_);
                } catch (e) {
                    return <Observable<CM_ATTACH_FILE_MODEL[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ATTACH_FILE_MODEL[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ATTACH_FILE_By_RefId(response: HttpResponseBase): Observable<CM_ATTACH_FILE_MODEL[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_ATTACH_FILE_MODEL.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ATTACH_FILE_MODEL[]>(<any>null);
    }

    /**
     * @param attachFileModel (optional) 
     * @return Success
     */
    cM_ATTACH_FILE_Ins(attachFileModel: CM_ATTACH_FILE_INPUT | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AttachFile/CM_ATTACH_FILE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(attachFileModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ATTACH_FILE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ATTACH_FILE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ATTACH_FILE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param attachFileModel (optional) 
     * @return Success
     */
    cM_ATTACH_FILE_Upd(attachFileModel: CM_ATTACH_FILE_INPUT | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AttachFile/CM_ATTACH_FILE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(attachFileModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ATTACH_FILE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ATTACH_FILE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ATTACH_FILE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @return Success
     */
    testFile(): Observable<CM_ATTACH_FILE_ENTITY> {
        let url_ = this.baseUrl + "/api/AttachFile/TestFile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestFile(<any>response_);
                } catch (e) {
                    return <Observable<CM_ATTACH_FILE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ATTACH_FILE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processTestFile(response: HttpResponseBase): Observable<CM_ATTACH_FILE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_ATTACH_FILE_ENTITY.fromJS(resultData200) : new CM_ATTACH_FILE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ATTACH_FILE_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_ATTACH_FILE_Del_BY_REFID(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/AttachFile/CM_ATTACH_FILE_Del_BY_REFID?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ATTACH_FILE_Del_BY_REFID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ATTACH_FILE_Del_BY_REFID(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ATTACH_FILE_Del_BY_REFID(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param fILE_NAME_OLD (optional) 
     * @return Success
     */
    cM_ATTACH_FILE_Upd_BY_REFID(id: string | null | undefined, fILE_NAME_OLD: string | null | undefined): Observable<CM_ATTACH_FILE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/AttachFile/CM_ATTACH_FILE_Upd_BY_REFID?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (fILE_NAME_OLD !== undefined)
            url_ += "FILE_NAME_OLD=" + encodeURIComponent("" + fILE_NAME_OLD) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ATTACH_FILE_Upd_BY_REFID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ATTACH_FILE_Upd_BY_REFID(<any>response_);
                } catch (e) {
                    return <Observable<CM_ATTACH_FILE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ATTACH_FILE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ATTACH_FILE_Upd_BY_REFID(response: HttpResponseBase): Observable<CM_ATTACH_FILE_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_ATTACH_FILE_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ATTACH_FILE_ENTITY[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveTmpFile(input: CM_ATTACH_FILE_INPUT | null | undefined): Observable<CM_ATTACH_FILE_INPUT> {
        let url_ = this.baseUrl + "/api/AttachFile/MoveTmpFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveTmpFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTmpFile(<any>response_);
                } catch (e) {
                    return <Observable<CM_ATTACH_FILE_INPUT>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ATTACH_FILE_INPUT>><any>_observableThrow(response_);
        }));
    }

    protected processMoveTmpFile(response: HttpResponseBase): Observable<CM_ATTACH_FILE_INPUT> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_ATTACH_FILE_INPUT.fromJS(resultData200) : new CM_ATTACH_FILE_INPUT();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ATTACH_FILE_INPUT>(<any>null);
    }

    /**
     * @param g (optional) 
     * @return Success
     */
    delete_g_path(g: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AttachFile/Delete_g_path?";
        if (g !== undefined)
            url_ += "g=" + encodeURIComponent("" + g) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete_g_path(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete_g_path(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete_g_path(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, tOP: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAuditLogListDto.fromJS(resultData200) : new PagedResultDtoOfAuditLogListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, tOP: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, tOP: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEntityChangeListDto.fromJS(resultData200) : new PagedResultDtoOfEntityChangeListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param entityTypeFullName (optional) 
     * @param entityId (optional) 
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityTypeChanges(entityTypeFullName: string | null | undefined, entityId: string | null | undefined, tOP: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityTypeChanges?";
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&"; 
        if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityTypeChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityTypeChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityTypeChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEntityChangeListDto.fromJS(resultData200) : new PagedResultDtoOfEntityChangeListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, tOP: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | null | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(<any>response_);
                } catch (e) {
                    return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntityPropertyChangeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityPropertyChangeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    ressetPermission(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/RessetPermission";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRessetPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRessetPermission(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRessetPermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BranchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    cM_BRANCH_Combobox(): Observable<CM_BRANCH_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_Combobox";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_Combobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_Combobox(<any>response_);
                } catch (e) {
                    return <Observable<CM_BRANCH_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_BRANCH_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_Combobox(response: HttpResponseBase): Observable<CM_BRANCH_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_BRANCH_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_BRANCH_ENTITY[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_BRANCH_Search(input: CM_BRANCH_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_BRANCH_ENTITY> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_BRANCH_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_BRANCH_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_BRANCH_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_BRANCH_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_BRANCH_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_BRANCH_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_BRANCH_ToExcel(input: CM_BRANCH_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_BRANCH_Ins(input: CM_BRANCH_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_BRANCH_Upd(input: CM_BRANCH_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_BRANCH_ById(id: string | null | undefined): Observable<CM_BRANCH_ENTITY> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_BRANCH_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_BRANCH_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_ById(response: HttpResponseBase): Observable<CM_BRANCH_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_BRANCH_ENTITY.fromJS(resultData200) : new CM_BRANCH_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_BRANCH_ENTITY>(<any>null);
    }

    /**
     * @param regionId (optional) 
     * @param branchType (optional) 
     * @return Success
     */
    cM_BRANCH_GetFatherList(regionId: string | null | undefined, branchType: string | null | undefined): Observable<CM_BRANCH_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_GetFatherList?";
        if (regionId !== undefined)
            url_ += "regionId=" + encodeURIComponent("" + regionId) + "&"; 
        if (branchType !== undefined)
            url_ += "branchType=" + encodeURIComponent("" + branchType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_GetFatherList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_GetFatherList(<any>response_);
                } catch (e) {
                    return <Observable<CM_BRANCH_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_BRANCH_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_GetFatherList(response: HttpResponseBase): Observable<CM_BRANCH_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_BRANCH_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_BRANCH_ENTITY[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_BRANCH_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_BRANCH_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param branchId (optional) 
     * @return Success
     */
    cM_BRANCH_Lev(branchId: string | null | undefined): Observable<CM_BRANCH_LEV_ENTITY> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_Lev?";
        if (branchId !== undefined)
            url_ += "branchId=" + encodeURIComponent("" + branchId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_Lev(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_Lev(<any>response_);
                } catch (e) {
                    return <Observable<CM_BRANCH_LEV_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_BRANCH_LEV_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_Lev(response: HttpResponseBase): Observable<CM_BRANCH_LEV_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_BRANCH_LEV_ENTITY.fromJS(resultData200) : new CM_BRANCH_LEV_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_BRANCH_LEV_ENTITY>(<any>null);
    }

    /**
     * @param parentId (optional) 
     * @return Success
     */
    cM_BRANCH_GetAllChild(parentId: string | null | undefined): Observable<CM_BRANCH_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_GetAllChild?";
        if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_GetAllChild(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_GetAllChild(<any>response_);
                } catch (e) {
                    return <Observable<CM_BRANCH_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_BRANCH_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_GetAllChild(response: HttpResponseBase): Observable<CM_BRANCH_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_BRANCH_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_BRANCH_ENTITY[]>(<any>null);
    }

    /**
     * @param dts (optional) 
     * @return Success
     */
    getListData(dts: any | null | undefined): Observable<{ [key: string] : number[][]; }> {
        let url_ = this.baseUrl + "/api/Branch/GetListData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dts);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListData(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : number[][]; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : number[][]; }>><any>_observableThrow(response_);
        }));
    }

    protected processGetListData(response: HttpResponseBase): Observable<{ [key: string] : number[][]; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key] !== undefined ? resultData200[key] : [];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : number[][]; }>(<any>null);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfCacheDto.fromJS(resultData200) : new ListResultDtoOfCacheDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCacheDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    clearCache(input: EntityDtoOfString | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearPermissionAndRole(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearPermissionAndRole";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearPermissionAndRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearPermissionAndRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearPermissionAndRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearTmpFolderUpload(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearTmpFolderUpload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearTmpFolderUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearTmpFolderUpload(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearTmpFolderUpload(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CareerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    aSS_GROUP_Search(input: ASS_GROUP_ENTITY | null | undefined): Observable<PagedResultDtoOfASS_GROUP_ENTITY> {
        let url_ = this.baseUrl + "/api/Career/ASS_GROUP_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processASS_GROUP_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processASS_GROUP_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfASS_GROUP_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfASS_GROUP_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processASS_GROUP_Search(response: HttpResponseBase): Observable<PagedResultDtoOfASS_GROUP_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfASS_GROUP_ENTITY.fromJS(resultData200) : new PagedResultDtoOfASS_GROUP_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfASS_GROUP_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    aSS_GROUP_ToExcel(input: ASS_GROUP_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Career/ASS_GROUP_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processASS_GROUP_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processASS_GROUP_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processASS_GROUP_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    aSS_GROUP_Ins(input: ASS_GROUP_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Career/ASS_GROUP_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processASS_GROUP_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processASS_GROUP_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processASS_GROUP_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    aSS_GROUP_Upd(input: ASS_GROUP_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Career/ASS_GROUP_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processASS_GROUP_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processASS_GROUP_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processASS_GROUP_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    aSS_GROUP_ById(id: string | null | undefined): Observable<ASS_GROUP_ENTITY> {
        let url_ = this.baseUrl + "/api/Career/ASS_GROUP_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processASS_GROUP_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processASS_GROUP_ById(<any>response_);
                } catch (e) {
                    return <Observable<ASS_GROUP_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<ASS_GROUP_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processASS_GROUP_ById(response: HttpResponseBase): Observable<ASS_GROUP_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ASS_GROUP_ENTITY.fromJS(resultData200) : new ASS_GROUP_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ASS_GROUP_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    aSS_GROUP_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Career/ASS_GROUP_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processASS_GROUP_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processASS_GROUP_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processASS_GROUP_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    aSS_GROUP_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Career/ASS_GROUP_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processASS_GROUP_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processASS_GROUP_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processASS_GROUP_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class CarTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_CAR_TYPE_Search(input: CM_CAR_TYPE_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_CAR_TYPE_ENTITY> {
        let url_ = this.baseUrl + "/api/CarType/CM_CAR_TYPE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_CAR_TYPE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_CAR_TYPE_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_CAR_TYPE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_CAR_TYPE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_CAR_TYPE_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_CAR_TYPE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_CAR_TYPE_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_CAR_TYPE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_CAR_TYPE_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_CAR_TYPE_ToExcel(input: CM_CAR_TYPE_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/CarType/CM_CAR_TYPE_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_CAR_TYPE_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_CAR_TYPE_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_CAR_TYPE_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_CAR_TYPE_Ins(input: CM_CAR_TYPE_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/CarType/CM_CAR_TYPE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_CAR_TYPE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_CAR_TYPE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_CAR_TYPE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_CAR_TYPE_Upd(input: CM_CAR_TYPE_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/CarType/CM_CAR_TYPE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_CAR_TYPE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_CAR_TYPE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_CAR_TYPE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_CAR_TYPE_List(input: CM_CAR_TYPE_ENTITY | null | undefined): Observable<CM_CAR_TYPE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/CarType/CM_CAR_TYPE_List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_CAR_TYPE_List(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_CAR_TYPE_List(<any>response_);
                } catch (e) {
                    return <Observable<CM_CAR_TYPE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_CAR_TYPE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_CAR_TYPE_List(response: HttpResponseBase): Observable<CM_CAR_TYPE_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_CAR_TYPE_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_CAR_TYPE_ENTITY[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_CAR_TYPE_ById(id: string | null | undefined): Observable<CM_CAR_TYPE_ENTITY> {
        let url_ = this.baseUrl + "/api/CarType/CM_CAR_TYPE_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_CAR_TYPE_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_CAR_TYPE_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_CAR_TYPE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_CAR_TYPE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_CAR_TYPE_ById(response: HttpResponseBase): Observable<CM_CAR_TYPE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_CAR_TYPE_ENTITY.fromJS(resultData200) : new CM_CAR_TYPE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_CAR_TYPE_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_CAR_TYPE_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/CarType/CM_CAR_TYPE_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_CAR_TYPE_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_CAR_TYPE_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_CAR_TYPE_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_CAR_TYPE_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/CarType/CM_CAR_TYPE_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_CAR_TYPE_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_CAR_TYPE_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_CAR_TYPE_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class CauHinhEmailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_CauHinhEmail_Search(input: HR_CauHinhEmail_ENTITY | null | undefined): Observable<PagedResultDtoOfHR_CauHinhEmail_ENTITY> {
        let url_ = this.baseUrl + "/api/CauHinhEmail/HR_CauHinhEmail_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_CauHinhEmail_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_CauHinhEmail_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfHR_CauHinhEmail_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfHR_CauHinhEmail_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_CauHinhEmail_Search(response: HttpResponseBase): Observable<PagedResultDtoOfHR_CauHinhEmail_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfHR_CauHinhEmail_ENTITY.fromJS(resultData200) : new PagedResultDtoOfHR_CauHinhEmail_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfHR_CauHinhEmail_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_CauHinhEmail_ToExcel(input: HR_CauHinhEmail_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/CauHinhEmail/HR_CauHinhEmail_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_CauHinhEmail_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_CauHinhEmail_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processHR_CauHinhEmail_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_CauHinhEmail_Ins(input: HR_CauHinhEmail_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/CauHinhEmail/HR_CauHinhEmail_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_CauHinhEmail_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_CauHinhEmail_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_CauHinhEmail_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_CauHinhEmail_Upd(input: HR_CauHinhEmail_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/CauHinhEmail/HR_CauHinhEmail_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_CauHinhEmail_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_CauHinhEmail_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_CauHinhEmail_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_CauHinhEmail_ById(id: string | null | undefined): Observable<HR_CauHinhEmail_ENTITY> {
        let url_ = this.baseUrl + "/api/CauHinhEmail/HR_CauHinhEmail_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_CauHinhEmail_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_CauHinhEmail_ById(<any>response_);
                } catch (e) {
                    return <Observable<HR_CauHinhEmail_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_CauHinhEmail_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_CauHinhEmail_ById(response: HttpResponseBase): Observable<HR_CauHinhEmail_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HR_CauHinhEmail_ENTITY.fromJS(resultData200) : new HR_CauHinhEmail_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_CauHinhEmail_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_CauHinhEmail_ByCTY(id: number | null | undefined): Observable<HR_CauHinhEmail_ENTITY> {
        let url_ = this.baseUrl + "/api/CauHinhEmail/HR_CauHinhEmail_ByCTY?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_CauHinhEmail_ByCTY(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_CauHinhEmail_ByCTY(<any>response_);
                } catch (e) {
                    return <Observable<HR_CauHinhEmail_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_CauHinhEmail_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_CauHinhEmail_ByCTY(response: HttpResponseBase): Observable<HR_CauHinhEmail_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HR_CauHinhEmail_ENTITY.fromJS(resultData200) : new HR_CauHinhEmail_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_CauHinhEmail_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_CauHinhEmail_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/CauHinhEmail/HR_CauHinhEmail_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_CauHinhEmail_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_CauHinhEmail_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_CauHinhEmail_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    hR_CauHinhEmail_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/CauHinhEmail/HR_CauHinhEmail_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_CauHinhEmail_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_CauHinhEmail_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_CauHinhEmail_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_CauHinhEmail_Lst(input: HR_CauHinhEmail_ENTITY | null | undefined): Observable<HR_CauHinhEmail_ENTITY[]> {
        let url_ = this.baseUrl + "/api/CauHinhEmail/HR_CauHinhEmail_Lst";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_CauHinhEmail_Lst(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_CauHinhEmail_Lst(<any>response_);
                } catch (e) {
                    return <Observable<HR_CauHinhEmail_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_CauHinhEmail_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processHR_CauHinhEmail_Lst(response: HttpResponseBase): Observable<HR_CauHinhEmail_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HR_CauHinhEmail_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_CauHinhEmail_ENTITY[]>(<any>null);
    }
}

@Injectable()
export class CmUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tlUserFilter (optional) 
     * @return Success
     */
    tLUSER_GETBY_BRANCHID(tlUserFilter: TLUSER_GETBY_BRANCHID_ENTITY | null | undefined): Observable<PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY> {
        let url_ = this.baseUrl + "/api/CmUser/TLUSER_GETBY_BRANCHID";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tlUserFilter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTLUSER_GETBY_BRANCHID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTLUSER_GETBY_BRANCHID(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processTLUSER_GETBY_BRANCHID(response: HttpResponseBase): Observable<PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY.fromJS(resultData200) : new PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | null | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200) : new ListResultDtoOfSubscribableEditionComboboxItemDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSubscribableEditionComboboxItemDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findUsers(input: FindUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDefaultEditionNameOutput.fromJS(resultData200) : new GetDefaultEditionNameOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(<any>null);
    }
}

@Injectable()
export class CHAMCONGServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maChamCong (optional) 
     * @param timeCheckDate (optional) 
     * @return Success
     */
    checkTrongNgay(maChamCong: string | null | undefined, timeCheckDate: moment.Moment | null | undefined): Observable<HR_DaTa_ChamCong_ENTITY> {
        let url_ = this.baseUrl + "/api/CHAMCONG/CheckTrongNgay?";
        if (maChamCong !== undefined)
            url_ += "maChamCong=" + encodeURIComponent("" + maChamCong) + "&"; 
        if (timeCheckDate !== undefined)
            url_ += "timeCheckDate=" + encodeURIComponent(timeCheckDate ? "" + timeCheckDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckTrongNgay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckTrongNgay(<any>response_);
                } catch (e) {
                    return <Observable<HR_DaTa_ChamCong_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_DaTa_ChamCong_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCheckTrongNgay(response: HttpResponseBase): Observable<HR_DaTa_ChamCong_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HR_DaTa_ChamCong_ENTITY.fromJS(resultData200) : new HR_DaTa_ChamCong_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_DaTa_ChamCong_ENTITY>(<any>null);
    }

    /**
     * @param macChamCong (optional) 
     * @return Success
     */
    getAllByMaChamCong(macChamCong: string | null | undefined): Observable<HR_DaTa_ChamCong_ENTITY[]> {
        let url_ = this.baseUrl + "/api/CHAMCONG/GetAllByMaChamCong?";
        if (macChamCong !== undefined)
            url_ += "macChamCong=" + encodeURIComponent("" + macChamCong) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByMaChamCong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByMaChamCong(<any>response_);
                } catch (e) {
                    return <Observable<HR_DaTa_ChamCong_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_DaTa_ChamCong_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllByMaChamCong(response: HttpResponseBase): Observable<HR_DaTa_ChamCong_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HR_DaTa_ChamCong_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_DaTa_ChamCong_ENTITY[]>(<any>null);
    }

    /**
     * @param branchId (optional) 
     * @param dateTo (optional) 
     * @param dateFrom (optional) 
     * @param maChamCong (optional) 
     * @param search (optional) 
     * @param flagGlobal (optional) 
     * @return Success
     */
    getAllByBranchId(branchId: number | null | undefined, dateTo: moment.Moment | null | undefined, dateFrom: moment.Moment | null | undefined, maChamCong: string | null | undefined, search: string | null | undefined, flagGlobal: boolean | null | undefined): Observable<HR_DaTa_ChamCong_ENTITY[]> {
        let url_ = this.baseUrl + "/api/CHAMCONG/GetAllByBranchId?";
        if (branchId !== undefined)
            url_ += "branchId=" + encodeURIComponent("" + branchId) + "&"; 
        if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toJSON() : "") + "&"; 
        if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toJSON() : "") + "&"; 
        if (maChamCong !== undefined)
            url_ += "maChamCong=" + encodeURIComponent("" + maChamCong) + "&"; 
        if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&"; 
        if (flagGlobal !== undefined)
            url_ += "flagGlobal=" + encodeURIComponent("" + flagGlobal) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByBranchId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByBranchId(<any>response_);
                } catch (e) {
                    return <Observable<HR_DaTa_ChamCong_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_DaTa_ChamCong_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllByBranchId(response: HttpResponseBase): Observable<HR_DaTa_ChamCong_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HR_DaTa_ChamCong_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_DaTa_ChamCong_ENTITY[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCurrentDateTime(): Observable<moment.Moment> {
        let url_ = this.baseUrl + "/api/CHAMCONG/GetCurrentDateTime";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentDateTime(<any>response_);
                } catch (e) {
                    return <Observable<moment.Moment>><any>_observableThrow(e);
                }
            } else
                return <Observable<moment.Moment>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentDateTime(response: HttpResponseBase): Observable<moment.Moment> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? moment(resultData200.toString()) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<moment.Moment>(<any>null);
    }

    /**
     * @param branchId (optional) 
     * @return Success
     */
    getAllFullNameByFilterKeyWord(branchId: string | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/CHAMCONG/GetAllFullNameByFilterKeyWord?";
        if (branchId !== undefined)
            url_ += "branchId=" + encodeURIComponent("" + branchId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFullNameByFilterKeyWord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFullNameByFilterKeyWord(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllFullNameByFilterKeyWord(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param maChamCong (optional) 
     * @param userId (optional) 
     * @return Success
     */
    createOrEditMobile(maChamCong: string | null | undefined, userId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/CHAMCONG/CreateOrEditMobile?";
        if (maChamCong !== undefined)
            url_ += "maChamCong=" + encodeURIComponent("" + maChamCong) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditMobile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditMobile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEditMobile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_CHAMCONG_Search(input: HR_DaTa_ChamCong_ENTITY | null | undefined): Observable<PagedResultDtoOfHR_DaTa_ChamCong_ENTITY> {
        let url_ = this.baseUrl + "/api/CHAMCONG/HR_CHAMCONG_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_CHAMCONG_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_CHAMCONG_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfHR_DaTa_ChamCong_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfHR_DaTa_ChamCong_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_CHAMCONG_Search(response: HttpResponseBase): Observable<PagedResultDtoOfHR_DaTa_ChamCong_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfHR_DaTa_ChamCong_ENTITY.fromJS(resultData200) : new PagedResultDtoOfHR_DaTa_ChamCong_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfHR_DaTa_ChamCong_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_DANHSACHCHAMCONG(input: HR_DaTa_ChamCong_ENTITY | null | undefined): Observable<PagedResultDtoOfHR_DaTa_ChamCong_ENTITY> {
        let url_ = this.baseUrl + "/api/CHAMCONG/HR_DANHSACHCHAMCONG";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_DANHSACHCHAMCONG(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_DANHSACHCHAMCONG(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfHR_DaTa_ChamCong_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfHR_DaTa_ChamCong_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_DANHSACHCHAMCONG(response: HttpResponseBase): Observable<PagedResultDtoOfHR_DaTa_ChamCong_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfHR_DaTa_ChamCong_ENTITY.fromJS(resultData200) : new PagedResultDtoOfHR_DaTa_ChamCong_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfHR_DaTa_ChamCong_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_CHAMCONG_ToExcel(input: HR_DaTa_ChamCong_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/CHAMCONG/HR_CHAMCONG_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_CHAMCONG_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_CHAMCONG_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processHR_CHAMCONG_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getDataChamCongsFilterToExcel(input: GetAllDataChamCongsInput | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/CHAMCONG/GetDataChamCongsFilterToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataChamCongsFilterToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataChamCongsFilterToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataChamCongsFilterToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param processDate (optional) 
     * @return Success
     */
    getDataChamCongsToExcel(processDate: moment.Moment | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/CHAMCONG/GetDataChamCongsToExcel?";
        if (processDate !== undefined)
            url_ += "ProcessDate=" + encodeURIComponent(processDate ? "" + processDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataChamCongsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataChamCongsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataChamCongsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    cM_DANHSACH_CONGTY(): Observable<OrganizationUnitDto[]> {
        let url_ = this.baseUrl + "/api/CHAMCONG/CM_DANHSACH_CONGTY";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DANHSACH_CONGTY(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DANHSACH_CONGTY(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DANHSACH_CONGTY(response: HttpResponseBase): Observable<OrganizationUnitDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrganizationUnitDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto[]>(<any>null);
    }

    /**
     * @param parentId (optional) 
     * @return Success
     */
    cM_DANHSACH_PHONGBAN(parentId: number | null | undefined): Observable<OrganizationUnitDto[]> {
        let url_ = this.baseUrl + "/api/CHAMCONG/CM_DANHSACH_PHONGBAN?";
        if (parentId !== undefined)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DANHSACH_PHONGBAN(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DANHSACH_PHONGBAN(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DANHSACH_PHONGBAN(response: HttpResponseBase): Observable<OrganizationUnitDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrganizationUnitDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto[]>(<any>null);
    }

    /**
     * @param parentId (optional) 
     * @return Success
     */
    cM_DANHSACH_VITRIUNGTUYEN(parentId: number | null | undefined): Observable<OrganizationUnitDto[]> {
        let url_ = this.baseUrl + "/api/CHAMCONG/CM_DANHSACH_VITRIUNGTUYEN?";
        if (parentId !== undefined)
            url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DANHSACH_VITRIUNGTUYEN(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DANHSACH_VITRIUNGTUYEN(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DANHSACH_VITRIUNGTUYEN(response: HttpResponseBase): Observable<OrganizationUnitDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrganizationUnitDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_CHAMCONG_Ins(input: HR_DaTa_ChamCong_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/CHAMCONG/HR_CHAMCONG_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_CHAMCONG_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_CHAMCONG_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_CHAMCONG_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_CHAMCONG_Upd(input: HR_DaTa_ChamCong_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/CHAMCONG/HR_CHAMCONG_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_CHAMCONG_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_CHAMCONG_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_CHAMCONG_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_CHAMCONG_ById(id: string | null | undefined): Observable<HR_DaTa_ChamCong_ENTITY> {
        let url_ = this.baseUrl + "/api/CHAMCONG/HR_CHAMCONG_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_CHAMCONG_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_CHAMCONG_ById(<any>response_);
                } catch (e) {
                    return <Observable<HR_DaTa_ChamCong_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_DaTa_ChamCong_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_CHAMCONG_ById(response: HttpResponseBase): Observable<HR_DaTa_ChamCong_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HR_DaTa_ChamCong_ENTITY.fromJS(resultData200) : new HR_DaTa_ChamCong_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_DaTa_ChamCong_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_CHAMCONG_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/CHAMCONG/HR_CHAMCONG_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_CHAMCONG_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_CHAMCONG_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_CHAMCONG_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    hR_CHAMCONG_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/CHAMCONG/HR_CHAMCONG_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_CHAMCONG_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_CHAMCONG_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_CHAMCONG_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserChatFriendsWithSettingsOutput.fromJS(resultData200) : new GetUserChatFriendsWithSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserChatFriendsWithSettingsOutput>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | null | undefined, userId: number | null | undefined, minMessageId: number | null | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatMessages?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (minMessageId !== undefined)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfChatMessageDto.fromJS(resultData200) : new ListResultDtoOfChatMessageDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfChatMessageDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(input: MarkAllUnreadMessagesOfUserAsReadInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getDashboard(): Observable<DashboardDto[]> {
        let url_ = this.baseUrl + "/api/Dashboard/GetDashboard";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboard(<any>response_);
                } catch (e) {
                    return <Observable<DashboardDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DashboardDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboard(response: HttpResponseBase): Observable<DashboardDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DashboardDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDashboardForEdit(id: number | null | undefined): Observable<DashboardDto> {
        let url_ = this.baseUrl + "/api/Dashboard/GetDashboardForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardForEdit(<any>response_);
                } catch (e) {
                    return <Observable<DashboardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DashboardDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardForEdit(response: HttpResponseBase): Observable<DashboardDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DashboardDto.fromJS(resultData200) : new DashboardDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: DashboardDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Dashboard/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDashboard(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Dashboard/DeleteDashboard?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDashboard(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDashboard(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPage(): Observable<PageDto[]> {
        let url_ = this.baseUrl + "/api/Dashboard/GetPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPage(<any>response_);
                } catch (e) {
                    return <Observable<PageDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPage(response: HttpResponseBase): Observable<PageDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PageDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPageByDashboardId(id: number | null | undefined): Observable<PageDto[]> {
        let url_ = this.baseUrl + "/api/Dashboard/GetPageByDashboardId?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPageByDashboardId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPageByDashboardId(<any>response_);
                } catch (e) {
                    return <Observable<PageDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPageByDashboardId(response: HttpResponseBase): Observable<PageDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PageDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPageForEdit(id: number | null | undefined): Observable<PageDto> {
        let url_ = this.baseUrl + "/api/Dashboard/GetPageForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<PageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPageForEdit(response: HttpResponseBase): Observable<PageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PageDto.fromJS(resultData200) : new PageDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEditPage(input: PageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Dashboard/CreateOrEditPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditPage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEditPage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deletePage(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Dashboard/DeletePage?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DashboardCustomizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllWidgetLayout(): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DashboardCustomization/GetAllWidgetLayout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWidgetLayout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWidgetLayout(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWidgetLayout(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInfoMultiSimpleItemWidget(id: number | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DashboardCustomization/GetInfoMultiSimpleItemWidget?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInfoMultiSimpleItemWidget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfoMultiSimpleItemWidget(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetInfoMultiSimpleItemWidget(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInfoMultiSimpleItemPercentWidget(id: number | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DashboardCustomization/GetInfoMultiSimpleItemPercentWidget?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInfoMultiSimpleItemPercentWidget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfoMultiSimpleItemPercentWidget(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetInfoMultiSimpleItemPercentWidget(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addWidgetMap(input: AddWidgetMapInput | null | undefined): Observable<WidgetMapOutput> {
        let url_ = this.baseUrl + "/api/DashboardCustomization/AddWidgetMap";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddWidgetMap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddWidgetMap(<any>response_);
                } catch (e) {
                    return <Observable<WidgetMapOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<WidgetMapOutput>><any>_observableThrow(response_);
        }));
    }

    protected processAddWidgetMap(response: HttpResponseBase): Observable<WidgetMapOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WidgetMapOutput.fromJS(resultData200) : new WidgetMapOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WidgetMapOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addNewCustomPage(input: AddNewPageInput | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DashboardCustomization/AddNewCustomPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewCustomPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewCustomPage(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processAddNewCustomPage(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getDashboardDefinition(input: string | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DashboardCustomization/GetDashboardDefinition?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardDefinition(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardDefinition(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param widgetId (optional) 
     * @return Success
     */
    getConfigDetailWidgetsById(widgetId: number | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DashboardCustomization/GetConfigDetailWidgetsById?";
        if (widgetId !== undefined)
            url_ += "WidgetId=" + encodeURIComponent("" + widgetId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfigDetailWidgetsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfigDetailWidgetsById(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfigDetailWidgetsById(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param widgetId (optional) 
     * @return Success
     */
    getConfigDefaultWidgetsById(widgetId: number | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DashboardCustomization/GetConfigDefaultWidgetsById?";
        if (widgetId !== undefined)
            url_ += "WidgetId=" + encodeURIComponent("" + widgetId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfigDefaultWidgetsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfigDefaultWidgetsById(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfigDefaultWidgetsById(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param nameStore (optional) 
     * @param parameter (optional) 
     * @return Success
     */
    dataResultStore(nameStore: string | null | undefined, parameter: FParameter[] | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DashboardCustomization/DataResultStore?";
        if (nameStore !== undefined)
            url_ += "nameStore=" + encodeURIComponent("" + nameStore) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(parameter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDataResultStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDataResultStore(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processDataResultStore(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getWidgetFilterOutput(input: WidgetFilterOutput | null | undefined): Observable<WidgetMapOutput> {
        let url_ = this.baseUrl + "/api/DashboardCustomization/GetWidgetFilterOutput";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWidgetFilterOutput(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWidgetFilterOutput(<any>response_);
                } catch (e) {
                    return <Observable<WidgetMapOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<WidgetMapOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWidgetFilterOutput(response: HttpResponseBase): Observable<WidgetMapOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WidgetMapOutput.fromJS(resultData200) : new WidgetMapOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WidgetMapOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    savePage(input: SavePageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DashboardCustomization/SavePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSavePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    saveMyPage(input: SavePageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DashboardCustomization/SaveMyPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveMyPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveMyPage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSaveMyPage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DeleteAssServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    t_DELETE_ASS_Search(input: T_DELETE_ASS_ENTITY | null | undefined): Observable<PagedResultDtoOfT_DELETE_ASS_ENTITY> {
        let url_ = this.baseUrl + "/api/DeleteAss/T_DELETE_ASS_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_DELETE_ASS_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_DELETE_ASS_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfT_DELETE_ASS_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfT_DELETE_ASS_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processT_DELETE_ASS_Search(response: HttpResponseBase): Observable<PagedResultDtoOfT_DELETE_ASS_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfT_DELETE_ASS_ENTITY.fromJS(resultData200) : new PagedResultDtoOfT_DELETE_ASS_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfT_DELETE_ASS_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    t_DELETE_ASS_Ins(input: T_DELETE_ASS_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/DeleteAss/T_DELETE_ASS_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_DELETE_ASS_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_DELETE_ASS_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processT_DELETE_ASS_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    t_DELETE_ASS_Upd(input: T_DELETE_ASS_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/DeleteAss/T_DELETE_ASS_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_DELETE_ASS_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_DELETE_ASS_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processT_DELETE_ASS_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    t_DELETE_ASS_ById(id: string | null | undefined): Observable<T_DELETE_ASS_ENTITY> {
        let url_ = this.baseUrl + "/api/DeleteAss/T_DELETE_ASS_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_DELETE_ASS_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_DELETE_ASS_ById(<any>response_);
                } catch (e) {
                    return <Observable<T_DELETE_ASS_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<T_DELETE_ASS_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processT_DELETE_ASS_ById(response: HttpResponseBase): Observable<T_DELETE_ASS_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? T_DELETE_ASS_ENTITY.fromJS(resultData200) : new T_DELETE_ASS_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<T_DELETE_ASS_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    t_DELETE_ASS_Del(id: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/DeleteAss/T_DELETE_ASS_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_DELETE_ASS_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_DELETE_ASS_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processT_DELETE_ASS_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    t_DELETE_ASS_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/DeleteAss/T_DELETE_ASS_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_DELETE_ASS_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_DELETE_ASS_App(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processT_DELETE_ASS_App(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class DeleteMultiAssServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    t_DEL_ASS_MUL_Search(input: T_DEL_ASS_MUL_ENTITY | null | undefined): Observable<PagedResultDtoOfT_DEL_ASS_MUL_ENTITY> {
        let url_ = this.baseUrl + "/api/DeleteMultiAss/T_DEL_ASS_MUL_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_DEL_ASS_MUL_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_DEL_ASS_MUL_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfT_DEL_ASS_MUL_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfT_DEL_ASS_MUL_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processT_DEL_ASS_MUL_Search(response: HttpResponseBase): Observable<PagedResultDtoOfT_DEL_ASS_MUL_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfT_DEL_ASS_MUL_ENTITY.fromJS(resultData200) : new PagedResultDtoOfT_DEL_ASS_MUL_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfT_DEL_ASS_MUL_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    t_DEL_ASS_MUL_Ins(input: T_DEL_ASS_MUL_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/DeleteMultiAss/T_DEL_ASS_MUL_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_DEL_ASS_MUL_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_DEL_ASS_MUL_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processT_DEL_ASS_MUL_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    t_DEL_ASS_MUL_Upd(input: T_DEL_ASS_MUL_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/DeleteMultiAss/T_DEL_ASS_MUL_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_DEL_ASS_MUL_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_DEL_ASS_MUL_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processT_DEL_ASS_MUL_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    t_DEL_ASS_MUL_ById(id: string | null | undefined): Observable<T_DEL_ASS_MUL_ENTITY> {
        let url_ = this.baseUrl + "/api/DeleteMultiAss/T_DEL_ASS_MUL_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_DEL_ASS_MUL_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_DEL_ASS_MUL_ById(<any>response_);
                } catch (e) {
                    return <Observable<T_DEL_ASS_MUL_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<T_DEL_ASS_MUL_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processT_DEL_ASS_MUL_ById(response: HttpResponseBase): Observable<T_DEL_ASS_MUL_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? T_DEL_ASS_MUL_ENTITY.fromJS(resultData200) : new T_DEL_ASS_MUL_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<T_DEL_ASS_MUL_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    t_DEL_ASS_MUL_DT_ById(id: string | null | undefined): Observable<T_DEL_ASS_MUL_DT_ENTITY[]> {
        let url_ = this.baseUrl + "/api/DeleteMultiAss/T_DEL_ASS_MUL_DT_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_DEL_ASS_MUL_DT_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_DEL_ASS_MUL_DT_ById(<any>response_);
                } catch (e) {
                    return <Observable<T_DEL_ASS_MUL_DT_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<T_DEL_ASS_MUL_DT_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processT_DEL_ASS_MUL_DT_ById(response: HttpResponseBase): Observable<T_DEL_ASS_MUL_DT_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(T_DEL_ASS_MUL_DT_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<T_DEL_ASS_MUL_DT_ENTITY[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    t_DEL_ASS_MUL_Del(id: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/DeleteMultiAss/T_DEL_ASS_MUL_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_DEL_ASS_MUL_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_DEL_ASS_MUL_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processT_DEL_ASS_MUL_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    t_DEL_ASS_MUL_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/DeleteMultiAss/T_DEL_ASS_MUL_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_DEL_ASS_MUL_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_DEL_ASS_MUL_App(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processT_DEL_ASS_MUL_App(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDate(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDate?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDate(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDate(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateTime?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateTime(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateRange?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateRange(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/GetCountries?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param selectedCountries (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(selectedCountries: NameValueOfString[] | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectedCountries);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetSelectedCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetSelectedCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string | null | undefined): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetValue?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetValue(<any>response_);
                } catch (e) {
                    return <Observable<StringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringOutput.fromJS(resultData200) : new StringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringOutput>(<any>null);
    }
}

@Injectable()
export class DepartmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param subbrId (optional) 
     * @return Success
     */
    cM_DEPARTMENT_Combobox(subbrId: string | null | undefined): Observable<CM_DEPARTMENT_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Department/CM_DEPARTMENT_Combobox?";
        if (subbrId !== undefined)
            url_ += "subbrId=" + encodeURIComponent("" + subbrId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPARTMENT_Combobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPARTMENT_Combobox(<any>response_);
                } catch (e) {
                    return <Observable<CM_DEPARTMENT_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_DEPARTMENT_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPARTMENT_Combobox(response: HttpResponseBase): Observable<CM_DEPARTMENT_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_DEPARTMENT_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_DEPARTMENT_ENTITY[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_DEPARTMENT_Search(input: CM_DEPARTMENT_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_DEPARTMENT_ENTITY> {
        let url_ = this.baseUrl + "/api/Department/CM_DEPARTMENT_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPARTMENT_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPARTMENT_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_DEPARTMENT_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_DEPARTMENT_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPARTMENT_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_DEPARTMENT_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_DEPARTMENT_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_DEPARTMENT_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_DEPARTMENT_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_DEPARTMENT_ToExcel(input: CM_DEPARTMENT_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Department/CM_DEPARTMENT_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPARTMENT_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPARTMENT_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPARTMENT_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_DEPARTMENT_Ins(input: CM_DEPARTMENT_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Department/CM_DEPARTMENT_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPARTMENT_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPARTMENT_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPARTMENT_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_DEPARTMENT_Upd(input: CM_DEPARTMENT_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Department/CM_DEPARTMENT_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPARTMENT_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPARTMENT_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPARTMENT_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_DEPARTMENT_ById(id: string | null | undefined): Observable<CM_DEPARTMENT_ENTITY> {
        let url_ = this.baseUrl + "/api/Department/CM_DEPARTMENT_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPARTMENT_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPARTMENT_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_DEPARTMENT_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_DEPARTMENT_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPARTMENT_ById(response: HttpResponseBase): Observable<CM_DEPARTMENT_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_DEPARTMENT_ENTITY.fromJS(resultData200) : new CM_DEPARTMENT_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_DEPARTMENT_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_DEPARTMENT_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Department/CM_DEPARTMENT_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPARTMENT_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPARTMENT_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPARTMENT_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_DEPARTMENT_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Department/CM_DEPARTMENT_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPARTMENT_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPARTMENT_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPARTMENT_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class DeptGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_DEPT_GROUP_Search(input: CM_DEPT_GROUP_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_DEPT_GROUP_ENTITY> {
        let url_ = this.baseUrl + "/api/DeptGroup/CM_DEPT_GROUP_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPT_GROUP_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPT_GROUP_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_DEPT_GROUP_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_DEPT_GROUP_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPT_GROUP_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_DEPT_GROUP_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_DEPT_GROUP_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_DEPT_GROUP_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_DEPT_GROUP_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_DEPT_GROUP_ToExcel(input: CM_DEPT_GROUP_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/DeptGroup/CM_DEPT_GROUP_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPT_GROUP_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPT_GROUP_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPT_GROUP_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_DEPT_GROUP_Ins(input: CM_DEPT_GROUP_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/DeptGroup/CM_DEPT_GROUP_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPT_GROUP_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPT_GROUP_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPT_GROUP_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_DEPT_GROUP_Upd(input: CM_DEPT_GROUP_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/DeptGroup/CM_DEPT_GROUP_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPT_GROUP_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPT_GROUP_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPT_GROUP_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_DEPT_GROUP_ById(id: string | null | undefined): Observable<CM_DEPT_GROUP_ENTITY> {
        let url_ = this.baseUrl + "/api/DeptGroup/CM_DEPT_GROUP_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPT_GROUP_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPT_GROUP_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_DEPT_GROUP_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_DEPT_GROUP_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPT_GROUP_ById(response: HttpResponseBase): Observable<CM_DEPT_GROUP_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_DEPT_GROUP_ENTITY.fromJS(resultData200) : new CM_DEPT_GROUP_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_DEPT_GROUP_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_DEPT_GROUP_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/DeptGroup/CM_DEPT_GROUP_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPT_GROUP_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPT_GROUP_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPT_GROUP_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_DEPT_GROUP_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/DeptGroup/CM_DEPT_GROUP_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPT_GROUP_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPT_GROUP_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPT_GROUP_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class DistributionDeleteListServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    dISTRIBUTION_DELETE_LIST_Search(input: DISTRIBUTION_DELETE_LIST_ENTITY | null | undefined): Observable<PagedResultDtoOfDISTRIBUTION_DELETE_LIST_ENTITY> {
        let url_ = this.baseUrl + "/api/DistributionDeleteList/DISTRIBUTION_DELETE_LIST_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDISTRIBUTION_DELETE_LIST_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDISTRIBUTION_DELETE_LIST_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDISTRIBUTION_DELETE_LIST_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDISTRIBUTION_DELETE_LIST_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processDISTRIBUTION_DELETE_LIST_Search(response: HttpResponseBase): Observable<PagedResultDtoOfDISTRIBUTION_DELETE_LIST_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDISTRIBUTION_DELETE_LIST_ENTITY.fromJS(resultData200) : new PagedResultDtoOfDISTRIBUTION_DELETE_LIST_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDISTRIBUTION_DELETE_LIST_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    dISTRIBUTION_DELETE_LIST_ById(input: DISTRIBUTION_DELETE_LIST_ENTITY | null | undefined): Observable<DISTRIBUTION_DELETE_LIST_ENTITY> {
        let url_ = this.baseUrl + "/api/DistributionDeleteList/DISTRIBUTION_DELETE_LIST_ById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDISTRIBUTION_DELETE_LIST_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDISTRIBUTION_DELETE_LIST_ById(<any>response_);
                } catch (e) {
                    return <Observable<DISTRIBUTION_DELETE_LIST_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<DISTRIBUTION_DELETE_LIST_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processDISTRIBUTION_DELETE_LIST_ById(response: HttpResponseBase): Observable<DISTRIBUTION_DELETE_LIST_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DISTRIBUTION_DELETE_LIST_ENTITY.fromJS(resultData200) : new DISTRIBUTION_DELETE_LIST_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DISTRIBUTION_DELETE_LIST_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    dISTRIBUTION_DELETE_LIST_Ins(input: DISTRIBUTION_DELETE_LIST_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/DistributionDeleteList/DISTRIBUTION_DELETE_LIST_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDISTRIBUTION_DELETE_LIST_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDISTRIBUTION_DELETE_LIST_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processDISTRIBUTION_DELETE_LIST_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    dISTRIBUTION_DELETE_LIST_Upd(input: DISTRIBUTION_DELETE_LIST_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/DistributionDeleteList/DISTRIBUTION_DELETE_LIST_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDISTRIBUTION_DELETE_LIST_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDISTRIBUTION_DELETE_LIST_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processDISTRIBUTION_DELETE_LIST_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    dISTRIBUTION_DELETE_LIST_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/DistributionDeleteList/DISTRIBUTION_DELETE_LIST_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDISTRIBUTION_DELETE_LIST_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDISTRIBUTION_DELETE_LIST_App(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processDISTRIBUTION_DELETE_LIST_App(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    dISTRIBUTION_DELETE_LIST_Del(id: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/DistributionDeleteList/DISTRIBUTION_DELETE_LIST_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDISTRIBUTION_DELETE_LIST_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDISTRIBUTION_DELETE_LIST_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processDISTRIBUTION_DELETE_LIST_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class DistributionExecuteListServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    dISTRIBUTION_EXECUTE_LIST_Search(input: DISTRIBUTION_EXECUTE_LIST_ENTITY | null | undefined): Observable<PagedResultDtoOfDISTRIBUTION_EXECUTE_LIST_ENTITY> {
        let url_ = this.baseUrl + "/api/DistributionExecuteList/DISTRIBUTION_EXECUTE_LIST_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDISTRIBUTION_EXECUTE_LIST_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDISTRIBUTION_EXECUTE_LIST_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDISTRIBUTION_EXECUTE_LIST_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDISTRIBUTION_EXECUTE_LIST_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processDISTRIBUTION_EXECUTE_LIST_Search(response: HttpResponseBase): Observable<PagedResultDtoOfDISTRIBUTION_EXECUTE_LIST_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDISTRIBUTION_EXECUTE_LIST_ENTITY.fromJS(resultData200) : new PagedResultDtoOfDISTRIBUTION_EXECUTE_LIST_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDISTRIBUTION_EXECUTE_LIST_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    dISTRIBUTION_EXECUTE_LIST_ById(input: DISTRIBUTION_EXECUTE_LIST_ENTITY | null | undefined): Observable<DISTRIBUTION_EXECUTE_LIST_ENTITY> {
        let url_ = this.baseUrl + "/api/DistributionExecuteList/DISTRIBUTION_EXECUTE_LIST_ById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDISTRIBUTION_EXECUTE_LIST_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDISTRIBUTION_EXECUTE_LIST_ById(<any>response_);
                } catch (e) {
                    return <Observable<DISTRIBUTION_EXECUTE_LIST_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<DISTRIBUTION_EXECUTE_LIST_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processDISTRIBUTION_EXECUTE_LIST_ById(response: HttpResponseBase): Observable<DISTRIBUTION_EXECUTE_LIST_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DISTRIBUTION_EXECUTE_LIST_ENTITY.fromJS(resultData200) : new DISTRIBUTION_EXECUTE_LIST_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DISTRIBUTION_EXECUTE_LIST_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    dISTRIBUTION_EXECUTE_LIST_Ins(input: DISTRIBUTION_EXECUTE_LIST_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/DistributionExecuteList/DISTRIBUTION_EXECUTE_LIST_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDISTRIBUTION_EXECUTE_LIST_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDISTRIBUTION_EXECUTE_LIST_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processDISTRIBUTION_EXECUTE_LIST_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    dISTRIBUTION_EXECUTE_LIST_Upd(input: DISTRIBUTION_EXECUTE_LIST_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/DistributionExecuteList/DISTRIBUTION_EXECUTE_LIST_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDISTRIBUTION_EXECUTE_LIST_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDISTRIBUTION_EXECUTE_LIST_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processDISTRIBUTION_EXECUTE_LIST_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    dISTRIBUTION_EXECUTE_LIST_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/DistributionExecuteList/DISTRIBUTION_EXECUTE_LIST_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDISTRIBUTION_EXECUTE_LIST_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDISTRIBUTION_EXECUTE_LIST_App(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processDISTRIBUTION_EXECUTE_LIST_App(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    dISTRIBUTION_EXECUTE_LIST_Del(id: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/DistributionExecuteList/DISTRIBUTION_EXECUTE_LIST_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDISTRIBUTION_EXECUTE_LIST_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDISTRIBUTION_EXECUTE_LIST_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processDISTRIBUTION_EXECUTE_LIST_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class DivisionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_DIVISION_Search(input: CM_DIVISION_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_DIVISION_ENTITY> {
        let url_ = this.baseUrl + "/api/Division/CM_DIVISION_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DIVISION_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DIVISION_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_DIVISION_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_DIVISION_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DIVISION_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_DIVISION_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_DIVISION_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_DIVISION_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_DIVISION_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_DIVISION_ToExcel(input: CM_DIVISION_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Division/CM_DIVISION_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DIVISION_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DIVISION_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DIVISION_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_DIVISION_Ins(input: CM_DIVISION_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Division/CM_DIVISION_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DIVISION_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DIVISION_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DIVISION_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_DIVISION_Upd(input: CM_DIVISION_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Division/CM_DIVISION_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DIVISION_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DIVISION_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DIVISION_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_DIVISION_ById(id: string | null | undefined): Observable<CM_DIVISION_ENTITY> {
        let url_ = this.baseUrl + "/api/Division/CM_DIVISION_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DIVISION_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DIVISION_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_DIVISION_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_DIVISION_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DIVISION_ById(response: HttpResponseBase): Observable<CM_DIVISION_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_DIVISION_ENTITY.fromJS(resultData200) : new CM_DIVISION_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_DIVISION_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_DIVISION_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Division/CM_DIVISION_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DIVISION_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DIVISION_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DIVISION_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_DIVISION_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Division/CM_DIVISION_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DIVISION_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DIVISION_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DIVISION_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param parentId (optional) 
     * @return Success
     */
    cM_DIVISION_GETALLCHILD(parentId: string | null | undefined): Observable<CM_DIVISION_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Division/CM_DIVISION_GETALLCHILD?";
        if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DIVISION_GETALLCHILD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DIVISION_GETALLCHILD(<any>response_);
                } catch (e) {
                    return <Observable<CM_DIVISION_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_DIVISION_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DIVISION_GETALLCHILD(response: HttpResponseBase): Observable<CM_DIVISION_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_DIVISION_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_DIVISION_ENTITY[]>(<any>null);
    }
}

@Injectable()
export class DRColumnServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param columns (optional) 
     * @return Success
     */
    insert(columns: DRColumnDto[] | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DRColumn/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(columns);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    listColumnByReportDelete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRColumn/ListColumnByReportDelete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListColumnByReportDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListColumnByReportDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processListColumnByReportDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getByID(id: number | null | undefined): Observable<DRColumnDto> {
        let url_ = this.baseUrl + "/api/DRColumn/GetByID?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<DRColumnDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DRColumnDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<DRColumnDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DRColumnDto.fromJS(resultData200) : new DRColumnDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DRColumnDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param data (optional) 
     * @return Success
     */
    updateFilter(id: number | null | undefined, data: DRColumnDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRColumn/UpdateFilter?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFilter(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateFilter(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param reportId (optional) 
     * @param sqlContent (optional) 
     * @return Success
     */
    checkSQLWithParam(reportId: number | null | undefined, sqlContent: string | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DRColumn/CheckSQLWithParam?";
        if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&"; 
        if (sqlContent !== undefined)
            url_ += "sqlContent=" + encodeURIComponent("" + sqlContent) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckSQLWithParam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckSQLWithParam(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processCheckSQLWithParam(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param reportId (optional) 
     * @param sqlContent (optional) 
     * @return Success
     */
    getColumn(reportId: number | null | undefined, sqlContent: string | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DRColumn/GetColumn?";
        if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&"; 
        if (sqlContent !== undefined)
            url_ += "sqlContent=" + encodeURIComponent("" + sqlContent) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetColumn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetColumn(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetColumn(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param reportId (optional) 
     * @return Success
     */
    getByReportId(reportId: number | null | undefined): Observable<DRColumnDto[]> {
        let url_ = this.baseUrl + "/api/DRColumn/GetByReportId?";
        if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByReportId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByReportId(<any>response_);
                } catch (e) {
                    return <Observable<DRColumnDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DRColumnDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetByReportId(response: HttpResponseBase): Observable<DRColumnDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DRColumnDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DRColumnDto[]>(<any>null);
    }
}

@Injectable()
export class DRChartServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getByReportID(id: number | null | undefined): Observable<DRChartDto> {
        let url_ = this.baseUrl + "/api/DRChart/GetByReportID?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByReportID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByReportID(<any>response_);
                } catch (e) {
                    return <Observable<DRChartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DRChartDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByReportID(response: HttpResponseBase): Observable<DRChartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DRChartDto.fromJS(resultData200) : new DRChartDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DRChartDto>(<any>null);
    }

    /**
     * @param data (optional) 
     * @return Success
     */
    update(data: DRChartDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRChart/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param data (optional) 
     * @return Success
     */
    insert(data: DRChartDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRChart/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DRDataSourceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param data (optional) 
     * @return Success
     */
    createDataSource(data: DRDataSourceDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/DRDataSource/CreateDataSource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDataSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDataSource(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDataSource(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDataSource(id: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/DRDataSource/DeleteDataSource?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDataSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDataSource(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDataSource(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getByID(id: number | null | undefined): Observable<DRDataSourceDto> {
        let url_ = this.baseUrl + "/api/DRDataSource/GetByID?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<DRDataSourceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DRDataSourceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<DRDataSourceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DRDataSourceDto.fromJS(resultData200) : new DRDataSourceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DRDataSourceDto>(<any>null);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    getByName(name: string | null | undefined): Observable<DRDataSourceDto[]> {
        let url_ = this.baseUrl + "/api/DRDataSource/GetByName?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByName(<any>response_);
                } catch (e) {
                    return <Observable<DRDataSourceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DRDataSourceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetByName(response: HttpResponseBase): Observable<DRDataSourceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DRDataSourceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DRDataSourceDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param data (optional) 
     * @return Success
     */
    updateDataSource(id: number | null | undefined, data: DRDataSourceDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRDataSource/UpdateDataSource?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDataSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDataSource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDataSource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param data (optional) 
     * @return Success
     */
    insertDetail(data: DRDataSourceDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRDataSource/InsertDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertDetail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsertDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param data (optional) 
     * @return Success
     */
    updateDataSourceDetail(data: DRDataSourceDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRDataSource/UpdateDataSourceDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDataSourceDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDataSourceDetail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDataSourceDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDataSourceValue(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRDataSource/DeleteDataSourceValue?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDataSourceValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDataSourceValue(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDataSourceValue(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param dataSourceID (optional) 
     * @return Success
     */
    getDetailDataSource(dataSourceID: number | null | undefined): Observable<DRDataSourceDetailDto> {
        let url_ = this.baseUrl + "/api/DRDataSource/GetDetailDataSource?";
        if (dataSourceID !== undefined)
            url_ += "DataSourceID=" + encodeURIComponent("" + dataSourceID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailDataSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailDataSource(<any>response_);
                } catch (e) {
                    return <Observable<DRDataSourceDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DRDataSourceDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetailDataSource(response: HttpResponseBase): Observable<DRDataSourceDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DRDataSourceDetailDto.fromJS(resultData200) : new DRDataSourceDetailDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DRDataSourceDetailDto>(<any>null);
    }

    /**
     * @param dataSourceID (optional) 
     * @return Success
     */
    getDetailDataSourceValue(dataSourceID: number | null | undefined): Observable<DRDataSourceDetailDto> {
        let url_ = this.baseUrl + "/api/DRDataSource/GetDetailDataSourceValue?";
        if (dataSourceID !== undefined)
            url_ += "DataSourceID=" + encodeURIComponent("" + dataSourceID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailDataSourceValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailDataSourceValue(<any>response_);
                } catch (e) {
                    return <Observable<DRDataSourceDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DRDataSourceDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetailDataSourceValue(response: HttpResponseBase): Observable<DRDataSourceDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DRDataSourceDetailDto.fromJS(resultData200) : new DRDataSourceDetailDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DRDataSourceDetailDto>(<any>null);
    }
}

@Injectable()
export class DRDynamicFieldServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DRDynamicField/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }
}

@Injectable()
export class DRFilterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param data (optional) 
     * @return Success
     */
    createFilter(data: DRFilterDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/DRFilter/CreateFilter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFilter(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFilter(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    filterDelete(id: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/DRFilter/FilterDelete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFilterDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFilterDelete(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processFilterDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getByID(id: number | null | undefined): Observable<DRFilterDto> {
        let url_ = this.baseUrl + "/api/DRFilter/GetByID?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<DRFilterDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DRFilterDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<DRFilterDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DRFilterDto.fromJS(resultData200) : new DRFilterDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DRFilterDto>(<any>null);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    getByName(name: string | null | undefined): Observable<DRFilterDto[]> {
        let url_ = this.baseUrl + "/api/DRFilter/GetByName?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByName(<any>response_);
                } catch (e) {
                    return <Observable<DRFilterDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DRFilterDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetByName(response: HttpResponseBase): Observable<DRFilterDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DRFilterDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DRFilterDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param data (optional) 
     * @return Success
     */
    updateFilter(id: number | null | undefined, data: DRFilterDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRFilter/UpdateFilter?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFilter(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateFilter(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param reportId (optional) 
     * @return Success
     */
    getFiltersByReportId(reportId: number | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DRFilter/GetFiltersByReportId?";
        if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFiltersByReportId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFiltersByReportId(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetFiltersByReportId(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param reportId (optional) 
     * @return Success
     */
    getFilterIsCombobox(reportId: number | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DRFilter/GetFilterIsCombobox?";
        if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilterIsCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilterIsCombobox(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetFilterIsCombobox(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param reportId (optional) 
     * @return Success
     */
    getFilterIsTagbox(reportId: number | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DRFilter/GetFilterIsTagbox?";
        if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilterIsTagbox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilterIsTagbox(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetFilterIsTagbox(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }
}

@Injectable()
export class DRLookUpServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param data (optional) 
     * @return Success
     */
    createLookup(data: DRLookUpDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/DRLookUp/CreateLookup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLookup(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLookup(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param data (optional) 
     * @return Success
     */
    updateLookup(id: number | null | undefined, data: DRLookUpDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRLookUp/UpdateLookup?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLookup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLookup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLookup(id: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/DRLookUp/DeleteLookup?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLookup(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLookup(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    getByName(name: string | null | undefined): Observable<DRLookUpDto[]> {
        let url_ = this.baseUrl + "/api/DRLookUp/GetByName?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByName(<any>response_);
                } catch (e) {
                    return <Observable<DRLookUpDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DRLookUpDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetByName(response: HttpResponseBase): Observable<DRLookUpDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DRLookUpDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DRLookUpDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getByID(id: number | null | undefined): Observable<DRLookUpDto> {
        let url_ = this.baseUrl + "/api/DRLookUp/GetByID?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<DRLookUpDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DRLookUpDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<DRLookUpDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DRLookUpDto.fromJS(resultData200) : new DRLookUpDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DRLookUpDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLookupValue(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRLookUp/DeleteLookupValue?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLookupValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLookupValue(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLookupValue(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param data (optional) 
     * @return Success
     */
    insertDetail(data: DRLookupDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRLookUp/InsertDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertDetail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsertDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param data (optional) 
     * @return Success
     */
    updateLookupDetail(data: DRLookupDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRLookUp/UpdateLookupDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLookupDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLookupDetail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLookupDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param lookupID (optional) 
     * @param input (optional) 
     * @return Success
     */
    getDetailLookup(lookupID: number | null | undefined, input: SearchInputLookup | null | undefined): Observable<DRLookupDetailDto[]> {
        let url_ = this.baseUrl + "/api/DRLookUp/GetDetailLookup?";
        if (lookupID !== undefined)
            url_ += "lookupID=" + encodeURIComponent("" + lookupID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailLookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailLookup(<any>response_);
                } catch (e) {
                    return <Observable<DRLookupDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DRLookupDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetailLookup(response: HttpResponseBase): Observable<DRLookupDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DRLookupDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DRLookupDetailDto[]>(<any>null);
    }

    /**
     * @param lookupID (optional) 
     * @return Success
     */
    getDetailLookupValue(lookupID: number | null | undefined): Observable<DRLookupDetailDto> {
        let url_ = this.baseUrl + "/api/DRLookUp/GetDetailLookupValue?";
        if (lookupID !== undefined)
            url_ += "lookupID=" + encodeURIComponent("" + lookupID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailLookupValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailLookupValue(<any>response_);
                } catch (e) {
                    return <Observable<DRLookupDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DRLookupDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetailLookupValue(response: HttpResponseBase): Observable<DRLookupDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DRLookupDetailDto.fromJS(resultData200) : new DRLookupDetailDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DRLookupDetailDto>(<any>null);
    }

    /**
     * @param lookupID (optional) 
     * @return Success
     */
    getAllLookupDetail(lookupID: number | null | undefined): Observable<DRLookupDetailDto[]> {
        let url_ = this.baseUrl + "/api/DRLookUp/GetAllLookupDetail?";
        if (lookupID !== undefined)
            url_ += "lookupID=" + encodeURIComponent("" + lookupID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLookupDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLookupDetail(<any>response_);
                } catch (e) {
                    return <Observable<DRLookupDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DRLookupDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLookupDetail(response: HttpResponseBase): Observable<DRLookupDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DRLookupDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DRLookupDetailDto[]>(<any>null);
    }
}

@Injectable()
export class DRReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: DRReportDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRReport/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: DRReportDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRReport/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRReport/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    search(input: SearchInput | null | undefined): Observable<DRReportDto[]> {
        let url_ = this.baseUrl + "/api/DRReport/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<DRReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DRReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<DRReportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DRReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DRReportDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DRReport/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    getIdByCode(code: string | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DRReport/GetIdByCode?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIdByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIdByCode(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetIdByCode(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sql (optional) 
     * @return Success
     */
    updateSql(id: number | null | undefined, sql: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRReport/UpdateSql?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (sql !== undefined)
            url_ += "sql=" + encodeURIComponent("" + sql) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSql(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSql(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSql(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    returnParameter(): Observable<Parameter> {
        let url_ = this.baseUrl + "/api/DRReport/ReturnParameter";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReturnParameter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReturnParameter(<any>response_);
                } catch (e) {
                    return <Observable<Parameter>><any>_observableThrow(e);
                }
            } else
                return <Observable<Parameter>><any>_observableThrow(response_);
        }));
    }

    protected processReturnParameter(response: HttpResponseBase): Observable<Parameter> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Parameter.fromJS(resultData200) : new Parameter();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Parameter>(<any>null);
    }

    /**
     * @param files (optional) 
     * @return Success
     */
    eXCELuploadFile(files: IFormFile[] | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DRReport/EXCELuploadFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            content_.append("files", files.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEXCELuploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEXCELuploadFile(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processEXCELuploadFile(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param files (optional) 
     * @return Success
     */
    wORDuploadFile(files: IFormFile[] | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DRReport/WORDuploadFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            content_.append("files", files.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWORDuploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWORDuploadFile(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processWORDuploadFile(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }
}

@Injectable()
export class DRServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: DRServiceDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRService/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRService/Delete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: DRServiceDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | null | undefined): Observable<DRServiceDto> {
        let url_ = this.baseUrl + "/api/DRService/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<DRServiceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DRServiceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<DRServiceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DRServiceDto.fromJS(resultData200) : new DRServiceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DRServiceDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getByName(input: string | null | undefined): Observable<DRServiceDto[]> {
        let url_ = this.baseUrl + "/api/DRService/GetByName?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByName(<any>response_);
                } catch (e) {
                    return <Observable<DRServiceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DRServiceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetByName(response: HttpResponseBase): Observable<DRServiceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DRServiceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DRServiceDto[]>(<any>null);
    }

    /**
     * @param filterId (optional) 
     * @param reportId (optional) 
     * @return Success
     */
    executeService(filterId: number | null | undefined, reportId: number | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DRService/ExecuteService?";
        if (filterId !== undefined)
            url_ += "filterId=" + encodeURIComponent("" + filterId) + "&"; 
        if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExecuteService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExecuteService(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processExecuteService(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param filterId (optional) 
     * @param reportId (optional) 
     * @param data (optional) 
     * @return Success
     */
    executeServiceWithParam(filterId: number | null | undefined, reportId: number | null | undefined, data: Parameter | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DRService/ExecuteServiceWithParam?";
        if (filterId !== undefined)
            url_ += "filterId=" + encodeURIComponent("" + filterId) + "&"; 
        if (reportId !== undefined)
            url_ += "reportId=" + encodeURIComponent("" + reportId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExecuteServiceWithParam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExecuteServiceWithParam(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processExecuteServiceWithParam(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }
}

@Injectable()
export class DRViewerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @param param (optional) 
     * @return Success
     */
    postData(id: number | null | undefined, param: FParameter[] | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DRViewer/PostData?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(param);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostData(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processPostData(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param param (optional) 
     * @return Success
     */
    postDataNow(id: number | null | undefined, param: FParameter[] | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DRViewer/PostDataNow?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(param);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostDataNow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostDataNow(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processPostDataNow(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param templatePathFile (optional) 
     * @param param (optional) 
     * @return Success
     */
    exportWord(id: number | null | undefined, templatePathFile: string | null | undefined, param: FParameter[] | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/DRViewer/ExportWord?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (templatePathFile !== undefined)
            url_ += "templatePathFile=" + encodeURIComponent("" + templatePathFile) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(param);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportWord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportWord(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processExportWord(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param reportID (optional) 
     * @return Success
     */
    dRGetTemplateWordFile(reportID: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRViewer/DRGetTemplateWordFile?";
        if (reportID !== undefined)
            url_ += "reportID=" + encodeURIComponent("" + reportID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDRGetTemplateWordFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDRGetTemplateWordFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDRGetTemplateWordFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param reportID (optional) 
     * @return Success
     */
    dRGetTemplateFile(reportID: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DRViewer/DRGetTemplateFile?";
        if (reportID !== undefined)
            url_ += "reportID=" + encodeURIComponent("" + reportID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDRGetTemplateFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDRGetTemplateFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDRGetTemplateFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DynamicCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_DYNAMIC_CATEGORY_Search(input: CM_DYNAMIC_CATEGORY_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_DYNAMIC_CATEGORY_ENTITY> {
        let url_ = this.baseUrl + "/api/DynamicCategory/CM_DYNAMIC_CATEGORY_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DYNAMIC_CATEGORY_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DYNAMIC_CATEGORY_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_DYNAMIC_CATEGORY_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_DYNAMIC_CATEGORY_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DYNAMIC_CATEGORY_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_DYNAMIC_CATEGORY_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_DYNAMIC_CATEGORY_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_DYNAMIC_CATEGORY_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_DYNAMIC_CATEGORY_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_DYNAMIC_CATEGORY_Ins(input: CM_DYNAMIC_CATEGORY_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/DynamicCategory/CM_DYNAMIC_CATEGORY_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DYNAMIC_CATEGORY_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DYNAMIC_CATEGORY_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DYNAMIC_CATEGORY_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_DYNAMIC_CATEGORY_Upd(input: CM_DYNAMIC_CATEGORY_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/DynamicCategory/CM_DYNAMIC_CATEGORY_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DYNAMIC_CATEGORY_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DYNAMIC_CATEGORY_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DYNAMIC_CATEGORY_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_DYNAMIC_CATEGORY_ById(id: number | null | undefined): Observable<CM_DYNAMIC_CATEGORY_ENTITY> {
        let url_ = this.baseUrl + "/api/DynamicCategory/CM_DYNAMIC_CATEGORY_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DYNAMIC_CATEGORY_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DYNAMIC_CATEGORY_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_DYNAMIC_CATEGORY_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_DYNAMIC_CATEGORY_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DYNAMIC_CATEGORY_ById(response: HttpResponseBase): Observable<CM_DYNAMIC_CATEGORY_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_DYNAMIC_CATEGORY_ENTITY.fromJS(resultData200) : new CM_DYNAMIC_CATEGORY_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_DYNAMIC_CATEGORY_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_DYNAMIC_CATEGORY_Del(id: number | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/DynamicCategory/CM_DYNAMIC_CATEGORY_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DYNAMIC_CATEGORY_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DYNAMIC_CATEGORY_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DYNAMIC_CATEGORY_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfEditionListDto.fromJS(resultData200) : new ListResultDtoOfEditionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEditionListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionEditOutput.fromJS(resultData200) : new GetEditionEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createEdition(input: CreateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateEdition(input: UpdateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/UpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEdition(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveTenantsToAnotherEdition(input: MoveTenantsToAnotherEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/MoveTenantsToAnotherEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveTenantsToAnotherEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTenantsToAnotherEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | null | undefined, addAllItem: boolean | null | undefined, onlyFreeItems: boolean | null | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&"; 
        if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&"; 
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getTenantCount(editionId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetTenantCount?";
        if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class EmployeeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_EMPLOYEE_Search(input: CM_EMPLOYEE_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_EMPLOYEE_ENTITY> {
        let url_ = this.baseUrl + "/api/Employee/CM_EMPLOYEE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_EMPLOYEE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_EMPLOYEE_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_EMPLOYEE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_EMPLOYEE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_EMPLOYEE_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_EMPLOYEE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_EMPLOYEE_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_EMPLOYEE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_EMPLOYEE_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    mT_CAMPAIGN_Search(input: MT_CAMPAIGN_ENTITY | null | undefined): Observable<PagedResultDtoOfMT_CAMPAIGN_ENTITY> {
        let url_ = this.baseUrl + "/api/Employee/MT_CAMPAIGN_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMT_CAMPAIGN_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMT_CAMPAIGN_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMT_CAMPAIGN_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMT_CAMPAIGN_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processMT_CAMPAIGN_Search(response: HttpResponseBase): Observable<PagedResultDtoOfMT_CAMPAIGN_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfMT_CAMPAIGN_ENTITY.fromJS(resultData200) : new PagedResultDtoOfMT_CAMPAIGN_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMT_CAMPAIGN_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_EMPLOYEE_Ins(input: CM_EMPLOYEE_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Employee/CM_EMPLOYEE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_EMPLOYEE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_EMPLOYEE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_EMPLOYEE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_EMPLOYEE_Upd(input: CM_EMPLOYEE_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Employee/CM_EMPLOYEE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_EMPLOYEE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_EMPLOYEE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_EMPLOYEE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_EMPLOYEE_ById(id: string | null | undefined): Observable<CM_EMPLOYEE_ENTITY> {
        let url_ = this.baseUrl + "/api/Employee/CM_EMPLOYEE_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_EMPLOYEE_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_EMPLOYEE_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_EMPLOYEE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_EMPLOYEE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_EMPLOYEE_ById(response: HttpResponseBase): Observable<CM_EMPLOYEE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_EMPLOYEE_ENTITY.fromJS(resultData200) : new CM_EMPLOYEE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_EMPLOYEE_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_EMPLOYEE_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Employee/CM_EMPLOYEE_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_EMPLOYEE_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_EMPLOYEE_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_EMPLOYEE_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_EMPLOYEE_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Employee/CM_EMPLOYEE_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_EMPLOYEE_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_EMPLOYEE_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_EMPLOYEE_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class ExecQueryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param queryString (optional) 
     * @return Success
     */
    execQuery(queryString: ExecQueryDto | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/ExecQuery/ExecQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(queryString);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExecQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExecQuery(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processExecQuery(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createFriendshipRequest(input: CreateFriendshipRequestInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(input: CreateFriendshipRequestByUserNameInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    blockUser(input: BlockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unblockUser(input: UnblockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    acceptFriendshipRequest(input: AcceptFriendshipRequestInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class GoodsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_GOODS_Search(input: CM_GOODS_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_GOODS_ENTITY> {
        let url_ = this.baseUrl + "/api/Goods/CM_GOODS_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODS_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODS_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_GOODS_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_GOODS_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODS_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_GOODS_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_GOODS_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_GOODS_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_GOODS_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_GOODS_ToExcel(input: CM_GOODS_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Goods/CM_GOODS_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODS_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODS_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODS_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_GOODS_Ins(input: CM_GOODS_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Goods/CM_GOODS_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODS_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODS_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODS_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_GOODS_Upd(input: CM_GOODS_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Goods/CM_GOODS_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODS_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODS_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODS_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_GOODS_ById(id: string | null | undefined): Observable<CM_GOODS_ENTITY> {
        let url_ = this.baseUrl + "/api/Goods/CM_GOODS_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODS_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODS_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_GOODS_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_GOODS_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODS_ById(response: HttpResponseBase): Observable<CM_GOODS_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_GOODS_ENTITY.fromJS(resultData200) : new CM_GOODS_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_GOODS_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_GOODS_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Goods/CM_GOODS_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODS_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODS_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODS_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_GOODS_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Goods/CM_GOODS_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODS_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODS_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODS_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class GoodsTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_GOODSTYPE_Search(input: CM_GOODSTYPE_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_GOODSTYPE_ENTITY> {
        let url_ = this.baseUrl + "/api/GoodsType/CM_GOODSTYPE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_GOODSTYPE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_GOODSTYPE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_GOODSTYPE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_GOODSTYPE_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_GOODSTYPE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_GOODSTYPE_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_GOODSTYPE_Ins(input: CM_GOODSTYPE_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/GoodsType/CM_GOODSTYPE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_GOODSTYPE_Upd(input: CM_GOODSTYPE_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/GoodsType/CM_GOODSTYPE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_GOODSTYPE_ById(id: string | null | undefined): Observable<CM_GOODSTYPE_ENTITY> {
        let url_ = this.baseUrl + "/api/GoodsType/CM_GOODSTYPE_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_GOODSTYPE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_GOODSTYPE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_ById(response: HttpResponseBase): Observable<CM_GOODSTYPE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_GOODSTYPE_ENTITY.fromJS(resultData200) : new CM_GOODSTYPE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_GOODSTYPE_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_GOODSTYPE_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/GoodsType/CM_GOODSTYPE_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_GOODSTYPE_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/GoodsType/CM_GOODSTYPE_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @return Success
     */
    getConnectionStringDecryption(): Observable<string> {
        let url_ = this.baseUrl + "/api/GoodsType/GetConnectionStringDecryption";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConnectionStringDecryption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConnectionStringDecryption(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetConnectionStringDecryption(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param key (optional) 
     * @return Success
     */
    getSampleConfig(key: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/GoodsType/GetSampleConfig?";
        if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSampleConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSampleConfig(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSampleConfig(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getClientIpAddress(): Observable<string> {
        let url_ = this.baseUrl + "/api/GoodsType/GetClientIpAddress";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientIpAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientIpAddress(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientIpAddress(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class GoodsTypeRealServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_GOODSTYPE_REAL_Search(input: CM_GOODSTYPE_REAL_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY> {
        let url_ = this.baseUrl + "/api/GoodsTypeReal/CM_GOODSTYPE_REAL_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_REAL_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_REAL_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_REAL_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_GOODSTYPE_REAL_ToExcel(input: CM_GOODSTYPE_REAL_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/GoodsTypeReal/CM_GOODSTYPE_REAL_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_REAL_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_REAL_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_REAL_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_GOODSTYPE_REAL_Ins(input: CM_GOODSTYPE_REAL_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/GoodsTypeReal/CM_GOODSTYPE_REAL_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_REAL_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_REAL_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_REAL_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_GOODSTYPE_REAL_Upd(input: CM_GOODSTYPE_REAL_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/GoodsTypeReal/CM_GOODSTYPE_REAL_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_REAL_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_REAL_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_REAL_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_GOODSTYPE_REAL_ById(id: string | null | undefined): Observable<CM_GOODSTYPE_REAL_ENTITY> {
        let url_ = this.baseUrl + "/api/GoodsTypeReal/CM_GOODSTYPE_REAL_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_REAL_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_REAL_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_GOODSTYPE_REAL_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_GOODSTYPE_REAL_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_REAL_ById(response: HttpResponseBase): Observable<CM_GOODSTYPE_REAL_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_GOODSTYPE_REAL_ENTITY.fromJS(resultData200) : new CM_GOODSTYPE_REAL_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_GOODSTYPE_REAL_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_GOODSTYPE_REAL_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/GoodsTypeReal/CM_GOODSTYPE_REAL_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_REAL_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_REAL_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_REAL_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_GOODSTYPE_REAL_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/GoodsTypeReal/CM_GOODSTYPE_REAL_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_REAL_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_REAL_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_REAL_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @return Success
     */
    getClientIpAddress(): Observable<string> {
        let url_ = this.baseUrl + "/api/GoodsTypeReal/GetClientIpAddress";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientIpAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientIpAddress(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientIpAddress(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class HopDongServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_HOPDONG_Search(input: HR_HopDong_ENTITY | null | undefined): Observable<PagedResultDtoOfHR_HopDong_ENTITY> {
        let url_ = this.baseUrl + "/api/HopDong/HR_HOPDONG_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_HOPDONG_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_HOPDONG_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfHR_HopDong_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfHR_HopDong_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_HOPDONG_Search(response: HttpResponseBase): Observable<PagedResultDtoOfHR_HopDong_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfHR_HopDong_ENTITY.fromJS(resultData200) : new PagedResultDtoOfHR_HopDong_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfHR_HopDong_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_HOPDONG_ToExcel(input: HR_HopDong_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/HopDong/HR_HOPDONG_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_HOPDONG_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_HOPDONG_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processHR_HOPDONG_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_HOPDONG_Ins(input: HR_HopDong_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/HopDong/HR_HOPDONG_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_HOPDONG_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_HOPDONG_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_HOPDONG_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_HOPDONG_Upd(input: HR_HopDong_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/HopDong/HR_HOPDONG_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_HOPDONG_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_HOPDONG_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_HOPDONG_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_HOPDONG_ById(id: string | null | undefined): Observable<HR_HopDong_ENTITY> {
        let url_ = this.baseUrl + "/api/HopDong/HR_HOPDONG_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_HOPDONG_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_HOPDONG_ById(<any>response_);
                } catch (e) {
                    return <Observable<HR_HopDong_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_HopDong_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_HOPDONG_ById(response: HttpResponseBase): Observable<HR_HopDong_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HR_HopDong_ENTITY.fromJS(resultData200) : new HR_HopDong_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_HopDong_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_HOPDONG_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/HopDong/HR_HOPDONG_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_HOPDONG_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_HOPDONG_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_HOPDONG_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    hR_HOPDONG_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/HopDong/HR_HOPDONG_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_HOPDONG_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_HOPDONG_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_HOPDONG_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class HoSoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    hR_HOSO_ByEmployeeCode(code: string | null | undefined): Observable<HR_Hoso_ENTITY> {
        let url_ = this.baseUrl + "/api/HoSo/HR_HOSO_ByEmployeeCode?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_HOSO_ByEmployeeCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_HOSO_ByEmployeeCode(<any>response_);
                } catch (e) {
                    return <Observable<HR_Hoso_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_Hoso_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_HOSO_ByEmployeeCode(response: HttpResponseBase): Observable<HR_Hoso_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HR_Hoso_ENTITY.fromJS(resultData200) : new HR_Hoso_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_Hoso_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_HOSO_Search(input: HR_Hoso_Filter | null | undefined): Observable<PagedResultDtoOfHR_Hoso_ENTITY> {
        let url_ = this.baseUrl + "/api/HoSo/HR_HOSO_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_HOSO_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_HOSO_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfHR_Hoso_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfHR_Hoso_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_HOSO_Search(response: HttpResponseBase): Observable<PagedResultDtoOfHR_Hoso_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfHR_Hoso_ENTITY.fromJS(resultData200) : new PagedResultDtoOfHR_Hoso_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfHR_Hoso_ENTITY>(<any>null);
    }

    /**
     * @return Success
     */
    dM_TINHTHANH_DANHSACH(): Observable<DM_TINHTHANH_ENTITY[]> {
        let url_ = this.baseUrl + "/api/HoSo/DM_TINHTHANH_DANHSACH";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDM_TINHTHANH_DANHSACH(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDM_TINHTHANH_DANHSACH(<any>response_);
                } catch (e) {
                    return <Observable<DM_TINHTHANH_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DM_TINHTHANH_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processDM_TINHTHANH_DANHSACH(response: HttpResponseBase): Observable<DM_TINHTHANH_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DM_TINHTHANH_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DM_TINHTHANH_ENTITY[]>(<any>null);
    }

    /**
     * @return Success
     */
    dM_NOIDAOTAO_DANHSACH(): Observable<HR_NoiDaoTao_ENTITY[]> {
        let url_ = this.baseUrl + "/api/HoSo/DM_NOIDAOTAO_DANHSACH";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDM_NOIDAOTAO_DANHSACH(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDM_NOIDAOTAO_DANHSACH(<any>response_);
                } catch (e) {
                    return <Observable<HR_NoiDaoTao_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_NoiDaoTao_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processDM_NOIDAOTAO_DANHSACH(response: HttpResponseBase): Observable<HR_NoiDaoTao_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HR_NoiDaoTao_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_NoiDaoTao_ENTITY[]>(<any>null);
    }

    /**
     * @return Success
     */
    dM_NOIKHAMBENH_DANHSACH(): Observable<HR_NOIKHAMCHUABENH_ENTITY[]> {
        let url_ = this.baseUrl + "/api/HoSo/DM_NOIKHAMBENH_DANHSACH";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDM_NOIKHAMBENH_DANHSACH(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDM_NOIKHAMBENH_DANHSACH(<any>response_);
                } catch (e) {
                    return <Observable<HR_NOIKHAMCHUABENH_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_NOIKHAMCHUABENH_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processDM_NOIKHAMBENH_DANHSACH(response: HttpResponseBase): Observable<HR_NOIKHAMCHUABENH_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HR_NOIKHAMCHUABENH_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_NOIKHAMCHUABENH_ENTITY[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_HOSO_ToExcel(input: HR_Hoso_Filter | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/HoSo/HR_HOSO_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_HOSO_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_HOSO_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processHR_HOSO_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_HOSO_Ins(input: HR_Hoso_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/HoSo/HR_HOSO_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_HOSO_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_HOSO_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_HOSO_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_HOSO_Upd(input: HR_Hoso_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/HoSo/HR_HOSO_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_HOSO_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_HOSO_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_HOSO_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_HOSO_ById(id: string | null | undefined): Observable<HR_Hoso_ENTITY> {
        let url_ = this.baseUrl + "/api/HoSo/HR_HOSO_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_HOSO_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_HOSO_ById(<any>response_);
                } catch (e) {
                    return <Observable<HR_Hoso_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_Hoso_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_HOSO_ById(response: HttpResponseBase): Observable<HR_Hoso_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HR_Hoso_ENTITY.fromJS(resultData200) : new HR_Hoso_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_Hoso_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_HOSO_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/HoSo/HR_HOSO_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_HOSO_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_HOSO_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_HOSO_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    hR_HOSO_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/HoSo/HR_HOSO_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_HOSO_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_HOSO_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_HOSO_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param data (optional) 
     * @return Success
     */
    hoSoImportResult(data: FileParameter | null | undefined): Observable<InsertResult[]> {
        let url_ = this.baseUrl + "/api/HoSo/HoSoImportResult";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (data !== null && data !== undefined)
            content_.append("data", data.data, data.fileName ? data.fileName : "data");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHoSoImportResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHoSoImportResult(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult[]>><any>_observableThrow(response_);
        }));
    }

    protected processHoSoImportResult(response: HttpResponseBase): Observable<InsertResult[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(InsertResult.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult[]>(<any>null);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getDashboardStatisticsData(incomeStatisticsDateInterval: ChartDateInterval, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<HostDashboardData> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetDashboardStatisticsData?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardStatisticsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardStatisticsData(<any>response_);
                } catch (e) {
                    return <Observable<HostDashboardData>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostDashboardData>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardStatisticsData(response: HttpResponseBase): Observable<HostDashboardData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostDashboardData.fromJS(resultData200) : new HostDashboardData();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostDashboardData>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: ChartDateInterval, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetIncomeStatisticsDataOutput.fromJS(resultData200) : new GetIncomeStatisticsDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncomeStatisticsDataOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetEditionTenantStatistics?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionTenantStatisticsOutput.fromJS(resultData200) : new GetEditionTenantStatisticsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionTenantStatisticsOutput>(<any>null);
    }

    /**
     * @param creationDateStart (optional) 
     * @param maxRecentTenantsShownCount (optional) 
     * @return Success
     */
    getRecentTenantsData(creationDateStart: moment.Moment | null | undefined, maxRecentTenantsShownCount: number | null | undefined): Observable<RecentTenant[]> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetRecentTenantsData?";
        if (creationDateStart !== undefined)
            url_ += "creationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&"; 
        if (maxRecentTenantsShownCount !== undefined)
            url_ += "maxRecentTenantsShownCount=" + encodeURIComponent("" + maxRecentTenantsShownCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentTenantsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentTenantsData(<any>response_);
                } catch (e) {
                    return <Observable<RecentTenant[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecentTenant[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentTenantsData(response: HttpResponseBase): Observable<RecentTenant[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RecentTenant.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecentTenant[]>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostSettingsEditDto.fromJS(resultData200) : new HostSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateAllSettings(input: HostSettingsEditDto | null | undefined): Observable<HostSettingResultDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<HostSettingResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostSettingResultDto.fromJS(resultData200) : new HostSettingResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingResultDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class InstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setup(input: InstallDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/app/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSettingsJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettingsJson(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingsJsonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppSettingsJsonDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AppSettingsJsonDto.fromJS(resultData200) : new AppSettingsJsonDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingsJsonDto>(<any>null);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/app/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDatabase(<any>response_);
                } catch (e) {
                    return <Observable<CheckDatabaseOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckDatabaseOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckDatabaseOutput.fromJS(resultData200) : new CheckDatabaseOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckDatabaseOutput>(<any>null);
    }
}

@Injectable()
export class InsuCompanyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_INSU_COMPANY_Search(input: CM_INSU_COMPANY_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_INSU_COMPANY_ENTITY> {
        let url_ = this.baseUrl + "/api/InsuCompany/CM_INSU_COMPANY_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_INSU_COMPANY_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_INSU_COMPANY_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_INSU_COMPANY_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_INSU_COMPANY_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_INSU_COMPANY_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_INSU_COMPANY_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_INSU_COMPANY_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_INSU_COMPANY_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_INSU_COMPANY_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_INSU_COMPANY_Ins(input: CM_INSU_COMPANY_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/InsuCompany/CM_INSU_COMPANY_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_INSU_COMPANY_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_INSU_COMPANY_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_INSU_COMPANY_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_INSU_COMPANY_Upd(input: CM_INSU_COMPANY_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/InsuCompany/CM_INSU_COMPANY_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_INSU_COMPANY_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_INSU_COMPANY_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_INSU_COMPANY_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_INSU_COMPANY_ById(id: string | null | undefined): Observable<CM_INSU_COMPANY_ENTITY> {
        let url_ = this.baseUrl + "/api/InsuCompany/CM_INSU_COMPANY_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_INSU_COMPANY_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_INSU_COMPANY_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_INSU_COMPANY_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_INSU_COMPANY_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_INSU_COMPANY_ById(response: HttpResponseBase): Observable<CM_INSU_COMPANY_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_INSU_COMPANY_ENTITY.fromJS(resultData200) : new CM_INSU_COMPANY_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_INSU_COMPANY_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_INSU_COMPANY_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/InsuCompany/CM_INSU_COMPANY_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_INSU_COMPANY_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_INSU_COMPANY_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_INSU_COMPANY_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_INSU_COMPANY_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/InsuCompany/CM_INSU_COMPANY_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_INSU_COMPANY_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_INSU_COMPANY_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_INSU_COMPANY_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | null | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceInfo?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceDto.fromJS(resultData200) : new InvoiceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createInvoice(input: CreateInvoiceDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class KeyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_ALL_KEY_Search(input: CM_ALL_KEY_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_ALL_KEY_ENTITY> {
        let url_ = this.baseUrl + "/api/Key/CM_ALL_KEY_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALL_KEY_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALL_KEY_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_ALL_KEY_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_ALL_KEY_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALL_KEY_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_ALL_KEY_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_ALL_KEY_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_ALL_KEY_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_ALL_KEY_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_ALL_KEY_ToExcel(input: CM_ALL_KEY_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Key/CM_ALL_KEY_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALL_KEY_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALL_KEY_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALL_KEY_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_ALL_KEY_Ins(input: CM_ALL_KEY_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Key/CM_ALL_KEY_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALL_KEY_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALL_KEY_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALL_KEY_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_ALL_KEY_Upd(input: CM_ALL_KEY_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Key/CM_ALL_KEY_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALL_KEY_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALL_KEY_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALL_KEY_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_ALL_KEY_ById(id: string | null | undefined): Observable<CM_ALL_KEY_ENTITY> {
        let url_ = this.baseUrl + "/api/Key/CM_ALL_KEY_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALL_KEY_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALL_KEY_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_ALL_KEY_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ALL_KEY_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALL_KEY_ById(response: HttpResponseBase): Observable<CM_ALL_KEY_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_ALL_KEY_ENTITY.fromJS(resultData200) : new CM_ALL_KEY_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ALL_KEY_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_ALL_KEY_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Key/CM_ALL_KEY_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALL_KEY_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALL_KEY_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALL_KEY_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_ALL_KEY_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Key/CM_ALL_KEY_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALL_KEY_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALL_KEY_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALL_KEY_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @return Success
     */
    aSS_GROUP_GET_LV1(): Observable<ASS_GROUP_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Key/ASS_GROUP_GET_LV1";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processASS_GROUP_GET_LV1(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processASS_GROUP_GET_LV1(<any>response_);
                } catch (e) {
                    return <Observable<ASS_GROUP_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ASS_GROUP_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processASS_GROUP_GET_LV1(response: HttpResponseBase): Observable<ASS_GROUP_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ASS_GROUP_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ASS_GROUP_ENTITY[]>(<any>null);
    }

    /**
     * @param groupID (optional) 
     * @return Success
     */
    aSS_GROUP_GET_LV2(groupID: string | null | undefined): Observable<ASS_GROUP_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Key/ASS_GROUP_GET_LV2?";
        if (groupID !== undefined)
            url_ += "groupID=" + encodeURIComponent("" + groupID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processASS_GROUP_GET_LV2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processASS_GROUP_GET_LV2(<any>response_);
                } catch (e) {
                    return <Observable<ASS_GROUP_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ASS_GROUP_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processASS_GROUP_GET_LV2(response: HttpResponseBase): Observable<ASS_GROUP_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ASS_GROUP_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ASS_GROUP_ENTITY[]>(<any>null);
    }

    /**
     * @param groupID (optional) 
     * @return Success
     */
    aSS_GROUP_GET_LV3(groupID: string | null | undefined): Observable<ASS_GROUP_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Key/ASS_GROUP_GET_LV3?";
        if (groupID !== undefined)
            url_ += "groupID=" + encodeURIComponent("" + groupID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processASS_GROUP_GET_LV3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processASS_GROUP_GET_LV3(<any>response_);
                } catch (e) {
                    return <Observable<ASS_GROUP_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ASS_GROUP_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processASS_GROUP_GET_LV3(response: HttpResponseBase): Observable<ASS_GROUP_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ASS_GROUP_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ASS_GROUP_ENTITY[]>(<any>null);
    }

    /**
     * @param groupID (optional) 
     * @return Success
     */
    aSS_GROUP_GET_LV4(groupID: string | null | undefined): Observable<ASS_GROUP_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Key/ASS_GROUP_GET_LV4?";
        if (groupID !== undefined)
            url_ += "groupID=" + encodeURIComponent("" + groupID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processASS_GROUP_GET_LV4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processASS_GROUP_GET_LV4(<any>response_);
                } catch (e) {
                    return <Observable<ASS_GROUP_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ASS_GROUP_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processASS_GROUP_GET_LV4(response: HttpResponseBase): Observable<ASS_GROUP_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ASS_GROUP_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ASS_GROUP_ENTITY[]>(<any>null);
    }
}

@Injectable()
export class KhoiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_KHOI_Search(input: CM_KHOI_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_KHOI_ENTITY> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_KHOI_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_KHOI_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_KHOI_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_KHOI_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_KHOI_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_KHOI_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_KHOI_Ins(input: CM_KHOI_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_KHOI_Upd(input: CM_KHOI_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_KHOI_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_KHOI_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_KHOI_ById(id: string | null | undefined): Observable<CM_KHOI_ENTITY> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_KHOI_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_KHOI_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_ById(response: HttpResponseBase): Observable<CM_KHOI_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_KHOI_ENTITY.fromJS(resultData200) : new CM_KHOI_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_KHOI_ENTITY>(<any>null);
    }

    /**
     * @return Success
     */
    cM_KHOI_Lst(): Observable<CM_KHOI_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_Lst";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_Lst(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_Lst(<any>response_);
                } catch (e) {
                    return <Observable<CM_KHOI_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_KHOI_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_Lst(response: HttpResponseBase): Observable<CM_KHOI_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_KHOI_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_KHOI_ENTITY[]>(<any>null);
    }

    /**
     * @return Success
     */
    cM_KHOI_DT_Lst(): Observable<CM_KHOI_DT_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_DT_Lst";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_DT_Lst(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_DT_Lst(<any>response_);
                } catch (e) {
                    return <Observable<CM_KHOI_DT_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_KHOI_DT_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_DT_Lst(response: HttpResponseBase): Observable<CM_KHOI_DT_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_KHOI_DT_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_KHOI_DT_ENTITY[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_KHOI_DT_Search(input: CM_KHOI_DT_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_KHOI_DT_ENTITY> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_DT_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_DT_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_DT_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_KHOI_DT_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_KHOI_DT_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_DT_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_KHOI_DT_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_KHOI_DT_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_KHOI_DT_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_KHOI_DT_ENTITY>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguagesOutput.fromJS(resultData200) : new GetLanguagesOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguageForEditOutput.fromJS(resultData200) : new GetLanguageForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateLanguage(input: CreateOrUpdateLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param key (optional) 
     * @return Success
     */
    deleteLanguageText(key: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguageText?";
        if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setDefaultLanguage(input: SetDefaultLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @param baseLanguageName (optional) 
     * @param targetValueFilter (optional) 
     * @param filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined, sourceName: string, baseLanguageName: string | null | undefined, targetLanguageName: string, targetValueFilter: string | null | undefined, filterText: string | null | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&"; 
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&"; 
        if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&"; 
        if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLanguageTextListDto.fromJS(resultData200) : new PagedResultDtoOfLanguageTextListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLanguageTextListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateLanguageText(input: UpdateLanguageTextInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LichSuGuiMailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_LichSuGuiMail_Search(input: HR_LichSuGuiMail_ENTITY | null | undefined): Observable<PagedResultDtoOfHR_LichSuGuiMail_ENTITY> {
        let url_ = this.baseUrl + "/api/LichSuGuiMail/HR_LichSuGuiMail_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_LichSuGuiMail_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_LichSuGuiMail_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfHR_LichSuGuiMail_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfHR_LichSuGuiMail_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_LichSuGuiMail_Search(response: HttpResponseBase): Observable<PagedResultDtoOfHR_LichSuGuiMail_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfHR_LichSuGuiMail_ENTITY.fromJS(resultData200) : new PagedResultDtoOfHR_LichSuGuiMail_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfHR_LichSuGuiMail_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_LichSuGuiMail_ToExcel(input: HR_LichSuGuiMail_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/LichSuGuiMail/HR_LichSuGuiMail_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_LichSuGuiMail_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_LichSuGuiMail_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processHR_LichSuGuiMail_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_LichSuGuiMail_Ins(input: HR_LichSuGuiMail_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/LichSuGuiMail/HR_LichSuGuiMail_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_LichSuGuiMail_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_LichSuGuiMail_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_LichSuGuiMail_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_LichSuGuiMail_Upd(input: HR_LichSuGuiMail_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/LichSuGuiMail/HR_LichSuGuiMail_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_LichSuGuiMail_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_LichSuGuiMail_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_LichSuGuiMail_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_LichSuGuiMail_ById(id: string | null | undefined): Observable<HR_LichSuGuiMail_ENTITY> {
        let url_ = this.baseUrl + "/api/LichSuGuiMail/HR_LichSuGuiMail_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_LichSuGuiMail_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_LichSuGuiMail_ById(<any>response_);
                } catch (e) {
                    return <Observable<HR_LichSuGuiMail_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_LichSuGuiMail_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_LichSuGuiMail_ById(response: HttpResponseBase): Observable<HR_LichSuGuiMail_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HR_LichSuGuiMail_ENTITY.fromJS(resultData200) : new HR_LichSuGuiMail_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_LichSuGuiMail_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_LichSuGuiMail_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/LichSuGuiMail/HR_LichSuGuiMail_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_LichSuGuiMail_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_LichSuGuiMail_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_LichSuGuiMail_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    hR_LichSuGuiMail_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/LichSuGuiMail/HR_LichSuGuiMail_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_LichSuGuiMail_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_LichSuGuiMail_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_LichSuGuiMail_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_LichSuGuiMail_Lst(input: HR_LichSuGuiMail_ENTITY | null | undefined): Observable<HR_LichSuGuiMail_ENTITY[]> {
        let url_ = this.baseUrl + "/api/LichSuGuiMail/HR_LichSuGuiMail_Lst";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_LichSuGuiMail_Lst(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_LichSuGuiMail_Lst(<any>response_);
                } catch (e) {
                    return <Observable<HR_LichSuGuiMail_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_LichSuGuiMail_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processHR_LichSuGuiMail_Lst(response: HttpResponseBase): Observable<HR_LichSuGuiMail_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HR_LichSuGuiMail_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_LichSuGuiMail_ENTITY[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_LichSuGuiMail_ByUngVien(id: string | null | undefined): Observable<HR_LichSuGuiMail_ENTITY[]> {
        let url_ = this.baseUrl + "/api/LichSuGuiMail/HR_LichSuGuiMail_ByUngVien?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_LichSuGuiMail_ByUngVien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_LichSuGuiMail_ByUngVien(<any>response_);
                } catch (e) {
                    return <Observable<HR_LichSuGuiMail_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_LichSuGuiMail_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processHR_LichSuGuiMail_ByUngVien(response: HttpResponseBase): Observable<HR_LichSuGuiMail_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HR_LichSuGuiMail_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_LichSuGuiMail_ENTITY[]>(<any>null);
    }
}

@Injectable()
export class LiquidCancelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    t_LIQUID_CANCEL_Search(input: T_LIQUID_CANCEL_ENTITY | null | undefined): Observable<PagedResultDtoOfT_LIQUID_CANCEL_ENTITY> {
        let url_ = this.baseUrl + "/api/LiquidCancel/T_LIQUID_CANCEL_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_LIQUID_CANCEL_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_LIQUID_CANCEL_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfT_LIQUID_CANCEL_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfT_LIQUID_CANCEL_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processT_LIQUID_CANCEL_Search(response: HttpResponseBase): Observable<PagedResultDtoOfT_LIQUID_CANCEL_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfT_LIQUID_CANCEL_ENTITY.fromJS(resultData200) : new PagedResultDtoOfT_LIQUID_CANCEL_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfT_LIQUID_CANCEL_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    t_LIQUID_CANCEL_Ins(input: T_LIQUID_CANCEL_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/LiquidCancel/T_LIQUID_CANCEL_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_LIQUID_CANCEL_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_LIQUID_CANCEL_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processT_LIQUID_CANCEL_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    t_LIQUID_CANCEL_Upd(input: T_LIQUID_CANCEL_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/LiquidCancel/T_LIQUID_CANCEL_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_LIQUID_CANCEL_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_LIQUID_CANCEL_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processT_LIQUID_CANCEL_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    t_LIQUID_CANCEL_ById(id: string | null | undefined): Observable<T_LIQUID_CANCEL_ENTITY> {
        let url_ = this.baseUrl + "/api/LiquidCancel/T_LIQUID_CANCEL_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_LIQUID_CANCEL_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_LIQUID_CANCEL_ById(<any>response_);
                } catch (e) {
                    return <Observable<T_LIQUID_CANCEL_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<T_LIQUID_CANCEL_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processT_LIQUID_CANCEL_ById(response: HttpResponseBase): Observable<T_LIQUID_CANCEL_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? T_LIQUID_CANCEL_ENTITY.fromJS(resultData200) : new T_LIQUID_CANCEL_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<T_LIQUID_CANCEL_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    t_LIQUID_CANCEL_Del(id: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/LiquidCancel/T_LIQUID_CANCEL_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_LIQUID_CANCEL_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_LIQUID_CANCEL_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processT_LIQUID_CANCEL_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    t_LIQUID_CANCEL_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/LiquidCancel/T_LIQUID_CANCEL_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processT_LIQUID_CANCEL_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processT_LIQUID_CANCEL_App(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processT_LIQUID_CANCEL_App(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class LocationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    cM_LOCATION_AllData(): Observable<CM_LOCATION_ENTITY> {
        let url_ = this.baseUrl + "/api/Location/CM_LOCATION_AllData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_LOCATION_AllData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_LOCATION_AllData(<any>response_);
                } catch (e) {
                    return <Observable<CM_LOCATION_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_LOCATION_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_LOCATION_AllData(response: HttpResponseBase): Observable<CM_LOCATION_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_LOCATION_ENTITY.fromJS(resultData200) : new CM_LOCATION_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_LOCATION_ENTITY>(<any>null);
    }
}

@Injectable()
export class ModelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_MODEL_Search(input: CM_MODEL_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_MODEL_ENTITY> {
        let url_ = this.baseUrl + "/api/Model/CM_MODEL_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_MODEL_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_MODEL_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_MODEL_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_MODEL_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_MODEL_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_MODEL_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_MODEL_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_MODEL_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_MODEL_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_MODEL_Ins(input: CM_MODEL_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Model/CM_MODEL_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_MODEL_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_MODEL_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_MODEL_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_MODEL_Upd(input: CM_MODEL_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Model/CM_MODEL_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_MODEL_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_MODEL_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_MODEL_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_MODEL_ById(id: string | null | undefined): Observable<CM_MODEL_ENTITY> {
        let url_ = this.baseUrl + "/api/Model/CM_MODEL_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_MODEL_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_MODEL_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_MODEL_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_MODEL_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_MODEL_ById(response: HttpResponseBase): Observable<CM_MODEL_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_MODEL_ENTITY.fromJS(resultData200) : new CM_MODEL_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_MODEL_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_MODEL_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Model/CM_MODEL_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_MODEL_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_MODEL_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_MODEL_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_MODEL_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Model/CM_MODEL_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_MODEL_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_MODEL_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_MODEL_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class NoiDaoTaoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_NoiDaoTao_Search(input: HR_NoiDaoTao_ENTITY | null | undefined): Observable<PagedResultDtoOfHR_NoiDaoTao_ENTITY> {
        let url_ = this.baseUrl + "/api/NoiDaoTao/HR_NoiDaoTao_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_NoiDaoTao_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_NoiDaoTao_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfHR_NoiDaoTao_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfHR_NoiDaoTao_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_NoiDaoTao_Search(response: HttpResponseBase): Observable<PagedResultDtoOfHR_NoiDaoTao_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfHR_NoiDaoTao_ENTITY.fromJS(resultData200) : new PagedResultDtoOfHR_NoiDaoTao_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfHR_NoiDaoTao_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_NoiDaoTao_ToExcel(input: HR_NoiDaoTao_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/NoiDaoTao/HR_NoiDaoTao_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_NoiDaoTao_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_NoiDaoTao_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processHR_NoiDaoTao_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_NoiDaoTao_Ins(input: HR_NoiDaoTao_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/NoiDaoTao/HR_NoiDaoTao_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_NoiDaoTao_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_NoiDaoTao_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_NoiDaoTao_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_NoiDaoTao_Upd(input: HR_NoiDaoTao_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/NoiDaoTao/HR_NoiDaoTao_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_NoiDaoTao_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_NoiDaoTao_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_NoiDaoTao_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_NoiDaoTao_ById(id: string | null | undefined): Observable<HR_NoiDaoTao_ENTITY> {
        let url_ = this.baseUrl + "/api/NoiDaoTao/HR_NoiDaoTao_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_NoiDaoTao_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_NoiDaoTao_ById(<any>response_);
                } catch (e) {
                    return <Observable<HR_NoiDaoTao_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_NoiDaoTao_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_NoiDaoTao_ById(response: HttpResponseBase): Observable<HR_NoiDaoTao_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HR_NoiDaoTao_ENTITY.fromJS(resultData200) : new HR_NoiDaoTao_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_NoiDaoTao_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_NoiDaoTao_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/NoiDaoTao/HR_NoiDaoTao_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_NoiDaoTao_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_NoiDaoTao_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_NoiDaoTao_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    hR_NoiDaoTao_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/NoiDaoTao/HR_NoiDaoTao_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_NoiDaoTao_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_NoiDaoTao_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_NoiDaoTao_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_NoiDaoTao_Lst(input: HR_NoiDaoTao_ENTITY | null | undefined): Observable<HR_NoiDaoTao_ENTITY[]> {
        let url_ = this.baseUrl + "/api/NoiDaoTao/HR_NoiDaoTao_Lst";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_NoiDaoTao_Lst(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_NoiDaoTao_Lst(<any>response_);
                } catch (e) {
                    return <Observable<HR_NoiDaoTao_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_NoiDaoTao_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processHR_NoiDaoTao_Lst(response: HttpResponseBase): Observable<HR_NoiDaoTao_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HR_NoiDaoTao_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_NoiDaoTao_ENTITY[]>(<any>null);
    }
}

@Injectable()
export class NoiKhamChuaBenhServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_NOIKHAMCHUABENH_Search(input: HR_NOIKHAMCHUABENH_ENTITY | null | undefined): Observable<PagedResultDtoOfHR_NOIKHAMCHUABENH_ENTITY> {
        let url_ = this.baseUrl + "/api/NoiKhamChuaBenh/HR_NOIKHAMCHUABENH_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_NOIKHAMCHUABENH_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_NOIKHAMCHUABENH_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfHR_NOIKHAMCHUABENH_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfHR_NOIKHAMCHUABENH_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_NOIKHAMCHUABENH_Search(response: HttpResponseBase): Observable<PagedResultDtoOfHR_NOIKHAMCHUABENH_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfHR_NOIKHAMCHUABENH_ENTITY.fromJS(resultData200) : new PagedResultDtoOfHR_NOIKHAMCHUABENH_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfHR_NOIKHAMCHUABENH_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_NOIKHAMCHUABENH_ToExcel(input: HR_NOIKHAMCHUABENH_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/NoiKhamChuaBenh/HR_NOIKHAMCHUABENH_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_NOIKHAMCHUABENH_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_NOIKHAMCHUABENH_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processHR_NOIKHAMCHUABENH_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_NOIKHAMCHUABENH_Ins(input: HR_NOIKHAMCHUABENH_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/NoiKhamChuaBenh/HR_NOIKHAMCHUABENH_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_NOIKHAMCHUABENH_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_NOIKHAMCHUABENH_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_NOIKHAMCHUABENH_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_NOIKHAMCHUABENH_Upd(input: HR_NOIKHAMCHUABENH_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/NoiKhamChuaBenh/HR_NOIKHAMCHUABENH_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_NOIKHAMCHUABENH_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_NOIKHAMCHUABENH_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_NOIKHAMCHUABENH_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_NOIKHAMCHUABENH_ById(id: string | null | undefined): Observable<HR_NOIKHAMCHUABENH_ENTITY> {
        let url_ = this.baseUrl + "/api/NoiKhamChuaBenh/HR_NOIKHAMCHUABENH_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_NOIKHAMCHUABENH_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_NOIKHAMCHUABENH_ById(<any>response_);
                } catch (e) {
                    return <Observable<HR_NOIKHAMCHUABENH_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_NOIKHAMCHUABENH_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_NOIKHAMCHUABENH_ById(response: HttpResponseBase): Observable<HR_NOIKHAMCHUABENH_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HR_NOIKHAMCHUABENH_ENTITY.fromJS(resultData200) : new HR_NOIKHAMCHUABENH_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_NOIKHAMCHUABENH_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_NOIKHAMCHUABENH_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/NoiKhamChuaBenh/HR_NOIKHAMCHUABENH_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_NOIKHAMCHUABENH_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_NOIKHAMCHUABENH_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_NOIKHAMCHUABENH_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    hR_NOIKHAMCHUABENH_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/NoiKhamChuaBenh/HR_NOIKHAMCHUABENH_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_NOIKHAMCHUABENH_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_NOIKHAMCHUABENH_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_NOIKHAMCHUABENH_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param state (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationsOutput.fromJS(resultData200) : new GetNotificationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param state (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getUserNotificationsWithNotificationsAsync(tenantId: number | null | undefined, userId: number | null | undefined, state: UserNotificationState | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<UserNotificationInfoWithNotificationInfo[]> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotificationsWithNotificationsAsync?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotificationsWithNotificationsAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotificationsWithNotificationsAsync(<any>response_);
                } catch (e) {
                    return <Observable<UserNotificationInfoWithNotificationInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserNotificationInfoWithNotificationInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotificationsWithNotificationsAsync(response: HttpResponseBase): Observable<UserNotificationInfoWithNotificationInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserNotificationInfoWithNotificationInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserNotificationInfoWithNotificationInfo[]>(<any>null);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setNotificationAsRead(input: EntityDtoOfGuid | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationSettingsOutput.fromJS(resultData200) : new GetNotificationSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateNotificationSettings(input: UpdateNotificationSettingsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteNotification(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteNotification?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfOrganizationUnitDto.fromJS(resultData200) : new ListResultDtoOfOrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfOrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | null | undefined, tOP: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitUserListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitRoles(id: number | null | undefined, tOP: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitRoles?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitRoleListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrganizationUnit(input: CreateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateOrganizationUnit(input: UpdateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveOrganizationUnit(input: MoveOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRoleFromOrganizationUnit(roleId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRoleFromOrganizationUnit?";
        if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRoleFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRoleFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(input: UsersToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addRolesToOrganizationUnit(input: RolesToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRolesToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRolesToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolesToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddRolesToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findUsers(input: FindOrganizationUnitUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findRoles(input: FindOrganizationUnitRolesInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number | null | undefined): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentInfo?";
        if (upgradeEditionId !== undefined)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<PaymentInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentInfoDto.fromJS(resultData200) : new PaymentInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInfoDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createPayment(input: CreatePaymentDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cancelPayment(input: CancelPaymentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaymentHistory(tOP: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentHistory?";
        if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentHistory(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200) : new PagedResultDtoOfSubscriptionPaymentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSubscriptionPaymentListDto>(<any>null);
    }

    /**
     * @param recurringPaymentsEnabled (optional) 
     * @return Success
     */
    getActiveGateways(recurringPaymentsEnabled: boolean | null | undefined): Observable<PaymentGatewayModel[]> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetActiveGateways?";
        if (recurringPaymentsEnabled !== undefined)
            url_ += "RecurringPaymentsEnabled=" + encodeURIComponent("" + recurringPaymentsEnabled) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveGateways(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveGateways(<any>response_);
                } catch (e) {
                    return <Observable<PaymentGatewayModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentGatewayModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveGateways(response: HttpResponseBase): Observable<PaymentGatewayModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PaymentGatewayModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentGatewayModel[]>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPaymentAsync(paymentId: number | null | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentAsync?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentAsync(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentAsync(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscriptionPaymentDto.fromJS(resultData200) : new SubscriptionPaymentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLastCompletedPayment(): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetLastCompletedPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastCompletedPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCompletedPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastCompletedPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscriptionPaymentDto.fromJS(resultData200) : new SubscriptionPaymentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    buyNowSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/BuyNowSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuyNowSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyNowSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBuyNowSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    newRegistrationSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/NewRegistrationSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewRegistrationSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewRegistrationSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processNewRegistrationSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    upgradeSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    extendSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ExtendSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExtendSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    paymentFailed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/PaymentFailed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentFailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentFailed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPaymentFailed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PayPalPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param paymentId (optional) 
     * @param paypalPaymentId (optional) 
     * @param paypalPayerId (optional) 
     * @return Success
     */
    confirmPayment(paymentId: number | null | undefined, paypalPaymentId: string | null | undefined, paypalPayerId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/ConfirmPayment?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        if (paypalPaymentId !== undefined)
            url_ += "paypalPaymentId=" + encodeURIComponent("" + paypalPaymentId) + "&"; 
        if (paypalPayerId !== undefined)
            url_ += "paypalPayerId=" + encodeURIComponent("" + paypalPayerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<PayPalConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<PayPalConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayPalConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<PayPalConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PayPalConfigurationDto.fromJS(resultData200) : new PayPalConfigurationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayPalConfigurationDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cancelPayment(input: CancelPaymentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200) : new ListResultDtoOfFlatPermissionWithLevelDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfFlatPermissionWithLevelDto>(<any>null);
    }
}

@Injectable()
export class PictureUploadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param fileType (optional) 
     * @return Success
     */
    uploadPicture(fileName: string, fileType: string | null | undefined, fileToken: string): Observable<UPLOAD_W_T_RESULT> {
        let url_ = this.baseUrl + "/api/PictureUpload/UploadPicture?";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined and cannot be null.");
        else
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&"; 
        if (fileType !== undefined)
            url_ += "FileType=" + encodeURIComponent("" + fileType) + "&"; 
        if (fileToken === undefined || fileToken === null)
            throw new Error("The parameter 'fileToken' must be defined and cannot be null.");
        else
            url_ += "FileToken=" + encodeURIComponent("" + fileToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadPicture(<any>response_);
                } catch (e) {
                    return <Observable<UPLOAD_W_T_RESULT>><any>_observableThrow(e);
                }
            } else
                return <Observable<UPLOAD_W_T_RESULT>><any>_observableThrow(response_);
        }));
    }

    protected processUploadPicture(response: HttpResponseBase): Observable<UPLOAD_W_T_RESULT> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UPLOAD_W_T_RESULT.fromJS(resultData200) : new UPLOAD_W_T_RESULT();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UPLOAD_W_T_RESULT>(<any>null);
    }

    /**
     * @param path (optional) 
     * @return Success
     */
    getUploadedPicture(path: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/PictureUpload/GetUploadedPicture?";
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUploadedPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUploadedPicture(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetUploadedPicture(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentUserProfileEditDto.fromJS(resultData200) : new CurrentUserProfileEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentUserProfileEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(<any>response_);
                } catch (e) {
                    return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200) : new UpdateGoogleAuthenticatorKeyOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateGoogleAuthenticatorKeyOutput>(<any>null);
    }

    /**
     * @return Success
     */
    sendVerificationSms(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    verifySmsCode(input: VerifySmsCodeInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    prepareCollectedData(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/PrepareCollectedData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareCollectedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareCollectedData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPrepareCollectedData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateCurrentUserProfile(input: CurrentUserProfileEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changePassword(input: ChangePasswordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateProfilePicture(input: UpdateProfilePictureInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(<any>response_);
                } catch (e) {
                    return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPasswordComplexitySettingOutput.fromJS(resultData200) : new GetPasswordComplexitySettingOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPasswordComplexitySettingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @param userId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getFriendProfilePictureById(profilePictureId: string | null | undefined, userId: number | null | undefined, tenantId: number | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetFriendProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "ProfilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFriendProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @return Success
     */
    getProfilePictureById(profilePictureId: string | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class QuyTrinhCongTacServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_QUYTRINHCONGTAC_Search(input: HR_QuyTrinhCongTacs_ENTITY | null | undefined): Observable<PagedResultDtoOfHR_QuyTrinhCongTacs_ENTITY> {
        let url_ = this.baseUrl + "/api/QuyTrinhCongTac/HR_QUYTRINHCONGTAC_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_QUYTRINHCONGTAC_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_QUYTRINHCONGTAC_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfHR_QuyTrinhCongTacs_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfHR_QuyTrinhCongTacs_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_QUYTRINHCONGTAC_Search(response: HttpResponseBase): Observable<PagedResultDtoOfHR_QuyTrinhCongTacs_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfHR_QuyTrinhCongTacs_ENTITY.fromJS(resultData200) : new PagedResultDtoOfHR_QuyTrinhCongTacs_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfHR_QuyTrinhCongTacs_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_QUYTRINHCONGTAC_Ins(input: HR_QuyTrinhCongTacs_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/QuyTrinhCongTac/HR_QUYTRINHCONGTAC_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_QUYTRINHCONGTAC_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_QUYTRINHCONGTAC_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_QUYTRINHCONGTAC_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_QUYTRINHCONGTAC_ById(id: string | null | undefined): Observable<HR_QuyTrinhCongTacs_ENTITY> {
        let url_ = this.baseUrl + "/api/QuyTrinhCongTac/HR_QUYTRINHCONGTAC_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_QUYTRINHCONGTAC_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_QUYTRINHCONGTAC_ById(<any>response_);
                } catch (e) {
                    return <Observable<HR_QuyTrinhCongTacs_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_QuyTrinhCongTacs_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_QUYTRINHCONGTAC_ById(response: HttpResponseBase): Observable<HR_QuyTrinhCongTacs_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HR_QuyTrinhCongTacs_ENTITY.fromJS(resultData200) : new HR_QuyTrinhCongTacs_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_QuyTrinhCongTacs_ENTITY>(<any>null);
    }
}

@Injectable()
export class RealEstateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    rET_MASTER_Search(input: RET_MASTER_ENTITY | null | undefined): Observable<PagedResultDtoOfRET_MASTER_ENTITY> {
        let url_ = this.baseUrl + "/api/RealEstate/RET_MASTER_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRET_MASTER_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRET_MASTER_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRET_MASTER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRET_MASTER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processRET_MASTER_Search(response: HttpResponseBase): Observable<PagedResultDtoOfRET_MASTER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRET_MASTER_ENTITY.fromJS(resultData200) : new PagedResultDtoOfRET_MASTER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRET_MASTER_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    rET_MASTER_Ins(input: RET_MASTER_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/RealEstate/RET_MASTER_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRET_MASTER_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRET_MASTER_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processRET_MASTER_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    rET_MASTER_Upd(input: RET_MASTER_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/RealEstate/RET_MASTER_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRET_MASTER_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRET_MASTER_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processRET_MASTER_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rET_MASTER_ById(id: string | null | undefined): Observable<RET_MASTER_ENTITY> {
        let url_ = this.baseUrl + "/api/RealEstate/RET_MASTER_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRET_MASTER_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRET_MASTER_ById(<any>response_);
                } catch (e) {
                    return <Observable<RET_MASTER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<RET_MASTER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processRET_MASTER_ById(response: HttpResponseBase): Observable<RET_MASTER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RET_MASTER_ENTITY.fromJS(resultData200) : new RET_MASTER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RET_MASTER_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rET_MASTER_Del(id: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/RealEstate/RET_MASTER_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRET_MASTER_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRET_MASTER_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processRET_MASTER_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rET_MASTER_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/RealEstate/RET_MASTER_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRET_MASTER_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRET_MASTER_App(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processRET_MASTER_App(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class RegionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_REGION_Search(input: CM_REGION_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_REGION_ENTITY> {
        let url_ = this.baseUrl + "/api/Region/CM_REGION_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REGION_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REGION_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_REGION_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_REGION_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REGION_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_REGION_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_REGION_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_REGION_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_REGION_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_REGION_Ins(input: CM_REGION_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Region/CM_REGION_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REGION_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REGION_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REGION_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_REGION_Upd(input: CM_REGION_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Region/CM_REGION_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REGION_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REGION_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REGION_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_REGION_ById(id: string | null | undefined): Observable<CM_REGION_ENTITY> {
        let url_ = this.baseUrl + "/api/Region/CM_REGION_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REGION_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REGION_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_REGION_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_REGION_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REGION_ById(response: HttpResponseBase): Observable<CM_REGION_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_REGION_ENTITY.fromJS(resultData200) : new CM_REGION_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_REGION_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_REGION_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Region/CM_REGION_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REGION_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REGION_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REGION_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_REGION_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Region/CM_REGION_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REGION_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REGION_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REGION_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class RejectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_REGION_Search(input: CM_REJECT_LOG_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_REJECT_LOG_ENTITY> {
        let url_ = this.baseUrl + "/api/Reject/CM_REGION_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REGION_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REGION_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_REJECT_LOG_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_REJECT_LOG_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REGION_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_REJECT_LOG_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_REJECT_LOG_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_REJECT_LOG_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_REJECT_LOG_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_REGION_Ins(input: CM_REJECT_LOG_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Reject/CM_REGION_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REGION_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REGION_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REGION_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_REJECT_Search(input: CM_REJECT_LOG_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_REJECT_LOG_ENTITY> {
        let url_ = this.baseUrl + "/api/Reject/CM_REJECT_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REJECT_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REJECT_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_REJECT_LOG_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_REJECT_LOG_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REJECT_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_REJECT_LOG_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_REJECT_LOG_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_REJECT_LOG_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_REJECT_LOG_ENTITY>(<any>null);
    }

    /**
     * @param trd_id (optional) 
     * @param stage (optional) 
     * @return Success
     */
    cM_REGION_ById(trd_id: string | null | undefined, stage: string | null | undefined): Observable<CM_REJECT_LOG_ENTITY> {
        let url_ = this.baseUrl + "/api/Reject/CM_REGION_ById?";
        if (trd_id !== undefined)
            url_ += "trd_id=" + encodeURIComponent("" + trd_id) + "&"; 
        if (stage !== undefined)
            url_ += "stage=" + encodeURIComponent("" + stage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REGION_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REGION_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_REJECT_LOG_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_REJECT_LOG_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REGION_ById(response: HttpResponseBase): Observable<CM_REJECT_LOG_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_REJECT_LOG_ENTITY.fromJS(resultData200) : new CM_REJECT_LOG_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_REJECT_LOG_ENTITY>(<any>null);
    }
}

@Injectable()
export class ReportTemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_Search(input: CM_REPORT_TEMPLATE_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_ToExcel(input: CM_REPORT_TEMPLATE_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_Ins(input: CM_REPORT_TEMPLATE_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_Upd(input: CM_REPORT_TEMPLATE_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_ById(id: string | null | undefined): Observable<CM_REPORT_TEMPLATE_ENTITY> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_REPORT_TEMPLATE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_REPORT_TEMPLATE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_ById(response: HttpResponseBase): Observable<CM_REPORT_TEMPLATE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_REPORT_TEMPLATE_ENTITY.fromJS(resultData200) : new CM_REPORT_TEMPLATE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_REPORT_TEMPLATE_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param templateCode (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_ByCode(templateCode: string | null | undefined): Observable<CM_REPORT_TEMPLATE_ENTITY> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_ByCode?";
        if (templateCode !== undefined)
            url_ += "templateCode=" + encodeURIComponent("" + templateCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_ByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_ByCode(<any>response_);
                } catch (e) {
                    return <Observable<CM_REPORT_TEMPLATE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_REPORT_TEMPLATE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_ByCode(response: HttpResponseBase): Observable<CM_REPORT_TEMPLATE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_REPORT_TEMPLATE_ENTITY.fromJS(resultData200) : new CM_REPORT_TEMPLATE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_REPORT_TEMPLATE_ENTITY>(<any>null);
    }

    /**
     * @param templateId (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_DETAIL_ByTemplateId(templateId: string | null | undefined): Observable<CM_REPORT_TEMPLATE_DETAIL_ENTITY[]> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_DETAIL_ByTemplateId?";
        if (templateId !== undefined)
            url_ += "templateId=" + encodeURIComponent("" + templateId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_DETAIL_ByTemplateId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_DETAIL_ByTemplateId(<any>response_);
                } catch (e) {
                    return <Observable<CM_REPORT_TEMPLATE_DETAIL_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_REPORT_TEMPLATE_DETAIL_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_DETAIL_ByTemplateId(response: HttpResponseBase): Observable<CM_REPORT_TEMPLATE_DETAIL_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_REPORT_TEMPLATE_DETAIL_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_REPORT_TEMPLATE_DETAIL_ENTITY[]>(<any>null);
    }

    /**
     * @param info (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_DETAIL_Upd(info: CM_REPORT_TEMPLATE_DETAIL_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_DETAIL_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(info);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_DETAIL_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_DETAIL_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_DETAIL_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param templateDetailId (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_DETAIL_ById(templateDetailId: string | null | undefined): Observable<CM_REPORT_TEMPLATE_DETAIL_ENTITY> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_DETAIL_ById?";
        if (templateDetailId !== undefined)
            url_ += "templateDetailId=" + encodeURIComponent("" + templateDetailId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_DETAIL_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_DETAIL_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_REPORT_TEMPLATE_DETAIL_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_REPORT_TEMPLATE_DETAIL_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_DETAIL_ById(response: HttpResponseBase): Observable<CM_REPORT_TEMPLATE_DETAIL_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_REPORT_TEMPLATE_DETAIL_ENTITY.fromJS(resultData200) : new CM_REPORT_TEMPLATE_DETAIL_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_REPORT_TEMPLATE_DETAIL_ENTITY>(<any>null);
    }
}

@Injectable()
export class RetLCServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    rEAL_ESTATE_L_C_Search(input: REAL_ESTATE_L_C_ENTITY | null | undefined): Observable<PagedResultDtoOfREAL_ESTATE_L_C_ENTITY> {
        let url_ = this.baseUrl + "/api/RetLC/REAL_ESTATE_L_C_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREAL_ESTATE_L_C_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREAL_ESTATE_L_C_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfREAL_ESTATE_L_C_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfREAL_ESTATE_L_C_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREAL_ESTATE_L_C_Search(response: HttpResponseBase): Observable<PagedResultDtoOfREAL_ESTATE_L_C_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfREAL_ESTATE_L_C_ENTITY.fromJS(resultData200) : new PagedResultDtoOfREAL_ESTATE_L_C_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfREAL_ESTATE_L_C_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    rEAL_ESTATE_L_C_Ins(input: REAL_ESTATE_L_C_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/RetLC/REAL_ESTATE_L_C_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREAL_ESTATE_L_C_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREAL_ESTATE_L_C_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processREAL_ESTATE_L_C_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    rEAL_ESTATE_L_C_Upd(input: REAL_ESTATE_L_C_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/RetLC/REAL_ESTATE_L_C_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREAL_ESTATE_L_C_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREAL_ESTATE_L_C_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processREAL_ESTATE_L_C_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEAL_ESTATE_L_C_ById(id: string | null | undefined): Observable<REAL_ESTATE_L_C_ENTITY> {
        let url_ = this.baseUrl + "/api/RetLC/REAL_ESTATE_L_C_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREAL_ESTATE_L_C_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREAL_ESTATE_L_C_ById(<any>response_);
                } catch (e) {
                    return <Observable<REAL_ESTATE_L_C_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<REAL_ESTATE_L_C_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREAL_ESTATE_L_C_ById(response: HttpResponseBase): Observable<REAL_ESTATE_L_C_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? REAL_ESTATE_L_C_ENTITY.fromJS(resultData200) : new REAL_ESTATE_L_C_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<REAL_ESTATE_L_C_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEAL_ESTATE_L_C_Del(id: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/RetLC/REAL_ESTATE_L_C_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREAL_ESTATE_L_C_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREAL_ESTATE_L_C_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processREAL_ESTATE_L_C_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEAL_ESTATE_L_C_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/RetLC/REAL_ESTATE_L_C_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREAL_ESTATE_L_C_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREAL_ESTATE_L_C_App(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processREAL_ESTATE_L_C_App(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class RetRepairServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    rET_REPAIR_Search(input: RET_REPAIR_ENTITY | null | undefined): Observable<PagedResultDtoOfRET_REPAIR_ENTITY> {
        let url_ = this.baseUrl + "/api/RetRepair/RET_REPAIR_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRET_REPAIR_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRET_REPAIR_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRET_REPAIR_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRET_REPAIR_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processRET_REPAIR_Search(response: HttpResponseBase): Observable<PagedResultDtoOfRET_REPAIR_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRET_REPAIR_ENTITY.fromJS(resultData200) : new PagedResultDtoOfRET_REPAIR_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRET_REPAIR_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    rET_REPAIR_Ins(input: RET_REPAIR_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/RetRepair/RET_REPAIR_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRET_REPAIR_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRET_REPAIR_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processRET_REPAIR_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    rET_REPAIR_Upd(input: RET_REPAIR_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/RetRepair/RET_REPAIR_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRET_REPAIR_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRET_REPAIR_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processRET_REPAIR_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rET_REPAIR_ById(id: string | null | undefined): Observable<RET_REPAIR_ENTITY> {
        let url_ = this.baseUrl + "/api/RetRepair/RET_REPAIR_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRET_REPAIR_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRET_REPAIR_ById(<any>response_);
                } catch (e) {
                    return <Observable<RET_REPAIR_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<RET_REPAIR_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processRET_REPAIR_ById(response: HttpResponseBase): Observable<RET_REPAIR_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RET_REPAIR_ENTITY.fromJS(resultData200) : new RET_REPAIR_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RET_REPAIR_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rET_REPAIR_Del(id: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/RetRepair/RET_REPAIR_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRET_REPAIR_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRET_REPAIR_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processRET_REPAIR_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rET_REPAIR_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/RetRepair/RET_REPAIR_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRET_REPAIR_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRET_REPAIR_App(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processRET_REPAIR_App(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class RetRHServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    rEAL_ESTATE_R_H_Search(input: REAL_ESTATE_R_H_ENTITY | null | undefined): Observable<PagedResultDtoOfREAL_ESTATE_R_H_ENTITY> {
        let url_ = this.baseUrl + "/api/RetRH/REAL_ESTATE_R_H_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREAL_ESTATE_R_H_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREAL_ESTATE_R_H_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfREAL_ESTATE_R_H_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfREAL_ESTATE_R_H_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREAL_ESTATE_R_H_Search(response: HttpResponseBase): Observable<PagedResultDtoOfREAL_ESTATE_R_H_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfREAL_ESTATE_R_H_ENTITY.fromJS(resultData200) : new PagedResultDtoOfREAL_ESTATE_R_H_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfREAL_ESTATE_R_H_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    rEAL_ESTATE_R_H_Ins(input: REAL_ESTATE_R_H_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/RetRH/REAL_ESTATE_R_H_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREAL_ESTATE_R_H_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREAL_ESTATE_R_H_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processREAL_ESTATE_R_H_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    rEAL_ESTATE_R_H_Upd(input: REAL_ESTATE_R_H_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/RetRH/REAL_ESTATE_R_H_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREAL_ESTATE_R_H_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREAL_ESTATE_R_H_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processREAL_ESTATE_R_H_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEAL_ESTATE_R_H_ById(id: string | null | undefined): Observable<REAL_ESTATE_R_H_ENTITY> {
        let url_ = this.baseUrl + "/api/RetRH/REAL_ESTATE_R_H_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREAL_ESTATE_R_H_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREAL_ESTATE_R_H_ById(<any>response_);
                } catch (e) {
                    return <Observable<REAL_ESTATE_R_H_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<REAL_ESTATE_R_H_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREAL_ESTATE_R_H_ById(response: HttpResponseBase): Observable<REAL_ESTATE_R_H_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? REAL_ESTATE_R_H_ENTITY.fromJS(resultData200) : new REAL_ESTATE_R_H_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<REAL_ESTATE_R_H_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEAL_ESTATE_R_H_Del(id: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/RetRH/REAL_ESTATE_R_H_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREAL_ESTATE_R_H_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREAL_ESTATE_R_H_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processREAL_ESTATE_R_H_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEAL_ESTATE_R_H_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/RetRH/REAL_ESTATE_R_H_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREAL_ESTATE_R_H_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREAL_ESTATE_R_H_App(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processREAL_ESTATE_R_H_App(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param permission (optional) 
     * @param roleName (optional) 
     * @return Success
     */
    getRoles(permission: string | null | undefined, roleName: string | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        if (roleName !== undefined)
            url_ += "RoleName=" + encodeURIComponent("" + roleName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllRole(): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllRole";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRole(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRole(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateRole(input: CreateOrUpdateRoleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRole(id: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class RoxyFilemanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param type (optional) 
     * @param functionFolder (optional) 
     * @param session (optional) 
     * @return Success
     */
    dIRLIST(type: string | null | undefined, functionFolder: string | null | undefined, session: ISession | null | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/services/app/RoxyFileman/DIRLIST?";
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (functionFolder !== undefined)
            url_ += "functionFolder=" + encodeURIComponent("" + functionFolder) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(session);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDIRLIST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDIRLIST(<any>response_);
                } catch (e) {
                    return <Observable<StringResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringResult>><any>_observableThrow(response_);
        }));
    }

    protected processDIRLIST(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringResult.fromJS(resultData200) : new StringResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringResult>(<any>null);
    }

    /**
     * @param d (optional) 
     * @param type (optional) 
     * @param session (optional) 
     * @return Success
     */
    fILESLIST(d: string | null | undefined, type: string | null | undefined, session: ISession | null | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/services/app/RoxyFileman/FILESLIST?";
        if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(session);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFILESLIST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFILESLIST(<any>response_);
                } catch (e) {
                    return <Observable<StringResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringResult>><any>_observableThrow(response_);
        }));
    }

    protected processFILESLIST(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringResult.fromJS(resultData200) : new StringResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringResult>(<any>null);
    }

    /**
     * @param d (optional) 
     * @param n (optional) 
     * @param session (optional) 
     * @return Success
     */
    cOPYDIR(d: string | null | undefined, n: string | null | undefined, session: ISession | null | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/services/app/RoxyFileman/COPYDIR?";
        if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&"; 
        if (n !== undefined)
            url_ += "n=" + encodeURIComponent("" + n) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(session);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCOPYDIR(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCOPYDIR(<any>response_);
                } catch (e) {
                    return <Observable<StringResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringResult>><any>_observableThrow(response_);
        }));
    }

    protected processCOPYDIR(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringResult.fromJS(resultData200) : new StringResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringResult>(<any>null);
    }

    /**
     * @param f (optional) 
     * @param n (optional) 
     * @param session (optional) 
     * @return Success
     */
    cOPYFILE(f: string | null | undefined, n: string | null | undefined, session: ISession | null | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/services/app/RoxyFileman/COPYFILE?";
        if (f !== undefined)
            url_ += "f=" + encodeURIComponent("" + f) + "&"; 
        if (n !== undefined)
            url_ += "n=" + encodeURIComponent("" + n) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(session);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCOPYFILE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCOPYFILE(<any>response_);
                } catch (e) {
                    return <Observable<StringResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringResult>><any>_observableThrow(response_);
        }));
    }

    protected processCOPYFILE(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringResult.fromJS(resultData200) : new StringResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringResult>(<any>null);
    }

    /**
     * @param d (optional) 
     * @param n (optional) 
     * @param session (optional) 
     * @return Success
     */
    cREATEDIR(d: string | null | undefined, n: string | null | undefined, session: ISession | null | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/services/app/RoxyFileman/CREATEDIR?";
        if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&"; 
        if (n !== undefined)
            url_ += "n=" + encodeURIComponent("" + n) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(session);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCREATEDIR(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCREATEDIR(<any>response_);
                } catch (e) {
                    return <Observable<StringResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringResult>><any>_observableThrow(response_);
        }));
    }

    protected processCREATEDIR(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringResult.fromJS(resultData200) : new StringResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringResult>(<any>null);
    }

    /**
     * @param d (optional) 
     * @param isAvailable (optional) 
     * @param id (optional) 
     * @param keys (optional) 
     * @return Success
     */
    dELETEDIR(d: string | null | undefined, isAvailable: boolean | null | undefined, id: string | null | undefined, keys: string[] | null | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/services/app/RoxyFileman/DELETEDIR?";
        if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&"; 
        if (isAvailable !== undefined)
            url_ += "IsAvailable=" + encodeURIComponent("" + isAvailable) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (keys !== undefined)
            keys && keys.forEach(item => { url_ += "Keys=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDELETEDIR(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDELETEDIR(<any>response_);
                } catch (e) {
                    return <Observable<StringResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringResult>><any>_observableThrow(response_);
        }));
    }

    protected processDELETEDIR(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringResult.fromJS(resultData200) : new StringResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringResult>(<any>null);
    }

    /**
     * @param f (optional) 
     * @param isAvailable (optional) 
     * @param id (optional) 
     * @param keys (optional) 
     * @return Success
     */
    dELETEFILE(f: string | null | undefined, isAvailable: boolean | null | undefined, id: string | null | undefined, keys: string[] | null | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/services/app/RoxyFileman/DELETEFILE?";
        if (f !== undefined)
            url_ += "f=" + encodeURIComponent("" + f) + "&"; 
        if (isAvailable !== undefined)
            url_ += "IsAvailable=" + encodeURIComponent("" + isAvailable) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (keys !== undefined)
            keys && keys.forEach(item => { url_ += "Keys=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDELETEFILE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDELETEFILE(<any>response_);
                } catch (e) {
                    return <Observable<StringResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringResult>><any>_observableThrow(response_);
        }));
    }

    protected processDELETEFILE(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringResult.fromJS(resultData200) : new StringResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringResult>(<any>null);
    }

    /**
     * @param f (optional) 
     * @param session (optional) 
     * @return Success
     */
    dOWNLOAD(f: string | null | undefined, session: ISession | null | undefined): Observable<FileResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RoxyFileman/DOWNLOAD?";
        if (f !== undefined)
            url_ += "f=" + encodeURIComponent("" + f) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(session);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDOWNLOAD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDOWNLOAD(<any>response_);
                } catch (e) {
                    return <Observable<FileResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processDOWNLOAD(response: HttpResponseBase): Observable<FileResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileResultDto.fromJS(resultData200) : new FileResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResultDto>(<any>null);
    }

    /**
     * @param d (optional) 
     * @return Success
     */
    dOWNLOADDIR(d: string | null | undefined): Observable<FileResultDto> {
        let url_ = this.baseUrl + "/api/services/app/RoxyFileman/DOWNLOADDIR?";
        if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDOWNLOADDIR(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDOWNLOADDIR(<any>response_);
                } catch (e) {
                    return <Observable<FileResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processDOWNLOADDIR(response: HttpResponseBase): Observable<FileResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileResultDto.fromJS(resultData200) : new FileResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResultDto>(<any>null);
    }

    /**
     * @param d (optional) 
     * @param n (optional) 
     * @param session (optional) 
     * @return Success
     */
    mOVEDIR(d: string | null | undefined, n: string | null | undefined, session: ISession | null | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/services/app/RoxyFileman/MOVEDIR?";
        if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&"; 
        if (n !== undefined)
            url_ += "n=" + encodeURIComponent("" + n) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(session);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMOVEDIR(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMOVEDIR(<any>response_);
                } catch (e) {
                    return <Observable<StringResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringResult>><any>_observableThrow(response_);
        }));
    }

    protected processMOVEDIR(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringResult.fromJS(resultData200) : new StringResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringResult>(<any>null);
    }

    /**
     * @param f (optional) 
     * @param n (optional) 
     * @param session (optional) 
     * @return Success
     */
    mOVEFILE(f: string | null | undefined, n: string | null | undefined, session: ISession | null | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/services/app/RoxyFileman/MOVEFILE?";
        if (f !== undefined)
            url_ += "f=" + encodeURIComponent("" + f) + "&"; 
        if (n !== undefined)
            url_ += "n=" + encodeURIComponent("" + n) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(session);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMOVEFILE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMOVEFILE(<any>response_);
                } catch (e) {
                    return <Observable<StringResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringResult>><any>_observableThrow(response_);
        }));
    }

    protected processMOVEFILE(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringResult.fromJS(resultData200) : new StringResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringResult>(<any>null);
    }

    /**
     * @param d (optional) 
     * @param n (optional) 
     * @param session (optional) 
     * @return Success
     */
    rENAMEDIR(d: string | null | undefined, n: string | null | undefined, session: ISession | null | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/services/app/RoxyFileman/RENAMEDIR?";
        if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&"; 
        if (n !== undefined)
            url_ += "n=" + encodeURIComponent("" + n) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(session);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRENAMEDIR(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRENAMEDIR(<any>response_);
                } catch (e) {
                    return <Observable<StringResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringResult>><any>_observableThrow(response_);
        }));
    }

    protected processRENAMEDIR(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringResult.fromJS(resultData200) : new StringResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringResult>(<any>null);
    }

    /**
     * @param f (optional) 
     * @param n (optional) 
     * @param session (optional) 
     * @return Success
     */
    rENAMEFILE(f: string | null | undefined, n: string | null | undefined, session: ISession | null | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/services/app/RoxyFileman/RENAMEFILE?";
        if (f !== undefined)
            url_ += "f=" + encodeURIComponent("" + f) + "&"; 
        if (n !== undefined)
            url_ += "n=" + encodeURIComponent("" + n) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(session);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRENAMEFILE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRENAMEFILE(<any>response_);
                } catch (e) {
                    return <Observable<StringResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringResult>><any>_observableThrow(response_);
        }));
    }

    protected processRENAMEFILE(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringResult.fromJS(resultData200) : new StringResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringResult>(<any>null);
    }

    /**
     * @param d (optional) 
     * @param files (optional) 
     * @param session (optional) 
     * @param isAjaxUpload (optional) 
     * @return Success
     */
    uPLOAD(d: string | null | undefined, files: any[] | null | undefined, session: ISession | null | undefined, isAjaxUpload: boolean | null | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/services/app/RoxyFileman/UPLOAD?";
        if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&"; 
        if (isAjaxUpload !== undefined)
            url_ += "isAjaxUpload=" + encodeURIComponent("" + isAjaxUpload) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            content_.append("files", files.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUPLOAD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUPLOAD(<any>response_);
                } catch (e) {
                    return <Observable<StringResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringResult>><any>_observableThrow(response_);
        }));
    }

    protected processUPLOAD(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringResult.fromJS(resultData200) : new StringResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringResult>(<any>null);
    }

    /**
     * @param d (optional) 
     * @param g (optional) 
     * @param files (optional) 
     * @param session (optional) 
     * @param isAjaxUpload (optional) 
     * @return Success
     */
    uPLOAD_W_T(d: string | null | undefined, g: string | null | undefined, files: any[] | null | undefined, session: ISession | null | undefined, isAjaxUpload: boolean | null | undefined): Observable<UPLOAD_W_T_RESULT> {
        let url_ = this.baseUrl + "/api/services/app/RoxyFileman/UPLOAD_W_T?";
        if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&"; 
        if (g !== undefined)
            url_ += "g=" + encodeURIComponent("" + g) + "&"; 
        if (isAjaxUpload !== undefined)
            url_ += "isAjaxUpload=" + encodeURIComponent("" + isAjaxUpload) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            content_.append("files", files.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUPLOAD_W_T(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUPLOAD_W_T(<any>response_);
                } catch (e) {
                    return <Observable<UPLOAD_W_T_RESULT>><any>_observableThrow(e);
                }
            } else
                return <Observable<UPLOAD_W_T_RESULT>><any>_observableThrow(response_);
        }));
    }

    protected processUPLOAD_W_T(response: HttpResponseBase): Observable<UPLOAD_W_T_RESULT> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UPLOAD_W_T_RESULT.fromJS(resultData200) : new UPLOAD_W_T_RESULT();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UPLOAD_W_T_RESULT>(<any>null);
    }

    /**
     * @param claimKey (optional) 
     * @return Success
     */
    getClaimValue(claimKey: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/RoxyFileman/GetClaimValue?";
        if (claimKey !== undefined)
            url_ += "claimKey=" + encodeURIComponent("" + claimKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaimValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaimValue(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetClaimValue(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getFunctionId(permission: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/RoxyFileman/GetFunctionId?";
        if (permission !== undefined)
            url_ += "permission=" + encodeURIComponent("" + permission) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFunctionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFunctionId(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetFunctionId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class RoxyFileman1ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param path (optional) 
     * @return Success
     */
    dOWNLOAD(path: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/RoxyFileman1/DOWNLOAD?";
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDOWNLOAD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDOWNLOAD(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDOWNLOAD(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateUserSignInTokenOutput.fromJS(resultData200) : new UpdateUserSignInTokenOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
    }
}

@Injectable()
export class SettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllAppSetting(): Observable<SettingDto> {
        let url_ = this.baseUrl + "/api/Setting/GetAllAppSetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAppSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAppSetting(<any>response_);
                } catch (e) {
                    return <Observable<SettingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SettingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAppSetting(response: HttpResponseBase): Observable<SettingDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SettingDto.fromJS(resultData200) : new SettingDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettingDto>(<any>null);
    }
}

@Injectable()
export class StripePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    confirmPayment(input: StripeConfirmPaymentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/ConfirmPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createSubscription(input: StripeCreateSubscriptionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/CreateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateSubscription(input: StripeUpdateSubscriptionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/UpdateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<StripeConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<StripeConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StripeConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<StripeConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StripeConfigurationDto.fromJS(resultData200) : new StripeConfigurationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripeConfigurationDto>(<any>null);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    upgradeTenantToEquivalentEdition(upgradeEditionId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/UpgradeTenantToEquivalentEdition?";
        if (upgradeEditionId !== undefined)
            url_ += "upgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeTenantToEquivalentEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeTenantToEquivalentEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeTenantToEquivalentEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    disableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/DisableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDisableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    enableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/EnableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEnableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SupplierServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_SUPPLIER_Search(input: CM_SUPPLIER_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_SUPPLIER_ENTITY> {
        let url_ = this.baseUrl + "/api/Supplier/CM_SUPPLIER_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIER_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIER_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_SUPPLIER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_SUPPLIER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIER_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_SUPPLIER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_SUPPLIER_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_SUPPLIER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_SUPPLIER_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_SUPPLIER_ToExcel(input: CM_SUPPLIER_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Supplier/CM_SUPPLIER_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIER_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIER_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIER_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_SUPPLIER_Ins(input: CM_SUPPLIER_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Supplier/CM_SUPPLIER_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIER_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIER_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIER_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_SUPPLIER_Upd(input: CM_SUPPLIER_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Supplier/CM_SUPPLIER_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIER_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIER_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIER_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_SUPPLIER_ById(id: string | null | undefined): Observable<CM_SUPPLIER_ENTITY> {
        let url_ = this.baseUrl + "/api/Supplier/CM_SUPPLIER_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIER_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIER_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_SUPPLIER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_SUPPLIER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIER_ById(response: HttpResponseBase): Observable<CM_SUPPLIER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_SUPPLIER_ENTITY.fromJS(resultData200) : new CM_SUPPLIER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_SUPPLIER_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_SUPPLIER_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Supplier/CM_SUPPLIER_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIER_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIER_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIER_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_SUPPLIER_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Supplier/CM_SUPPLIER_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIER_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIER_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIER_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class SupplierTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_SUPPLIERTYPE_Search(input: CM_SUPPLIERTYPE_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY> {
        let url_ = this.baseUrl + "/api/SupplierType/CM_SUPPLIERTYPE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIERTYPE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIERTYPE_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIERTYPE_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_SUPPLIERTYPE_Ins(input: CM_SUPPLIERTYPE_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/SupplierType/CM_SUPPLIERTYPE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIERTYPE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIERTYPE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIERTYPE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_SUPPLIERTYPE_Upd(input: CM_SUPPLIERTYPE_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/SupplierType/CM_SUPPLIERTYPE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIERTYPE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIERTYPE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIERTYPE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_SUPPLIERTYPE_ById(id: string | null | undefined): Observable<CM_SUPPLIERTYPE_ENTITY> {
        let url_ = this.baseUrl + "/api/SupplierType/CM_SUPPLIERTYPE_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIERTYPE_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIERTYPE_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_SUPPLIERTYPE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_SUPPLIERTYPE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIERTYPE_ById(response: HttpResponseBase): Observable<CM_SUPPLIERTYPE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_SUPPLIERTYPE_ENTITY.fromJS(resultData200) : new CM_SUPPLIERTYPE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_SUPPLIERTYPE_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_SUPPLIERTYPE_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/SupplierType/CM_SUPPLIERTYPE_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIERTYPE_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIERTYPE_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIERTYPE_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_SUPPLIERTYPE_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/SupplierType/CM_SUPPLIERTYPE_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIERTYPE_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIERTYPE_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIERTYPE_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class SysParametersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sYS_PARAMETERS_Search(input: SYS_PARAMETERS_ENTITY | null | undefined): Observable<PagedResultDtoOfSYS_PARAMETERS_ENTITY> {
        let url_ = this.baseUrl + "/api/SysParameters/SYS_PARAMETERS_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSYS_PARAMETERS_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_PARAMETERS_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSYS_PARAMETERS_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSYS_PARAMETERS_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_PARAMETERS_Search(response: HttpResponseBase): Observable<PagedResultDtoOfSYS_PARAMETERS_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSYS_PARAMETERS_ENTITY.fromJS(resultData200) : new PagedResultDtoOfSYS_PARAMETERS_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSYS_PARAMETERS_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sYS_PARAMETERS_ToExcel(input: SYS_PARAMETERS_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/SysParameters/SYS_PARAMETERS_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSYS_PARAMETERS_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_PARAMETERS_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_PARAMETERS_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sYS_PARAMETERS_Ins(input: SYS_PARAMETERS_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/SysParameters/SYS_PARAMETERS_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSYS_PARAMETERS_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_PARAMETERS_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_PARAMETERS_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sYS_PARAMETERS_Upd(input: SYS_PARAMETERS_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/SysParameters/SYS_PARAMETERS_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSYS_PARAMETERS_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_PARAMETERS_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_PARAMETERS_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    sYS_PARAMETERS_ById(id: number | null | undefined): Observable<SYS_PARAMETERS_ENTITY> {
        let url_ = this.baseUrl + "/api/SysParameters/SYS_PARAMETERS_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSYS_PARAMETERS_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_PARAMETERS_ById(<any>response_);
                } catch (e) {
                    return <Observable<SYS_PARAMETERS_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<SYS_PARAMETERS_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_PARAMETERS_ById(response: HttpResponseBase): Observable<SYS_PARAMETERS_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SYS_PARAMETERS_ENTITY.fromJS(resultData200) : new SYS_PARAMETERS_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SYS_PARAMETERS_ENTITY>(<any>null);
    }

    /**
     * @param parakey (optional) 
     * @return Success
     */
    sYS_PARAMETERS_ByParaKey(parakey: string | null | undefined): Observable<SYS_PARAMETERS_ENTITY> {
        let url_ = this.baseUrl + "/api/SysParameters/SYS_PARAMETERS_ByParaKey?";
        if (parakey !== undefined)
            url_ += "parakey=" + encodeURIComponent("" + parakey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSYS_PARAMETERS_ByParaKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_PARAMETERS_ByParaKey(<any>response_);
                } catch (e) {
                    return <Observable<SYS_PARAMETERS_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<SYS_PARAMETERS_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_PARAMETERS_ByParaKey(response: HttpResponseBase): Observable<SYS_PARAMETERS_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SYS_PARAMETERS_ENTITY.fromJS(resultData200) : new SYS_PARAMETERS_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SYS_PARAMETERS_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    sYS_PARAMETERS_Del(id: number | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/SysParameters/SYS_PARAMETERS_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSYS_PARAMETERS_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_PARAMETERS_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_PARAMETERS_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class TemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_TEMPLATE_Search(input: HR_TEMPLATE_ENTITY | null | undefined): Observable<PagedResultDtoOfHR_TEMPLATE_ENTITY> {
        let url_ = this.baseUrl + "/api/Template/HR_TEMPLATE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_TEMPLATE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_TEMPLATE_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfHR_TEMPLATE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfHR_TEMPLATE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_TEMPLATE_Search(response: HttpResponseBase): Observable<PagedResultDtoOfHR_TEMPLATE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfHR_TEMPLATE_ENTITY.fromJS(resultData200) : new PagedResultDtoOfHR_TEMPLATE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfHR_TEMPLATE_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_TEMPLATE_ToExcel(input: HR_TEMPLATE_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Template/HR_TEMPLATE_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_TEMPLATE_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_TEMPLATE_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processHR_TEMPLATE_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_TEMPLATE_Ins(input: HR_TEMPLATE_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Template/HR_TEMPLATE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_TEMPLATE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_TEMPLATE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_TEMPLATE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_TEMPLATE_Upd(input: HR_TEMPLATE_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Template/HR_TEMPLATE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_TEMPLATE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_TEMPLATE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_TEMPLATE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_TEMPLATE_ById(id: string | null | undefined): Observable<HR_TEMPLATE_ENTITY> {
        let url_ = this.baseUrl + "/api/Template/HR_TEMPLATE_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_TEMPLATE_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_TEMPLATE_ById(<any>response_);
                } catch (e) {
                    return <Observable<HR_TEMPLATE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_TEMPLATE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_TEMPLATE_ById(response: HttpResponseBase): Observable<HR_TEMPLATE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HR_TEMPLATE_ENTITY.fromJS(resultData200) : new HR_TEMPLATE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_TEMPLATE_ENTITY>(<any>null);
    }

    /**
     * @param maCty (optional) 
     * @return Success
     */
    hR_TEMPLATE_ByCty(maCty: number | null | undefined): Observable<HR_TEMPLATE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Template/HR_TEMPLATE_ByCty?";
        if (maCty !== undefined)
            url_ += "MaCty=" + encodeURIComponent("" + maCty) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_TEMPLATE_ByCty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_TEMPLATE_ByCty(<any>response_);
                } catch (e) {
                    return <Observable<HR_TEMPLATE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_TEMPLATE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processHR_TEMPLATE_ByCty(response: HttpResponseBase): Observable<HR_TEMPLATE_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HR_TEMPLATE_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_TEMPLATE_ENTITY[]>(<any>null);
    }

    /**
     * @param maCty (optional) 
     * @return Success
     */
    hR_TEMPLATE_GetList(maCty: number | null | undefined): Observable<HR_TEMPLATE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Template/HR_TEMPLATE_GetList?";
        if (maCty !== undefined)
            url_ += "maCty=" + encodeURIComponent("" + maCty) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_TEMPLATE_GetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_TEMPLATE_GetList(<any>response_);
                } catch (e) {
                    return <Observable<HR_TEMPLATE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_TEMPLATE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processHR_TEMPLATE_GetList(response: HttpResponseBase): Observable<HR_TEMPLATE_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HR_TEMPLATE_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_TEMPLATE_ENTITY[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_TEMPLATE_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Template/HR_TEMPLATE_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_TEMPLATE_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_TEMPLATE_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_TEMPLATE_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    hR_TEMPLATE_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Template/HR_TEMPLATE_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_TEMPLATE_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_TEMPLATE_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_TEMPLATE_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param subscriptionEndDateStart (optional) 
     * @param subscriptionEndDateEnd (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param editionId (optional) 
     * @param editionIdSpecified (optional) 
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | null | undefined, subscriptionEndDateStart: moment.Moment | null | undefined, subscriptionEndDateEnd: moment.Moment | null | undefined, creationDateStart: moment.Moment | null | undefined, creationDateEnd: moment.Moment | null | undefined, editionId: number | null | undefined, editionIdSpecified: boolean | null | undefined, tOP: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (subscriptionEndDateStart !== undefined)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toJSON() : "") + "&"; 
        if (subscriptionEndDateEnd !== undefined)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toJSON() : "") + "&"; 
        if (creationDateStart !== undefined)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&"; 
        if (creationDateEnd !== undefined)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&"; 
        if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&"; 
        if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&"; 
        if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantListDto.fromJS(resultData200) : new PagedResultDtoOfTenantListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createTenant(input: CreateTenantInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | null | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(<any>response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantEditDto.fromJS(resultData200) : new TenantEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateTenant(input: TenantEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTenant(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteTenant?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | null | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTenantFeaturesEditOutput.fromJS(resultData200) : new GetTenantFeaturesEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateTenantFeatures(input: UpdateTenantFeaturesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlockTenantAdmin(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberActivityOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberActivityOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemberActivityOutput.fromJS(resultData200) : new GetMemberActivityOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberActivityOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<GetDashboardDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDashboardDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDashboardDataOutput.fromJS(resultData200) : new GetDashboardDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDashboardDataOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getTopStats(): Observable<GetTopStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetTopStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStats(<any>response_);
                } catch (e) {
                    return <Observable<GetTopStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTopStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTopStats(response: HttpResponseBase): Observable<GetTopStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTopStatsOutput.fromJS(resultData200) : new GetTopStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTopStatsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfitShare(): Observable<GetProfitShareOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetProfitShare";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfitShare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfitShare(<any>response_);
                } catch (e) {
                    return <Observable<GetProfitShareOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfitShareOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfitShare(response: HttpResponseBase): Observable<GetProfitShareOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfitShareOutput.fromJS(resultData200) : new GetProfitShareOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfitShareOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getDailySales(): Observable<GetDailySalesOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDailySales";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDailySales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDailySales(<any>response_);
                } catch (e) {
                    return <Observable<GetDailySalesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDailySalesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDailySales(response: HttpResponseBase): Observable<GetDailySalesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDailySalesOutput.fromJS(resultData200) : new GetDailySalesOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDailySalesOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(<any>response_);
                } catch (e) {
                    return <Observable<GetSalesSummaryOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSalesSummaryOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSalesSummaryOutput.fromJS(resultData200) : new GetSalesSummaryOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSalesSummaryOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getRegionalStats(): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRegionalStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionalStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(<any>response_);
                } catch (e) {
                    return <Observable<GetRegionalStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRegionalStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRegionalStatsOutput.fromJS(resultData200) : new GetRegionalStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRegionalStatsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getGeneralStats(): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetGeneralStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(<any>response_);
                } catch (e) {
                    return <Observable<GetGeneralStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGeneralStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetGeneralStatsOutput.fromJS(resultData200) : new GetGeneralStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGeneralStatsOutput>(<any>null);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    registerTenant(input: RegisterTenantInput | null | undefined): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterTenantOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterTenantOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterTenantOutput.fromJS(resultData200) : new RegisterTenantOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterTenantOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForSelect(<any>response_);
                } catch (e) {
                    return <Observable<EditionsSelectOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionsSelectOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionsSelectOutput.fromJS(resultData200) : new EditionsSelectOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionsSelectOutput>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getEdition(editionId: number | null | undefined): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEdition?";
        if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEdition(<any>response_);
                } catch (e) {
                    return <Observable<EditionSelectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionSelectDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionSelectDto.fromJS(resultData200) : new EditionSelectDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionSelectDto>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSettingsEditDto.fromJS(resultData200) : new TenantSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateAllSettings(input: TenantSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TermServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filterInput (optional) 
     * @return Success
     */
    cM_TERM_Search(filterInput: CM_TERM_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_TERM_ENTITY> {
        let url_ = this.baseUrl + "/api/Term/CM_TERM_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_TERM_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_TERM_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_TERM_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_TERM_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_TERM_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_TERM_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_TERM_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_TERM_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_TERM_ENTITY>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfNameValueDto.fromJS(resultData200) : new ListResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class TinhThanhServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    dM_TINHTHANH_Search(input: DM_TINHTHANH_ENTITY | null | undefined): Observable<PagedResultDtoOfDM_TINHTHANH_ENTITY> {
        let url_ = this.baseUrl + "/api/TinhThanh/DM_TINHTHANH_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDM_TINHTHANH_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDM_TINHTHANH_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDM_TINHTHANH_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDM_TINHTHANH_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processDM_TINHTHANH_Search(response: HttpResponseBase): Observable<PagedResultDtoOfDM_TINHTHANH_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDM_TINHTHANH_ENTITY.fromJS(resultData200) : new PagedResultDtoOfDM_TINHTHANH_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDM_TINHTHANH_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    dM_TINHTHANH_ToExcel(input: DM_TINHTHANH_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/TinhThanh/DM_TINHTHANH_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDM_TINHTHANH_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDM_TINHTHANH_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDM_TINHTHANH_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    dM_TINHTHANH_Ins(input: DM_TINHTHANH_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/TinhThanh/DM_TINHTHANH_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDM_TINHTHANH_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDM_TINHTHANH_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processDM_TINHTHANH_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    dM_TINHTHANH_Upd(input: DM_TINHTHANH_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/TinhThanh/DM_TINHTHANH_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDM_TINHTHANH_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDM_TINHTHANH_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processDM_TINHTHANH_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    dM_TINHTHANH_ById(id: string | null | undefined): Observable<DM_TINHTHANH_ENTITY> {
        let url_ = this.baseUrl + "/api/TinhThanh/DM_TINHTHANH_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDM_TINHTHANH_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDM_TINHTHANH_ById(<any>response_);
                } catch (e) {
                    return <Observable<DM_TINHTHANH_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<DM_TINHTHANH_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processDM_TINHTHANH_ById(response: HttpResponseBase): Observable<DM_TINHTHANH_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DM_TINHTHANH_ENTITY.fromJS(resultData200) : new DM_TINHTHANH_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DM_TINHTHANH_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    dM_TINHTHANH_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/TinhThanh/DM_TINHTHANH_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDM_TINHTHANH_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDM_TINHTHANH_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processDM_TINHTHANH_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    dM_TINHTHANH_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/TinhThanh/DM_TINHTHANH_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDM_TINHTHANH_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDM_TINHTHANH_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processDM_TINHTHANH_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    dM_TINHTHANH_Lst(input: DM_TINHTHANH_ENTITY | null | undefined): Observable<DM_TINHTHANH_ENTITY[]> {
        let url_ = this.baseUrl + "/api/TinhThanh/DM_TINHTHANH_Lst";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDM_TINHTHANH_Lst(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDM_TINHTHANH_Lst(<any>response_);
                } catch (e) {
                    return <Observable<DM_TINHTHANH_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DM_TINHTHANH_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processDM_TINHTHANH_Lst(response: HttpResponseBase): Observable<DM_TINHTHANH_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DM_TINHTHANH_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DM_TINHTHANH_ENTITY[]>(<any>null);
    }
}

@Injectable()
export class TlUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    tL_USER_Search(input: TL_USER_ENTITY | null | undefined): Observable<PagedResultDtoOfTL_USER_ENTITY> {
        let url_ = this.baseUrl + "/api/TlUser/TL_USER_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_USER_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_USER_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTL_USER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTL_USER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processTL_USER_Search(response: HttpResponseBase): Observable<PagedResultDtoOfTL_USER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTL_USER_ENTITY.fromJS(resultData200) : new PagedResultDtoOfTL_USER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTL_USER_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    tL_USER_Ins(input: TL_USER_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/TlUser/TL_USER_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_USER_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_USER_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processTL_USER_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    tL_USER_Upd(input: TL_USER_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/TlUser/TL_USER_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_USER_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_USER_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processTL_USER_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    tL_USER_ById(id: number | null | undefined): Observable<TL_USER_ENTITY> {
        let url_ = this.baseUrl + "/api/TlUser/TL_USER_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_USER_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_USER_ById(<any>response_);
                } catch (e) {
                    return <Observable<TL_USER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<TL_USER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processTL_USER_ById(response: HttpResponseBase): Observable<TL_USER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TL_USER_ENTITY.fromJS(resultData200) : new TL_USER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TL_USER_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    tL_USER_Del(id: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/TlUser/TL_USER_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_USER_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_USER_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processTL_USER_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    tL_USER_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/TlUser/TL_USER_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_USER_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_USER_App(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processTL_USER_App(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    autoLogin(): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AutoLogin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoLogin(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAutoLogin(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    authenticateLdap(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AuthenticateLdap";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateLdap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateLdap(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticateLdap(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    authenticateFederation(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AuthenticateFederation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateFederation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateFederation(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticateFederation(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param user (optional) 
     * @return Success
     */
    getUserInfomation(user: string | null | undefined): Observable<TL_USER_SearchResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetUserInfomation?";
        if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInfomation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInfomation(<any>response_);
                } catch (e) {
                    return <Observable<TL_USER_SearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TL_USER_SearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInfomation(response: HttpResponseBase): Observable<TL_USER_SearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TL_USER_SearchResult.fromJS(resultData200) : new TL_USER_SearchResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TL_USER_SearchResult>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    refreshToken(refreshToken: string | null | undefined): Observable<RefreshTokenResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken?";
        if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<RefreshTokenResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RefreshTokenResult>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RefreshTokenResult.fromJS(resultData200) : new RefreshTokenResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RefreshTokenResult>(<any>null);
    }

    /**
     * @return Success
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(model: SendTwoFactorAuthCodeModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonatedAuthenticateResultModel.fromJS(resultData200) : new ImpersonatedAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @param switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | null | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchedAccountAuthenticateResultModel.fromJS(resultData200) : new SwitchedAccountAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchedAccountAuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * @param message (optional) 
     * @param severity (optional) 
     * @return Success
     */
    testNotification(message: string | null | undefined, severity: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&"; 
        if (severity !== undefined)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param provider (optional) 
     * @param returnUrl (optional) 
     * @param ss (optional) 
     * @return Success
     */
    externalLogin(provider: string | null | undefined, returnUrl: string | null | undefined, ss: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalLogin?";
        if (provider !== undefined)
            url_ += "provider=" + encodeURIComponent("" + provider) + "&"; 
        if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (ss !== undefined)
            url_ += "ss=" + encodeURIComponent("" + ss) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalLogin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExternalLogin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param returnUrl (optional) 
     * @param ss (optional) 
     * @return Success
     */
    loginAdfs(returnUrl: string | null | undefined, ss: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LoginAdfs?";
        if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (ss !== undefined)
            url_ += "ss=" + encodeURIComponent("" + ss) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginAdfs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginAdfs(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLoginAdfs(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param returnUrl (optional) 
     * @param remoteError (optional) 
     * @param ss (optional) 
     * @return Success
     */
    externalLoginCallback(returnUrl: string | null | undefined, remoteError: string | null | undefined, ss: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalLoginCallback?";
        if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (remoteError !== undefined)
            url_ += "remoteError=" + encodeURIComponent("" + remoteError) + "&"; 
        if (ss !== undefined)
            url_ += "ss=" + encodeURIComponent("" + ss) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalLoginCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalLoginCallback(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExternalLoginCallback(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    signOutAdfs(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SignOutAdfs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignOutAdfs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignOutAdfs(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSignOutAdfs(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<ThemeSettingsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<ThemeSettingsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThemeSettingsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<ThemeSettingsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ThemeSettingsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThemeSettingsDto[]>(<any>null);
    }

    /**
     * @param themeName (optional) 
     * @return Success
     */
    changeThemeWithDefaultValues(themeName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/ChangeThemeWithDefaultValues?";
        if (themeName !== undefined)
            url_ += "themeName=" + encodeURIComponent("" + themeName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeThemeWithDefaultValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeThemeWithDefaultValues(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeThemeWithDefaultValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param settings (optional) 
     * @return Success
     */
    updateUiManagementSettings(settings: ThemeSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param settings (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(settings: ThemeSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UltilityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param functionId (optional) 
     * @return Success
     */
    isApproveFunct(functionId: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Ultility/IsApproveFunct?";
        if (functionId !== undefined)
            url_ += "functionId=" + encodeURIComponent("" + functionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsApproveFunct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsApproveFunct(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsApproveFunct(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param procedureName (optional) 
     * @return Success
     */
    getProcedureContent(procedureName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Ultility/GetProcedureContent?";
        if (procedureName !== undefined)
            url_ += "procedureName=" + encodeURIComponent("" + procedureName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcedureContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcedureContent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcedureContent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getLogFile(): Observable<string> {
        let url_ = this.baseUrl + "/api/Ultility/GetLogFile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogFile(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetLogFile(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param path (optional) 
     * @return Success
     */
    downloadFile(path: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Ultility/DownloadFile?";
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFile(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param files (optional) 
     * @return Success
     */
    dEL_F(files: string[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Ultility/DEL_F?";
        if (files !== undefined)
            files && files.forEach(item => { url_ += "files=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDEL_F(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDEL_F(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDEL_F(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param d (optional) 
     * @param fileName (optional) 
     * @param g (optional) 
     * @param settingName (optional) 
     * @return Success
     */
    uploadLogo(d: string | null | undefined, fileName: string | null | undefined, g: string | null | undefined, settingName: string | null | undefined): Observable<UPLOAD_W_T_RESULT> {
        let url_ = this.baseUrl + "/api/Ultility/UploadLogo?";
        if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&"; 
        if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&"; 
        if (g !== undefined)
            url_ += "g=" + encodeURIComponent("" + g) + "&"; 
        if (settingName !== undefined)
            url_ += "settingName=" + encodeURIComponent("" + settingName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadLogo(<any>response_);
                } catch (e) {
                    return <Observable<UPLOAD_W_T_RESULT>><any>_observableThrow(e);
                }
            } else
                return <Observable<UPLOAD_W_T_RESULT>><any>_observableThrow(response_);
        }));
    }

    protected processUploadLogo(response: HttpResponseBase): Observable<UPLOAD_W_T_RESULT> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UPLOAD_W_T_RESULT.fromJS(resultData200) : new UPLOAD_W_T_RESULT();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UPLOAD_W_T_RESULT>(<any>null);
    }

    /**
     * @param content (optional) 
     * @param _fileName (optional) 
     * @return Success
     */
    uploadSFtp(content: string | null | undefined, _fileName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Ultility/UploadSFtp?";
        if (content !== undefined)
            url_ += "content=" + encodeURIComponent("" + content) + "&"; 
        if (_fileName !== undefined)
            url_ += "_fileName=" + encodeURIComponent("" + _fileName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadSFtp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadSFtp(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadSFtp(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_UNIT_Search(input: CM_UNIT_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_UNIT_ENTITY> {
        let url_ = this.baseUrl + "/api/Unit/CM_UNIT_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_UNIT_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_UNIT_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_UNIT_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_UNIT_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_UNIT_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_UNIT_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_UNIT_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_UNIT_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_UNIT_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_UNIT_Ins(input: CM_UNIT_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Unit/CM_UNIT_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_UNIT_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_UNIT_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_UNIT_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_UNIT_Upd(input: CM_UNIT_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Unit/CM_UNIT_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_UNIT_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_UNIT_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_UNIT_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_UNIT_ById(id: string | null | undefined): Observable<CM_UNIT_ENTITY> {
        let url_ = this.baseUrl + "/api/Unit/CM_UNIT_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_UNIT_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_UNIT_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_UNIT_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_UNIT_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_UNIT_ById(response: HttpResponseBase): Observable<CM_UNIT_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_UNIT_ENTITY.fromJS(resultData200) : new CM_UNIT_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_UNIT_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_UNIT_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Unit/CM_UNIT_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_UNIT_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_UNIT_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_UNIT_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_UNIT_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Unit/CM_UNIT_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_UNIT_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_UNIT_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_UNIT_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class UngVienServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_UngVien_Search(input: HR_UngVien_ENTITY | null | undefined): Observable<PagedResultDtoOfHR_UngVien_ENTITY> {
        let url_ = this.baseUrl + "/api/UngVien/HR_UngVien_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_UngVien_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_UngVien_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfHR_UngVien_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfHR_UngVien_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_UngVien_Search(response: HttpResponseBase): Observable<PagedResultDtoOfHR_UngVien_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfHR_UngVien_ENTITY.fromJS(resultData200) : new PagedResultDtoOfHR_UngVien_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfHR_UngVien_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_UngVien_ToExcel(input: HR_UngVien_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/UngVien/HR_UngVien_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_UngVien_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_UngVien_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processHR_UngVien_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_UngVien_Ins(input: HR_UngVien_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/UngVien/HR_UngVien_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_UngVien_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_UngVien_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_UngVien_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendEmailKH(input: HR_CauHinhEmail_ENTITY | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/UngVien/SendEmailKH";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailKH(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailKH(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailKH(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_UngVien_Upd(input: HR_UngVien_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/UngVien/HR_UngVien_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_UngVien_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_UngVien_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_UngVien_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_UngVien_ById(id: string | null | undefined): Observable<HR_UngVien_ENTITY> {
        let url_ = this.baseUrl + "/api/UngVien/HR_UngVien_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_UngVien_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_UngVien_ById(<any>response_);
                } catch (e) {
                    return <Observable<HR_UngVien_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_UngVien_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processHR_UngVien_ById(response: HttpResponseBase): Observable<HR_UngVien_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HR_UngVien_ENTITY.fromJS(resultData200) : new HR_UngVien_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_UngVien_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param autH_STATUS (optional) 
     * @return Success
     */
    hR_UngVien_Del(id: string | null | undefined, autH_STATUS: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/UngVien/HR_UngVien_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (autH_STATUS !== undefined)
            url_ += "autH_STATUS=" + encodeURIComponent("" + autH_STATUS) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_UngVien_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_UngVien_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_UngVien_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    hR_UngVien_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/UngVien/HR_UngVien_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_UngVien_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_UngVien_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_UngVien_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    hR_UngVien_UpdateTrangThai(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/UngVien/HR_UngVien_UpdateTrangThai?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_UngVien_UpdateTrangThai(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_UngVien_UpdateTrangThai(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processHR_UngVien_UpdateTrangThai(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param data (optional) 
     * @return Success
     */
    ungVienImportResult(data: FileParameter | null | undefined): Observable<InsertResult[]> {
        let url_ = this.baseUrl + "/api/UngVien/UngVienImportResult";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (data !== null && data !== undefined)
            content_.append("data", data.data, data.fileName ? data.fileName : "data");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUngVienImportResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUngVienImportResult(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult[]>><any>_observableThrow(response_);
        }));
    }

    protected processUngVienImportResult(response: HttpResponseBase): Observable<InsertResult[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(InsertResult.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    hR_UngVien_Lst(input: HR_UngVien_ENTITY | null | undefined): Observable<HR_UngVien_ENTITY[]> {
        let url_ = this.baseUrl + "/api/UngVien/HR_UngVien_Lst";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_UngVien_Lst(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_UngVien_Lst(<any>response_);
                } catch (e) {
                    return <Observable<HR_UngVien_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_UngVien_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processHR_UngVien_Lst(response: HttpResponseBase): Observable<HR_UngVien_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HR_UngVien_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_UngVien_ENTITY[]>(<any>null);
    }

    /**
     * @param cdType (optional) 
     * @return Success
     */
    cM_ALLCODE_GetByCDTYPE(cdType: string | null | undefined): Observable<CM_ALLCODE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/UngVien/CM_ALLCODE_GetByCDTYPE?";
        if (cdType !== undefined)
            url_ += "cdType=" + encodeURIComponent("" + cdType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALLCODE_GetByCDTYPE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALLCODE_GetByCDTYPE(<any>response_);
                } catch (e) {
                    return <Observable<CM_ALLCODE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ALLCODE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALLCODE_GetByCDTYPE(response: HttpResponseBase): Observable<CM_ALLCODE_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_ALLCODE_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ALLCODE_ENTITY[]>(<any>null);
    }

    /**
     * @param maCty (optional) 
     * @return Success
     */
    hR_TieuDeGuiMail_ByMaCty(maCty: number | null | undefined): Observable<HR_TieuDeGuiMail_ENTITY[]> {
        let url_ = this.baseUrl + "/api/UngVien/HR_TieuDeGuiMail_ByMaCty?";
        if (maCty !== undefined)
            url_ += "maCty=" + encodeURIComponent("" + maCty) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHR_TieuDeGuiMail_ByMaCty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHR_TieuDeGuiMail_ByMaCty(<any>response_);
                } catch (e) {
                    return <Observable<HR_TieuDeGuiMail_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HR_TieuDeGuiMail_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processHR_TieuDeGuiMail_ByMaCty(response: HttpResponseBase): Observable<HR_TieuDeGuiMail_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HR_TieuDeGuiMail_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HR_TieuDeGuiMail_ENTITY[]>(<any>null);
    }
}

@Injectable()
export class UpdateDateListServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    uPDATE_DATE_LIST_Search(input: UPDATE_DATE_LIST_ENTITY | null | undefined): Observable<PagedResultDtoOfUPDATE_DATE_LIST_ENTITY> {
        let url_ = this.baseUrl + "/api/UpdateDateList/UPDATE_DATE_LIST_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUPDATE_DATE_LIST_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUPDATE_DATE_LIST_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUPDATE_DATE_LIST_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUPDATE_DATE_LIST_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processUPDATE_DATE_LIST_Search(response: HttpResponseBase): Observable<PagedResultDtoOfUPDATE_DATE_LIST_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUPDATE_DATE_LIST_ENTITY.fromJS(resultData200) : new PagedResultDtoOfUPDATE_DATE_LIST_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUPDATE_DATE_LIST_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    uPDATE_DATE_LIST_ById(input: UPDATE_DATE_LIST_ENTITY | null | undefined): Observable<UPDATE_DATE_LIST_ENTITY> {
        let url_ = this.baseUrl + "/api/UpdateDateList/UPDATE_DATE_LIST_ById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUPDATE_DATE_LIST_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUPDATE_DATE_LIST_ById(<any>response_);
                } catch (e) {
                    return <Observable<UPDATE_DATE_LIST_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<UPDATE_DATE_LIST_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processUPDATE_DATE_LIST_ById(response: HttpResponseBase): Observable<UPDATE_DATE_LIST_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UPDATE_DATE_LIST_ENTITY.fromJS(resultData200) : new UPDATE_DATE_LIST_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UPDATE_DATE_LIST_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    uPDATE_DATE_LIST_Ins(input: UPDATE_DATE_LIST_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/UpdateDateList/UPDATE_DATE_LIST_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUPDATE_DATE_LIST_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUPDATE_DATE_LIST_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processUPDATE_DATE_LIST_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    uPDATE_DATE_LIST_Upd(input: UPDATE_DATE_LIST_ENTITY | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/UpdateDateList/UPDATE_DATE_LIST_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUPDATE_DATE_LIST_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUPDATE_DATE_LIST_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processUPDATE_DATE_LIST_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    uPDATE_DATE_LIST_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/UpdateDateList/UPDATE_DATE_LIST_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUPDATE_DATE_LIST_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUPDATE_DATE_LIST_App(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processUPDATE_DATE_LIST_App(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    uPDATE_DATE_LIST_Del(id: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/UpdateDateList/UPDATE_DATE_LIST_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUPDATE_DATE_LIST_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUPDATE_DATE_LIST_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processUPDATE_DATE_LIST_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getUsers(input: GetUsersInput | null | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserListDto.fromJS(resultData200) : new PagedResultDtoOfUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getUsersToExcel(input: GetUsersInput | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserForEditOutput.fromJS(resultData200) : new GetUserForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | null | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserPermissionsForEditOutput.fromJS(resultData200) : new GetUserPermissionsForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateUserPermissions(input: UpdateUserPermissionsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateUser(input: CreateOrUpdateUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUser(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    approveUser(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ApproveUser?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlockUser(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    linkToUser(input: LinkToUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLinkedUserDto.fromJS(resultData200) : new PagedResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLinkedUserDto.fromJS(resultData200) : new ListResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlinkUser(input: UnlinkUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200) : new ListResultDtoOfUserLoginAttemptDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(<any>null);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLatestWebLogsOutput.fromJS(resultData200) : new GetLatestWebLogsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class WfDefinitionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param param (optional) 
     * @return Success
     */
    wF_EXECUTE(param: WfDefinitionParam | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/WfDefinition/WF_EXECUTE";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(param);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWF_EXECUTE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWF_EXECUTE(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processWF_EXECUTE(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class WidgetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getWidgetItem(): Observable<WidgetItemSearchDto[]> {
        let url_ = this.baseUrl + "/api/Widget/GetWidgetItem";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWidgetItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWidgetItem(<any>response_);
                } catch (e) {
                    return <Observable<WidgetItemSearchDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WidgetItemSearchDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWidgetItem(response: HttpResponseBase): Observable<WidgetItemSearchDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WidgetItemSearchDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WidgetItemSearchDto[]>(<any>null);
    }

    /**
     * @param pageId (optional) 
     * @return Success
     */
    getWidgetByPageId(pageId: number | null | undefined): Observable<WidgetMapDto[]> {
        let url_ = this.baseUrl + "/api/Widget/GetWidgetByPageId?";
        if (pageId !== undefined)
            url_ += "pageId=" + encodeURIComponent("" + pageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWidgetByPageId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWidgetByPageId(<any>response_);
                } catch (e) {
                    return <Observable<WidgetMapDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WidgetMapDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWidgetByPageId(response: HttpResponseBase): Observable<WidgetMapDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WidgetMapDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WidgetMapDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWidgetItemForEdit(id: number | null | undefined): Observable<WidgetItemDto> {
        let url_ = this.baseUrl + "/api/Widget/GetWidgetItemForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWidgetItemForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWidgetItemForEdit(<any>response_);
                } catch (e) {
                    return <Observable<WidgetItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WidgetItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWidgetItemForEdit(response: HttpResponseBase): Observable<WidgetItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WidgetItemDto.fromJS(resultData200) : new WidgetItemDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WidgetItemDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: WidgetItemDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Widget/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteWidgetItem(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Widget/DeleteWidgetItem?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWidgetItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWidgetItem(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteWidgetItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getWidgetLayout(): Observable<void> {
        let url_ = this.baseUrl + "/api/Widget/GetWidgetLayout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWidgetLayout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWidgetLayout(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetWidgetLayout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWidgetLayoutByWidgetMapId(id: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Widget/GetWidgetLayoutByWidgetMapId?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWidgetLayoutByWidgetMapId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWidgetLayoutByWidgetMapId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetWidgetLayoutByWidgetMapId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteWidgetMap(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Widget/DeleteWidgetMap?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWidgetMap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWidgetMap(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteWidgetMap(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEditWidgetMap(input: WidgetMapDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Widget/CreateOrEditWidgetMap";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditWidgetMap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditWidgetMap(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEditWidgetMap(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWidgetMapForEdit(id: number | null | undefined): Observable<WidgetMapDto> {
        let url_ = this.baseUrl + "/api/Widget/GetWidgetMapForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWidgetMapForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWidgetMapForEdit(<any>response_);
                } catch (e) {
                    return <Observable<WidgetMapDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WidgetMapDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWidgetMapForEdit(response: HttpResponseBase): Observable<WidgetMapDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WidgetMapDto.fromJS(resultData200) : new WidgetMapDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WidgetMapDto>(<any>null);
    }

    /**
     * @param values (optional) 
     * @param widgetMapId (optional) 
     * @return Success
     */
    insertWidgetValue(values: WidgetValueConfigDto[] | null | undefined, widgetMapId: number | null | undefined): Observable<FDataVm> {
        let url_ = this.baseUrl + "/api/Widget/InsertWidgetValue?";
        if (widgetMapId !== undefined)
            url_ += "widgetMapId=" + encodeURIComponent("" + widgetMapId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(values);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertWidgetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertWidgetValue(<any>response_);
                } catch (e) {
                    return <Observable<FDataVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FDataVm>><any>_observableThrow(response_);
        }));
    }

    protected processInsertWidgetValue(response: HttpResponseBase): Observable<FDataVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FDataVm.fromJS(resultData200) : new FDataVm();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FDataVm>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteWidgetValue(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Widget/DeleteWidgetValue?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWidgetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWidgetValue(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteWidgetValue(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WorkflowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_WORKFLOW_Search(input: CM_WORKFLOW_ENTITY | null | undefined): Observable<PagedResultDtoOfCM_WORKFLOW_ENTITY> {
        let url_ = this.baseUrl + "/api/Workflow/CM_WORKFLOW_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_WORKFLOW_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_WORKFLOW_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_WORKFLOW_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_WORKFLOW_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_WORKFLOW_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_WORKFLOW_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_WORKFLOW_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_WORKFLOW_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_WORKFLOW_ENTITY>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_WORKFLOW_ToExcel(input: CM_WORKFLOW_ENTITY | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Workflow/CM_WORKFLOW_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_WORKFLOW_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_WORKFLOW_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_WORKFLOW_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_WORKFLOW_Ins(input: CM_WORKFLOW_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Workflow/CM_WORKFLOW_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_WORKFLOW_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_WORKFLOW_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_WORKFLOW_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_WORKFLOW_Upd(input: CM_WORKFLOW_ENTITY | null | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Workflow/CM_WORKFLOW_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_WORKFLOW_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_WORKFLOW_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_WORKFLOW_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_WORKFLOW_ById(id: string | null | undefined): Observable<CM_WORKFLOW_ENTITY> {
        let url_ = this.baseUrl + "/api/Workflow/CM_WORKFLOW_ById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_WORKFLOW_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_WORKFLOW_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_WORKFLOW_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_WORKFLOW_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_WORKFLOW_ById(response: HttpResponseBase): Observable<CM_WORKFLOW_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_WORKFLOW_ENTITY.fromJS(resultData200) : new CM_WORKFLOW_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_WORKFLOW_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_WORKFLOW_Del(id: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Workflow/CM_WORKFLOW_Del?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_WORKFLOW_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_WORKFLOW_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_WORKFLOW_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_WORKFLOW_App(id: string | null | undefined, currentUserName: string | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Workflow/CM_WORKFLOW_App?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_WORKFLOW_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_WORKFLOW_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_WORKFLOW_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cM_WORKFLOW_TRANSACTION_Reject(input: CM_WORKFLOW_REJECT_MODEL | null | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Workflow/CM_WORKFLOW_TRANSACTION_Reject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_WORKFLOW_TRANSACTION_Reject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_WORKFLOW_TRANSACTION_Reject(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_WORKFLOW_TRANSACTION_Reject(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class WorkflowRejectDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param transactionId (optional) 
     * @return Success
     */
    cM_WORKFLOW_List(transactionId: string | null | undefined): Observable<CM_WORKFLOW_REJECT_DETAIL_ENTITY[]> {
        let url_ = this.baseUrl + "/api/WorkflowRejectDetail/CM_WORKFLOW_List?";
        if (transactionId !== undefined)
            url_ += "transactionId=" + encodeURIComponent("" + transactionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_WORKFLOW_List(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_WORKFLOW_List(<any>response_);
                } catch (e) {
                    return <Observable<CM_WORKFLOW_REJECT_DETAIL_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_WORKFLOW_REJECT_DETAIL_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_WORKFLOW_List(response: HttpResponseBase): Observable<CM_WORKFLOW_REJECT_DETAIL_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_WORKFLOW_REJECT_DETAIL_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_WORKFLOW_REJECT_DETAIL_ENTITY[]>(<any>null);
    }
}

@Injectable()
export class WorkTimeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param creatorUserId (optional) 
     * @param tenCty (optional) 
     * @param hoVaTen (optional) 
     * @param image (optional) 
     * @param email (optional) 
     * @param documentType (optional) 
     * @param timeFrom (optional) 
     * @param timeTo (optional) 
     * @param status (optional) 
     * @param totalMinutes (optional) 
     * @param reasons (optional) 
     * @param notes (optional) 
     * @param attachment (optional) 
     * @param approverId (optional) 
     * @param nextApproverId (optional) 
     * @param approveTime (optional) 
     * @param truongNhomId (optional) 
     * @param truongPhongId (optional) 
     * @param giamDocKhoiId (optional) 
     * @param tcnsId (optional) 
     * @param giamDocDieuHanhId (optional) 
     * @param loaiNghiPhep (optional) 
     * @param nghiCoLuong (optional) 
     * @param id (optional) 
     * @return Success
     */
    createOrEditForMobile(creatorUserId: number | null | undefined, tenCty: string | null | undefined, hoVaTen: string | null | undefined, image: string | null | undefined, email: string | null | undefined, documentType: string | null | undefined, timeFrom: string | null | undefined, timeTo: string | null | undefined, status: number | null | undefined, totalMinutes: number | null | undefined, reasons: string | null | undefined, notes: string | null | undefined, attachment: FileParameter | null | undefined, approverId: number | null | undefined, nextApproverId: number | null | undefined, approveTime: string | null | undefined, truongNhomId: number | null | undefined, truongPhongId: number | null | undefined, giamDocKhoiId: number | null | undefined, tcnsId: number | null | undefined, giamDocDieuHanhId: number | null | undefined, loaiNghiPhep: string | null | undefined, nghiCoLuong: boolean | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/WorkTime/CreateOrEditForMobile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (creatorUserId !== null && creatorUserId !== undefined)
            content_.append("CreatorUserId", creatorUserId.toString());
        if (tenCty !== null && tenCty !== undefined)
            content_.append("TenCty", tenCty.toString());
        if (hoVaTen !== null && hoVaTen !== undefined)
            content_.append("HoVaTen", hoVaTen.toString());
        if (image !== null && image !== undefined)
            content_.append("Image", image.toString());
        if (email !== null && email !== undefined)
            content_.append("Email", email.toString());
        if (documentType !== null && documentType !== undefined)
            content_.append("DocumentType", documentType.toString());
        if (timeFrom !== null && timeFrom !== undefined)
            content_.append("TimeFrom", timeFrom.toString());
        if (timeTo !== null && timeTo !== undefined)
            content_.append("TimeTo", timeTo.toString());
        if (status !== null && status !== undefined)
            content_.append("Status", status.toString());
        if (totalMinutes !== null && totalMinutes !== undefined)
            content_.append("TotalMinutes", totalMinutes.toString());
        if (reasons !== null && reasons !== undefined)
            content_.append("Reasons", reasons.toString());
        if (notes !== null && notes !== undefined)
            content_.append("Notes", notes.toString());
        if (attachment !== null && attachment !== undefined)
            content_.append("Attachment", attachment.data, attachment.fileName ? attachment.fileName : "Attachment");
        if (approverId !== null && approverId !== undefined)
            content_.append("ApproverId", approverId.toString());
        if (nextApproverId !== null && nextApproverId !== undefined)
            content_.append("NextApproverId", nextApproverId.toString());
        if (approveTime !== null && approveTime !== undefined)
            content_.append("ApproveTime", approveTime.toString());
        if (truongNhomId !== null && truongNhomId !== undefined)
            content_.append("TruongNhomId", truongNhomId.toString());
        if (truongPhongId !== null && truongPhongId !== undefined)
            content_.append("TruongPhongId", truongPhongId.toString());
        if (giamDocKhoiId !== null && giamDocKhoiId !== undefined)
            content_.append("GiamDocKhoiId", giamDocKhoiId.toString());
        if (tcnsId !== null && tcnsId !== undefined)
            content_.append("TcnsId", tcnsId.toString());
        if (giamDocDieuHanhId !== null && giamDocDieuHanhId !== undefined)
            content_.append("GiamDocDieuHanhId", giamDocDieuHanhId.toString());
        if (loaiNghiPhep !== null && loaiNghiPhep !== undefined)
            content_.append("LoaiNghiPhep", loaiNghiPhep.toString());
        if (nghiCoLuong !== null && nghiCoLuong !== undefined)
            content_.append("NghiCoLuong", nghiCoLuong.toString());
        if (id !== null && id !== undefined)
            content_.append("Id", id.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditForMobile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditForMobile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEditForMobile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param lstInput (optional) 
     * @return Success
     */
    editAllForMobile(lstInput: HrWorkTimeRequest_ENTITY[] | null | undefined): Observable<SendAnnouncement_ENTITY> {
        let url_ = this.baseUrl + "/api/WorkTime/EditAllForMobile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(lstInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditAllForMobile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditAllForMobile(<any>response_);
                } catch (e) {
                    return <Observable<SendAnnouncement_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<SendAnnouncement_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processEditAllForMobile(response: HttpResponseBase): Observable<SendAnnouncement_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SendAnnouncement_ENTITY.fromJS(resultData200) : new SendAnnouncement_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SendAnnouncement_ENTITY>(<any>null);
    }

    /**
     * @param branchId (optional) 
     * @return Success
     */
    getQuyTrinhDuyet(branchId: number | null | undefined): Observable<LstRegisterInput_ENTITY> {
        let url_ = this.baseUrl + "/api/WorkTime/GetQuyTrinhDuyet?";
        if (branchId !== undefined)
            url_ += "branchId=" + encodeURIComponent("" + branchId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuyTrinhDuyet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuyTrinhDuyet(<any>response_);
                } catch (e) {
                    return <Observable<LstRegisterInput_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<LstRegisterInput_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuyTrinhDuyet(response: HttpResponseBase): Observable<LstRegisterInput_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LstRegisterInput_ENTITY.fromJS(resultData200) : new LstRegisterInput_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LstRegisterInput_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkTimeDetail(id: number | null | undefined): Observable<HrWorkTime> {
        let url_ = this.baseUrl + "/api/WorkTime/GetWorkTimeDetail?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkTimeDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkTimeDetail(<any>response_);
                } catch (e) {
                    return <Observable<HrWorkTime>><any>_observableThrow(e);
                }
            } else
                return <Observable<HrWorkTime>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkTimeDetail(response: HttpResponseBase): Observable<HrWorkTime> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HrWorkTime.fromJS(resultData200) : new HrWorkTime();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HrWorkTime>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStatusWorkTime(id: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/WorkTime/GetStatusWorkTime?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatusWorkTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatusWorkTime(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatusWorkTime(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getWorkTimeUnCheck(userId: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Observable<HrWorkTime_ENTITY[]> {
        let url_ = this.baseUrl + "/api/WorkTime/GetWorkTimeUnCheck?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkTimeUnCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkTimeUnCheck(<any>response_);
                } catch (e) {
                    return <Observable<HrWorkTime_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HrWorkTime_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkTimeUnCheck(response: HttpResponseBase): Observable<HrWorkTime_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HrWorkTime_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HrWorkTime_ENTITY[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getListMyWorktime(userId: string | null | undefined, page: number | null | undefined, pageSize: number | null | undefined): Observable<HrWorkTime_ENTITY[]> {
        let url_ = this.baseUrl + "/api/WorkTime/GetListMyWorktime?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListMyWorktime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListMyWorktime(<any>response_);
                } catch (e) {
                    return <Observable<HrWorkTime_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HrWorkTime_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListMyWorktime(response: HttpResponseBase): Observable<HrWorkTime_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HrWorkTime_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HrWorkTime_ENTITY[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteWorkTime(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/WorkTime/DeleteWorkTime?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWorkTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWorkTime(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteWorkTime(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param creatorUserId (optional) 
     * @param tenCty (optional) 
     * @param hoVaTen (optional) 
     * @param image (optional) 
     * @param email (optional) 
     * @param documentType (optional) 
     * @param timeFrom (optional) 
     * @param timeTo (optional) 
     * @param status (optional) 
     * @param totalMinutes (optional) 
     * @param reasons (optional) 
     * @param notes (optional) 
     * @param attachment (optional) 
     * @param approverId (optional) 
     * @param nextApproverId (optional) 
     * @param approveTime (optional) 
     * @param truongNhomId (optional) 
     * @param truongPhongId (optional) 
     * @param giamDocKhoiId (optional) 
     * @param tcnsId (optional) 
     * @param giamDocDieuHanhId (optional) 
     * @param loaiNghiPhep (optional) 
     * @param nghiCoLuong (optional) 
     * @param id (optional) 
     * @return Success
     */
    editLetterForMobile(creatorUserId: number | null | undefined, tenCty: string | null | undefined, hoVaTen: string | null | undefined, image: string | null | undefined, email: string | null | undefined, documentType: string | null | undefined, timeFrom: string | null | undefined, timeTo: string | null | undefined, status: number | null | undefined, totalMinutes: number | null | undefined, reasons: string | null | undefined, notes: string | null | undefined, attachment: FileParameter | null | undefined, approverId: number | null | undefined, nextApproverId: number | null | undefined, approveTime: string | null | undefined, truongNhomId: number | null | undefined, truongPhongId: number | null | undefined, giamDocKhoiId: number | null | undefined, tcnsId: number | null | undefined, giamDocDieuHanhId: number | null | undefined, loaiNghiPhep: string | null | undefined, nghiCoLuong: boolean | null | undefined, id: number | null | undefined): Observable<SendAnnouncement_ENTITY> {
        let url_ = this.baseUrl + "/api/WorkTime/EditLetterForMobile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (creatorUserId !== null && creatorUserId !== undefined)
            content_.append("CreatorUserId", creatorUserId.toString());
        if (tenCty !== null && tenCty !== undefined)
            content_.append("TenCty", tenCty.toString());
        if (hoVaTen !== null && hoVaTen !== undefined)
            content_.append("HoVaTen", hoVaTen.toString());
        if (image !== null && image !== undefined)
            content_.append("Image", image.toString());
        if (email !== null && email !== undefined)
            content_.append("Email", email.toString());
        if (documentType !== null && documentType !== undefined)
            content_.append("DocumentType", documentType.toString());
        if (timeFrom !== null && timeFrom !== undefined)
            content_.append("TimeFrom", timeFrom.toString());
        if (timeTo !== null && timeTo !== undefined)
            content_.append("TimeTo", timeTo.toString());
        if (status !== null && status !== undefined)
            content_.append("Status", status.toString());
        if (totalMinutes !== null && totalMinutes !== undefined)
            content_.append("TotalMinutes", totalMinutes.toString());
        if (reasons !== null && reasons !== undefined)
            content_.append("Reasons", reasons.toString());
        if (notes !== null && notes !== undefined)
            content_.append("Notes", notes.toString());
        if (attachment !== null && attachment !== undefined)
            content_.append("Attachment", attachment.data, attachment.fileName ? attachment.fileName : "Attachment");
        if (approverId !== null && approverId !== undefined)
            content_.append("ApproverId", approverId.toString());
        if (nextApproverId !== null && nextApproverId !== undefined)
            content_.append("NextApproverId", nextApproverId.toString());
        if (approveTime !== null && approveTime !== undefined)
            content_.append("ApproveTime", approveTime.toString());
        if (truongNhomId !== null && truongNhomId !== undefined)
            content_.append("TruongNhomId", truongNhomId.toString());
        if (truongPhongId !== null && truongPhongId !== undefined)
            content_.append("TruongPhongId", truongPhongId.toString());
        if (giamDocKhoiId !== null && giamDocKhoiId !== undefined)
            content_.append("GiamDocKhoiId", giamDocKhoiId.toString());
        if (tcnsId !== null && tcnsId !== undefined)
            content_.append("TcnsId", tcnsId.toString());
        if (giamDocDieuHanhId !== null && giamDocDieuHanhId !== undefined)
            content_.append("GiamDocDieuHanhId", giamDocDieuHanhId.toString());
        if (loaiNghiPhep !== null && loaiNghiPhep !== undefined)
            content_.append("LoaiNghiPhep", loaiNghiPhep.toString());
        if (nghiCoLuong !== null && nghiCoLuong !== undefined)
            content_.append("NghiCoLuong", nghiCoLuong.toString());
        if (id !== null && id !== undefined)
            content_.append("Id", id.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditLetterForMobile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditLetterForMobile(<any>response_);
                } catch (e) {
                    return <Observable<SendAnnouncement_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<SendAnnouncement_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processEditLetterForMobile(response: HttpResponseBase): Observable<SendAnnouncement_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SendAnnouncement_ENTITY.fromJS(resultData200) : new SendAnnouncement_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SendAnnouncement_ENTITY>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState | undefined;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
            this.serverRootAddress = data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState | undefined;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export enum TenantAvailabilityState {
    Available = 1, 
    InActive = 2, 
    NotFound = 3, 
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data; 
    }

    clone(): ResolveTenantIdInput {
        const json = this.toJSON();
        let result = new ResolveTenantIdInput();
        result.init(json);
        return result;
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean | undefined;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean | undefined;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress: string;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): SendPasswordResetCodeInput {
        const json = this.toJSON();
        let result = new SendPasswordResetCodeInput();
        result.init(json);
        return result;
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId: number | undefined;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.password = data["password"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["c"] = this.c;
        return data; 
    }

    clone(): ResetPasswordInput {
        const json = this.toJSON();
        let result = new ResetPasswordInput();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordInput {
    userId: number | undefined;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin: boolean | undefined;
    userName: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }

    clone(): ResetPasswordOutput {
        const json = this.toJSON();
        let result = new ResetPasswordOutput();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean | undefined;
    userName: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): SendEmailActivationLinkInput {
        const json = this.toJSON();
        let result = new SendEmailActivationLinkInput();
        result.init(json);
        return result;
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId: number | undefined;
    confirmationCode: string | undefined;
    c: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.confirmationCode = data["confirmationCode"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data; 
    }

    clone(): ActivateEmailInput {
        const json = this.toJSON();
        let result = new ActivateEmailInput();
        result.init(json);
        return result;
    }
}

export interface IActivateEmailInput {
    userId: number | undefined;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId: number | undefined;
    userId: number | undefined;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): ImpersonateInput {
        const json = this.toJSON();
        let result = new ImpersonateInput();
        result.init(json);
        return result;
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
    tenancyId: number | undefined;
    userId: number | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.impersonationToken = data["impersonationToken"];
            this.tenancyName = data["tenancyName"];
            this.tenancyId = data["tenancyId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        data["tenancyId"] = this.tenancyId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): ImpersonateOutput {
        const json = this.toJSON();
        let result = new ImpersonateOutput();
        result.init(json);
        return result;
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
    tenancyId: number | undefined;
    userId: number | undefined;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number | undefined;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetTenantId = data["targetTenantId"];
            this.targetUserId = data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }

    clone(): SwitchToLinkedAccountInput {
        const json = this.toJSON();
        let result = new SwitchToLinkedAccountInput();
        result.init(json);
        return result;
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number | undefined;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.switchAccountToken = data["switchAccountToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): SwitchToLinkedAccountOutput {
        const json = this.toJSON();
        let result = new SwitchToLinkedAccountOutput();
        result.init(json);
        return result;
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class T_ADJUST_ASS_ENTITY implements IT_ADJUST_ASS_ENTITY {
    adjusT_ID: string | undefined;
    adjusT_CODE: string | undefined;
    asS_ID: string | undefined;
    asS_CODE: string | undefined;
    iS_ASS: string | undefined;
    neW_PRICE: number | undefined;
    reason: string | undefined;
    requesT_NAME: string | undefined;
    requesT_DT: moment.Moment | undefined;
    brancH_ID: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    notes: string | undefined;
    level: string | undefined;
    autH_STATUS_NAME: string | undefined;
    asseT_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IT_ADJUST_ASS_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adjusT_ID = data["adjusT_ID"];
            this.adjusT_CODE = data["adjusT_CODE"];
            this.asS_ID = data["asS_ID"];
            this.asS_CODE = data["asS_CODE"];
            this.iS_ASS = data["iS_ASS"];
            this.neW_PRICE = data["neW_PRICE"];
            this.reason = data["reason"];
            this.requesT_NAME = data["requesT_NAME"];
            this.requesT_DT = data["requesT_DT"] ? moment(data["requesT_DT"].toString()) : <any>undefined;
            this.brancH_ID = data["brancH_ID"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.autH_STATUS = data["autH_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.level = data["level"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.asseT_NAME = data["asseT_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): T_ADJUST_ASS_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new T_ADJUST_ASS_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adjusT_ID"] = this.adjusT_ID;
        data["adjusT_CODE"] = this.adjusT_CODE;
        data["asS_ID"] = this.asS_ID;
        data["asS_CODE"] = this.asS_CODE;
        data["iS_ASS"] = this.iS_ASS;
        data["neW_PRICE"] = this.neW_PRICE;
        data["reason"] = this.reason;
        data["requesT_NAME"] = this.requesT_NAME;
        data["requesT_DT"] = this.requesT_DT ? this.requesT_DT.toISOString() : <any>undefined;
        data["brancH_ID"] = this.brancH_ID;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["autH_STATUS"] = this.autH_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["level"] = this.level;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["asseT_NAME"] = this.asseT_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): T_ADJUST_ASS_ENTITY {
        const json = this.toJSON();
        let result = new T_ADJUST_ASS_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IT_ADJUST_ASS_ENTITY {
    adjusT_ID: string | undefined;
    adjusT_CODE: string | undefined;
    asS_ID: string | undefined;
    asS_CODE: string | undefined;
    iS_ASS: string | undefined;
    neW_PRICE: number | undefined;
    reason: string | undefined;
    requesT_NAME: string | undefined;
    requesT_DT: moment.Moment | undefined;
    brancH_ID: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    notes: string | undefined;
    level: string | undefined;
    autH_STATUS_NAME: string | undefined;
    asseT_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfT_ADJUST_ASS_ENTITY implements IPagedResultDtoOfT_ADJUST_ASS_ENTITY {
    totalCount: number | undefined;
    items: T_ADJUST_ASS_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfT_ADJUST_ASS_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(T_ADJUST_ASS_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfT_ADJUST_ASS_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfT_ADJUST_ASS_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfT_ADJUST_ASS_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfT_ADJUST_ASS_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfT_ADJUST_ASS_ENTITY {
    totalCount: number | undefined;
    items: T_ADJUST_ASS_ENTITY[] | undefined;
}

export class CM_ALLCODE_ENTITY implements ICM_ALLCODE_ENTITY {
    id: number | undefined;
    cdname: string | undefined;
    cdval: string | undefined;
    content: string | undefined;
    cdtype: string | undefined;
    lstodr: number | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_ALLCODE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cdname = data["cdname"];
            this.cdval = data["cdval"];
            this.content = data["content"];
            this.cdtype = data["cdtype"];
            this.lstodr = data["lstodr"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_ALLCODE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_ALLCODE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cdname"] = this.cdname;
        data["cdval"] = this.cdval;
        data["content"] = this.content;
        data["cdtype"] = this.cdtype;
        data["lstodr"] = this.lstodr;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_ALLCODE_ENTITY {
        const json = this.toJSON();
        let result = new CM_ALLCODE_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_ALLCODE_ENTITY {
    id: number | undefined;
    cdname: string | undefined;
    cdval: string | undefined;
    content: string | undefined;
    cdtype: string | undefined;
    lstodr: number | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_ALLCODE_ENTITY implements IPagedResultDtoOfCM_ALLCODE_ENTITY {
    totalCount: number | undefined;
    items: CM_ALLCODE_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_ALLCODE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_ALLCODE_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_ALLCODE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_ALLCODE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_ALLCODE_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_ALLCODE_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_ALLCODE_ENTITY {
    totalCount: number | undefined;
    items: CM_ALLCODE_ENTITY[] | undefined;
}

export class InsertResult implements IInsertResult {
    id: string | undefined;
    ids: string | undefined;
    result: string | undefined;
    errorDesc: string | undefined;
    attr1: string | undefined;
    attr2: string | undefined;
    attr3: string | undefined;
    attr4: string | undefined;
    attr5: string | undefined;

    constructor(data?: IInsertResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ids = data["ids"];
            this.result = data["result"];
            this.errorDesc = data["errorDesc"];
            this.attr1 = data["attr1"];
            this.attr2 = data["attr2"];
            this.attr3 = data["attr3"];
            this.attr4 = data["attr4"];
            this.attr5 = data["attr5"];
        }
    }

    static fromJS(data: any): InsertResult {
        data = typeof data === 'object' ? data : {};
        let result = new InsertResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ids"] = this.ids;
        data["result"] = this.result;
        data["errorDesc"] = this.errorDesc;
        data["attr1"] = this.attr1;
        data["attr2"] = this.attr2;
        data["attr3"] = this.attr3;
        data["attr4"] = this.attr4;
        data["attr5"] = this.attr5;
        return data; 
    }

    clone(): InsertResult {
        const json = this.toJSON();
        let result = new InsertResult();
        result.init(json);
        return result;
    }
}

export interface IInsertResult {
    id: string | undefined;
    ids: string | undefined;
    result: string | undefined;
    errorDesc: string | undefined;
    attr1: string | undefined;
    attr2: string | undefined;
    attr3: string | undefined;
    attr4: string | undefined;
    attr5: string | undefined;
}

export class CommonResult implements ICommonResult {
    result: string | undefined;
    errorDesc: string | undefined;
    attr1: string | undefined;
    attr2: string | undefined;
    attr3: string | undefined;
    attr4: string | undefined;
    attr5: string | undefined;

    constructor(data?: ICommonResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.result = data["result"];
            this.errorDesc = data["errorDesc"];
            this.attr1 = data["attr1"];
            this.attr2 = data["attr2"];
            this.attr3 = data["attr3"];
            this.attr4 = data["attr4"];
            this.attr5 = data["attr5"];
        }
    }

    static fromJS(data: any): CommonResult {
        data = typeof data === 'object' ? data : {};
        let result = new CommonResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["errorDesc"] = this.errorDesc;
        data["attr1"] = this.attr1;
        data["attr2"] = this.attr2;
        data["attr3"] = this.attr3;
        data["attr4"] = this.attr4;
        data["attr5"] = this.attr5;
        return data; 
    }

    clone(): CommonResult {
        const json = this.toJSON();
        let result = new CommonResult();
        result.init(json);
        return result;
    }
}

export interface ICommonResult {
    result: string | undefined;
    errorDesc: string | undefined;
    attr1: string | undefined;
    attr2: string | undefined;
    attr3: string | undefined;
    attr4: string | undefined;
    attr5: string | undefined;
}

export class AllCodeDto implements IAllCodeDto {
    cdname: string | undefined;
    cdval: string | undefined;
    content: string | undefined;
    cdtype: string | undefined;

    constructor(data?: IAllCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cdname = data["cdname"];
            this.cdval = data["cdval"];
            this.content = data["content"];
            this.cdtype = data["cdtype"];
        }
    }

    static fromJS(data: any): AllCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AllCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cdname"] = this.cdname;
        data["cdval"] = this.cdval;
        data["content"] = this.content;
        data["cdtype"] = this.cdtype;
        return data; 
    }

    clone(): AllCodeDto {
        const json = this.toJSON();
        let result = new AllCodeDto();
        result.init(json);
        return result;
    }
}

export interface IAllCodeDto {
    cdname: string | undefined;
    cdval: string | undefined;
    content: string | undefined;
    cdtype: string | undefined;
}

export class SendAnnouncement_ENTITY implements ISendAnnouncement_ENTITY {
    announcementsEntity: HR_Announcement_ENTITY[] | undefined;
    announcementUsersEntity: HR_AnnouncementUser_ENTITY[] | undefined;

    constructor(data?: ISendAnnouncement_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["announcementsEntity"] && data["announcementsEntity"].constructor === Array) {
                this.announcementsEntity = [];
                for (let item of data["announcementsEntity"])
                    this.announcementsEntity.push(HR_Announcement_ENTITY.fromJS(item));
            }
            if (data["announcementUsersEntity"] && data["announcementUsersEntity"].constructor === Array) {
                this.announcementUsersEntity = [];
                for (let item of data["announcementUsersEntity"])
                    this.announcementUsersEntity.push(HR_AnnouncementUser_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SendAnnouncement_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new SendAnnouncement_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.announcementsEntity && this.announcementsEntity.constructor === Array) {
            data["announcementsEntity"] = [];
            for (let item of this.announcementsEntity)
                data["announcementsEntity"].push(item.toJSON());
        }
        if (this.announcementUsersEntity && this.announcementUsersEntity.constructor === Array) {
            data["announcementUsersEntity"] = [];
            for (let item of this.announcementUsersEntity)
                data["announcementUsersEntity"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SendAnnouncement_ENTITY {
        const json = this.toJSON();
        let result = new SendAnnouncement_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ISendAnnouncement_ENTITY {
    announcementsEntity: HR_Announcement_ENTITY[] | undefined;
    announcementUsersEntity: HR_AnnouncementUser_ENTITY[] | undefined;
}

export class HR_Announcement_ENTITY implements IHR_Announcement_ENTITY {
    id: string | undefined;
    title: string | undefined;
    content: string | undefined;
    image: string | undefined;
    userId: number | undefined;
    dateCreated: moment.Moment | undefined;
    dateModified: moment.Moment | undefined;
    status: boolean | undefined;
    entityType: string | undefined;
    entityId: string | undefined;
    statusType: boolean | undefined;
    hasRead: boolean | undefined;
    userReadId: number | undefined;

    constructor(data?: IHR_Announcement_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.title = data["title"];
            this.content = data["content"];
            this.image = data["image"];
            this.userId = data["userId"];
            this.dateCreated = data["dateCreated"] ? moment(data["dateCreated"].toString()) : <any>undefined;
            this.dateModified = data["dateModified"] ? moment(data["dateModified"].toString()) : <any>undefined;
            this.status = data["status"];
            this.entityType = data["entityType"];
            this.entityId = data["entityId"];
            this.statusType = data["statusType"];
            this.hasRead = data["hasRead"];
            this.userReadId = data["userReadId"];
        }
    }

    static fromJS(data: any): HR_Announcement_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HR_Announcement_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["content"] = this.content;
        data["image"] = this.image;
        data["userId"] = this.userId;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["entityType"] = this.entityType;
        data["entityId"] = this.entityId;
        data["statusType"] = this.statusType;
        data["hasRead"] = this.hasRead;
        data["userReadId"] = this.userReadId;
        return data; 
    }

    clone(): HR_Announcement_ENTITY {
        const json = this.toJSON();
        let result = new HR_Announcement_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHR_Announcement_ENTITY {
    id: string | undefined;
    title: string | undefined;
    content: string | undefined;
    image: string | undefined;
    userId: number | undefined;
    dateCreated: moment.Moment | undefined;
    dateModified: moment.Moment | undefined;
    status: boolean | undefined;
    entityType: string | undefined;
    entityId: string | undefined;
    statusType: boolean | undefined;
    hasRead: boolean | undefined;
    userReadId: number | undefined;
}

export class HR_AnnouncementUser_ENTITY implements IHR_AnnouncementUser_ENTITY {
    id: number | undefined;
    userId: number | undefined;
    hasRead: boolean | undefined;
    statusType: boolean | undefined;
    announcementId: string | undefined;
    isDeleted: boolean | undefined;
    announcement: HR_Announcement_ENTITY | undefined;

    constructor(data?: IHR_AnnouncementUser_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userId = data["userId"];
            this.hasRead = data["hasRead"];
            this.statusType = data["statusType"];
            this.announcementId = data["announcementId"];
            this.isDeleted = data["isDeleted"];
            this.announcement = data["announcement"] ? HR_Announcement_ENTITY.fromJS(data["announcement"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HR_AnnouncementUser_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HR_AnnouncementUser_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["hasRead"] = this.hasRead;
        data["statusType"] = this.statusType;
        data["announcementId"] = this.announcementId;
        data["isDeleted"] = this.isDeleted;
        data["announcement"] = this.announcement ? this.announcement.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HR_AnnouncementUser_ENTITY {
        const json = this.toJSON();
        let result = new HR_AnnouncementUser_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHR_AnnouncementUser_ENTITY {
    id: number | undefined;
    userId: number | undefined;
    hasRead: boolean | undefined;
    statusType: boolean | undefined;
    announcementId: string | undefined;
    isDeleted: boolean | undefined;
    announcement: HR_Announcement_ENTITY | undefined;
}

export class AppMenuDto implements IAppMenuDto {
    menuId: string | undefined;
    name: string | undefined;
    permissionName: string | undefined;
    icon: string | undefined;
    route: string | undefined;
    display: string | undefined;
    items: AppMenuDto[] | undefined;
    parentId: string | undefined;
    parent: AppMenuDto | undefined;
    external: boolean | undefined;
    requiresAuthentication: boolean | undefined;
    featureDependency: string | undefined;
    parameters: string[] | undefined;
    id: string | undefined;

    constructor(data?: IAppMenuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.menuId = data["menuId"];
            this.name = data["name"];
            this.permissionName = data["permissionName"];
            this.icon = data["icon"];
            this.route = data["route"];
            this.display = data["display"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AppMenuDto.fromJS(item));
            }
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? AppMenuDto.fromJS(data["parent"]) : <any>undefined;
            this.external = data["external"];
            this.requiresAuthentication = data["requiresAuthentication"];
            this.featureDependency = data["featureDependency"];
            if (data["parameters"] && data["parameters"].constructor === Array) {
                this.parameters = [];
                for (let item of data["parameters"])
                    this.parameters.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AppMenuDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppMenuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuId"] = this.menuId;
        data["name"] = this.name;
        data["permissionName"] = this.permissionName;
        data["icon"] = this.icon;
        data["route"] = this.route;
        data["display"] = this.display;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["external"] = this.external;
        data["requiresAuthentication"] = this.requiresAuthentication;
        data["featureDependency"] = this.featureDependency;
        if (this.parameters && this.parameters.constructor === Array) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): AppMenuDto {
        const json = this.toJSON();
        let result = new AppMenuDto();
        result.init(json);
        return result;
    }
}

export interface IAppMenuDto {
    menuId: string | undefined;
    name: string | undefined;
    permissionName: string | undefined;
    icon: string | undefined;
    route: string | undefined;
    display: string | undefined;
    items: AppMenuDto[] | undefined;
    parentId: string | undefined;
    parent: AppMenuDto | undefined;
    external: boolean | undefined;
    requiresAuthentication: boolean | undefined;
    featureDependency: string | undefined;
    parameters: string[] | undefined;
    id: string | undefined;
}

export class TL_MENU_ENTITY implements ITL_MENU_ENTITY {
    menU_ID: number | undefined;
    menU_NAME: string | undefined;
    menU_NAME_EL: string | undefined;
    menU_PARENT: string | undefined;
    menU_LINK: string | undefined;
    menU_ORDER: number | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    checkeR_ID: string | undefined;
    datE_APPROVE: moment.Moment | undefined;
    isapprove: string | undefined;
    isapprovE_FUNC: string | undefined;
    menU_PERMISSION: string | undefined;
    menU_ICON: string | undefined;
    recorD_STATUS: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    creatE_DT: moment.Moment | undefined;
    approvE_DT: moment.Moment | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ITL_MENU_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.menU_ID = data["menU_ID"];
            this.menU_NAME = data["menU_NAME"];
            this.menU_NAME_EL = data["menU_NAME_EL"];
            this.menU_PARENT = data["menU_PARENT"];
            this.menU_LINK = data["menU_LINK"];
            this.menU_ORDER = data["menU_ORDER"];
            this.autH_STATUS = data["autH_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.checkeR_ID = data["checkeR_ID"];
            this.datE_APPROVE = data["datE_APPROVE"] ? moment(data["datE_APPROVE"].toString()) : <any>undefined;
            this.isapprove = data["isapprove"];
            this.isapprovE_FUNC = data["isapprovE_FUNC"];
            this.menU_PERMISSION = data["menU_PERMISSION"];
            this.menU_ICON = data["menU_ICON"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): TL_MENU_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new TL_MENU_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menU_ID"] = this.menU_ID;
        data["menU_NAME"] = this.menU_NAME;
        data["menU_NAME_EL"] = this.menU_NAME_EL;
        data["menU_PARENT"] = this.menU_PARENT;
        data["menU_LINK"] = this.menU_LINK;
        data["menU_ORDER"] = this.menU_ORDER;
        data["autH_STATUS"] = this.autH_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["checkeR_ID"] = this.checkeR_ID;
        data["datE_APPROVE"] = this.datE_APPROVE ? this.datE_APPROVE.toISOString() : <any>undefined;
        data["isapprove"] = this.isapprove;
        data["isapprovE_FUNC"] = this.isapprovE_FUNC;
        data["menU_PERMISSION"] = this.menU_PERMISSION;
        data["menU_ICON"] = this.menU_ICON;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): TL_MENU_ENTITY {
        const json = this.toJSON();
        let result = new TL_MENU_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ITL_MENU_ENTITY {
    menU_ID: number | undefined;
    menU_NAME: string | undefined;
    menU_NAME_EL: string | undefined;
    menU_PARENT: string | undefined;
    menU_LINK: string | undefined;
    menU_ORDER: number | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    checkeR_ID: string | undefined;
    datE_APPROVE: moment.Moment | undefined;
    isapprove: string | undefined;
    isapprovE_FUNC: string | undefined;
    menU_PERMISSION: string | undefined;
    menU_ICON: string | undefined;
    recorD_STATUS: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    creatE_DT: moment.Moment | undefined;
    approvE_DT: moment.Moment | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfTL_MENU_ENTITY implements IPagedResultDtoOfTL_MENU_ENTITY {
    totalCount: number | undefined;
    items: TL_MENU_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfTL_MENU_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TL_MENU_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTL_MENU_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTL_MENU_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTL_MENU_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTL_MENU_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTL_MENU_ENTITY {
    totalCount: number | undefined;
    items: TL_MENU_ENTITY[] | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
    isRootAction: boolean | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
            this.isRootAction = data["isRootAction"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        data["isRootAction"] = this.isRootAction;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
    isRootAction: boolean | undefined;
}

export class ReportInfo implements IReportInfo {
    storeName: string | undefined;
    typeExport: string | undefined;
    pathName: string | undefined;
    fileName: string | undefined;
    processMerge: boolean | undefined;
    parameters: ReportParameter[] | undefined;
    values: ReportParameter[] | undefined;

    constructor(data?: IReportInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.storeName = data["storeName"];
            this.typeExport = data["typeExport"];
            this.pathName = data["pathName"];
            this.fileName = data["fileName"];
            this.processMerge = data["processMerge"];
            if (data["parameters"] && data["parameters"].constructor === Array) {
                this.parameters = [];
                for (let item of data["parameters"])
                    this.parameters.push(ReportParameter.fromJS(item));
            }
            if (data["values"] && data["values"].constructor === Array) {
                this.values = [];
                for (let item of data["values"])
                    this.values.push(ReportParameter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ReportInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeName"] = this.storeName;
        data["typeExport"] = this.typeExport;
        data["pathName"] = this.pathName;
        data["fileName"] = this.fileName;
        data["processMerge"] = this.processMerge;
        if (this.parameters && this.parameters.constructor === Array) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        if (this.values && this.values.constructor === Array) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ReportInfo {
        const json = this.toJSON();
        let result = new ReportInfo();
        result.init(json);
        return result;
    }
}

export interface IReportInfo {
    storeName: string | undefined;
    typeExport: string | undefined;
    pathName: string | undefined;
    fileName: string | undefined;
    processMerge: boolean | undefined;
    parameters: ReportParameter[] | undefined;
    values: ReportParameter[] | undefined;
}

export class ReportParameter implements IReportParameter {
    name: string | undefined;
    value: any | undefined;

    constructor(data?: IReportParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): ReportParameter {
        data = typeof data === 'object' ? data : {};
        let result = new ReportParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): ReportParameter {
        const json = this.toJSON();
        let result = new ReportParameter();
        result.init(json);
        return result;
    }
}

export interface IReportParameter {
    name: string | undefined;
    value: any | undefined;
}

export class FileDto implements IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }

    clone(): FileDto {
        const json = this.toJSON();
        let result = new FileDto();
        result.init(json);
        return result;
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;
}

export class ReportHtmlInfo implements IReportHtmlInfo {
    htmlString: string | undefined;
    typeExport: string | undefined;
    fileName: string | undefined;
    pageInfo: string | undefined;

    constructor(data?: IReportHtmlInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.htmlString = data["htmlString"];
            this.typeExport = data["typeExport"];
            this.fileName = data["fileName"];
            this.pageInfo = data["pageInfo"];
        }
    }

    static fromJS(data: any): ReportHtmlInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ReportHtmlInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["htmlString"] = this.htmlString;
        data["typeExport"] = this.typeExport;
        data["fileName"] = this.fileName;
        data["pageInfo"] = this.pageInfo;
        return data; 
    }

    clone(): ReportHtmlInfo {
        const json = this.toJSON();
        let result = new ReportHtmlInfo();
        result.init(json);
        return result;
    }
}

export interface IReportHtmlInfo {
    htmlString: string | undefined;
    typeExport: string | undefined;
    fileName: string | undefined;
    pageInfo: string | undefined;
}

export class ReportTable implements IReportTable {
    tableName: string | undefined;
    columns: ReportColumn[] | undefined;
    rows: ReportRow[] | undefined;

    constructor(data?: IReportTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tableName = data["tableName"];
            if (data["columns"] && data["columns"].constructor === Array) {
                this.columns = [];
                for (let item of data["columns"])
                    this.columns.push(ReportColumn.fromJS(item));
            }
            if (data["rows"] && data["rows"].constructor === Array) {
                this.rows = [];
                for (let item of data["rows"])
                    this.rows.push(ReportRow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportTable {
        data = typeof data === 'object' ? data : {};
        let result = new ReportTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tableName"] = this.tableName;
        if (this.columns && this.columns.constructor === Array) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (this.rows && this.rows.constructor === Array) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ReportTable {
        const json = this.toJSON();
        let result = new ReportTable();
        result.init(json);
        return result;
    }
}

export interface IReportTable {
    tableName: string | undefined;
    columns: ReportColumn[] | undefined;
    rows: ReportRow[] | undefined;
}

export class ReportColumn implements IReportColumn {
    colName: string | undefined;
    keyName: string | undefined;

    constructor(data?: IReportColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.colName = data["colName"];
            this.keyName = data["keyName"];
        }
    }

    static fromJS(data: any): ReportColumn {
        data = typeof data === 'object' ? data : {};
        let result = new ReportColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["colName"] = this.colName;
        data["keyName"] = this.keyName;
        return data; 
    }

    clone(): ReportColumn {
        const json = this.toJSON();
        let result = new ReportColumn();
        result.init(json);
        return result;
    }
}

export interface IReportColumn {
    colName: string | undefined;
    keyName: string | undefined;
}

export class ReportRow implements IReportRow {
    cells: any[] | undefined;

    constructor(data?: IReportRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["cells"] && data["cells"].constructor === Array) {
                this.cells = [];
                for (let item of data["cells"])
                    this.cells.push(item);
            }
        }
    }

    static fromJS(data: any): ReportRow {
        data = typeof data === 'object' ? data : {};
        let result = new ReportRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.cells && this.cells.constructor === Array) {
            data["cells"] = [];
            for (let item of this.cells)
                data["cells"].push(item);
        }
        return data; 
    }

    clone(): ReportRow {
        const json = this.toJSON();
        let result = new ReportRow();
        result.init(json);
        return result;
    }
}

export interface IReportRow {
    cells: any[] | undefined;
}

export class CM_ATTACH_FILE_ENTITY implements ICM_ATTACH_FILE_ENTITY {
    id: number | undefined;
    attacH_ID: string | undefined;
    type: string | undefined;
    reF_ID: string | undefined;
    filE_NAME_OLD: string | undefined;
    patH_OLD: string | undefined;
    filE_NAME_NEW: string | undefined;
    patH_NEW: string | undefined;
    filE_SIZE: number | undefined;
    filE_TYPE: string | undefined;
    attacH_DT: moment.Moment | undefined;
    emP_ID: string | undefined;
    index: string | undefined;
    notes: string | undefined;
    version: string | undefined;
    action: string | undefined;
    reF_MASTER: string | undefined;
    attachDetail: string | undefined;

    constructor(data?: ICM_ATTACH_FILE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.attacH_ID = data["attacH_ID"];
            this.type = data["type"];
            this.reF_ID = data["reF_ID"];
            this.filE_NAME_OLD = data["filE_NAME_OLD"];
            this.patH_OLD = data["patH_OLD"];
            this.filE_NAME_NEW = data["filE_NAME_NEW"];
            this.patH_NEW = data["patH_NEW"];
            this.filE_SIZE = data["filE_SIZE"];
            this.filE_TYPE = data["filE_TYPE"];
            this.attacH_DT = data["attacH_DT"] ? moment(data["attacH_DT"].toString()) : <any>undefined;
            this.emP_ID = data["emP_ID"];
            this.index = data["index"];
            this.notes = data["notes"];
            this.version = data["version"];
            this.action = data["action"];
            this.reF_MASTER = data["reF_MASTER"];
            this.attachDetail = data["attachDetail"];
        }
    }

    static fromJS(data: any): CM_ATTACH_FILE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_ATTACH_FILE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["attacH_ID"] = this.attacH_ID;
        data["type"] = this.type;
        data["reF_ID"] = this.reF_ID;
        data["filE_NAME_OLD"] = this.filE_NAME_OLD;
        data["patH_OLD"] = this.patH_OLD;
        data["filE_NAME_NEW"] = this.filE_NAME_NEW;
        data["patH_NEW"] = this.patH_NEW;
        data["filE_SIZE"] = this.filE_SIZE;
        data["filE_TYPE"] = this.filE_TYPE;
        data["attacH_DT"] = this.attacH_DT ? this.attacH_DT.toISOString() : <any>undefined;
        data["emP_ID"] = this.emP_ID;
        data["index"] = this.index;
        data["notes"] = this.notes;
        data["version"] = this.version;
        data["action"] = this.action;
        data["reF_MASTER"] = this.reF_MASTER;
        data["attachDetail"] = this.attachDetail;
        return data; 
    }

    clone(): CM_ATTACH_FILE_ENTITY {
        const json = this.toJSON();
        let result = new CM_ATTACH_FILE_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_ATTACH_FILE_ENTITY {
    id: number | undefined;
    attacH_ID: string | undefined;
    type: string | undefined;
    reF_ID: string | undefined;
    filE_NAME_OLD: string | undefined;
    patH_OLD: string | undefined;
    filE_NAME_NEW: string | undefined;
    patH_NEW: string | undefined;
    filE_SIZE: number | undefined;
    filE_TYPE: string | undefined;
    attacH_DT: moment.Moment | undefined;
    emP_ID: string | undefined;
    index: string | undefined;
    notes: string | undefined;
    version: string | undefined;
    action: string | undefined;
    reF_MASTER: string | undefined;
    attachDetail: string | undefined;
}

export class CM_ATTACH_FILE_MODEL implements ICM_ATTACH_FILE_MODEL {
    attacH_ID: string | undefined;
    reF_ID: string | undefined;
    filE_NAME: string | undefined;

    constructor(data?: ICM_ATTACH_FILE_MODEL) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.attacH_ID = data["attacH_ID"];
            this.reF_ID = data["reF_ID"];
            this.filE_NAME = data["filE_NAME"];
        }
    }

    static fromJS(data: any): CM_ATTACH_FILE_MODEL {
        data = typeof data === 'object' ? data : {};
        let result = new CM_ATTACH_FILE_MODEL();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attacH_ID"] = this.attacH_ID;
        data["reF_ID"] = this.reF_ID;
        data["filE_NAME"] = this.filE_NAME;
        return data; 
    }

    clone(): CM_ATTACH_FILE_MODEL {
        const json = this.toJSON();
        let result = new CM_ATTACH_FILE_MODEL();
        result.init(json);
        return result;
    }
}

export interface ICM_ATTACH_FILE_MODEL {
    attacH_ID: string | undefined;
    reF_ID: string | undefined;
    filE_NAME: string | undefined;
}

export class CM_ATTACH_FILE_INPUT implements ICM_ATTACH_FILE_INPUT {
    attachFile: CM_ATTACH_FILE_ENTITY | undefined;
    childs: CM_ATTACH_FILE_ENTITY[] | undefined;
    ids: string | undefined;
    oldFiles: string[] | undefined;
    newFiles: string[] | undefined;

    constructor(data?: ICM_ATTACH_FILE_INPUT) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.attachFile = data["attachFile"] ? CM_ATTACH_FILE_ENTITY.fromJS(data["attachFile"]) : <any>undefined;
            if (data["childs"] && data["childs"].constructor === Array) {
                this.childs = [];
                for (let item of data["childs"])
                    this.childs.push(CM_ATTACH_FILE_ENTITY.fromJS(item));
            }
            this.ids = data["ids"];
            if (data["oldFiles"] && data["oldFiles"].constructor === Array) {
                this.oldFiles = [];
                for (let item of data["oldFiles"])
                    this.oldFiles.push(item);
            }
            if (data["newFiles"] && data["newFiles"].constructor === Array) {
                this.newFiles = [];
                for (let item of data["newFiles"])
                    this.newFiles.push(item);
            }
        }
    }

    static fromJS(data: any): CM_ATTACH_FILE_INPUT {
        data = typeof data === 'object' ? data : {};
        let result = new CM_ATTACH_FILE_INPUT();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attachFile"] = this.attachFile ? this.attachFile.toJSON() : <any>undefined;
        if (this.childs && this.childs.constructor === Array) {
            data["childs"] = [];
            for (let item of this.childs)
                data["childs"].push(item.toJSON());
        }
        data["ids"] = this.ids;
        if (this.oldFiles && this.oldFiles.constructor === Array) {
            data["oldFiles"] = [];
            for (let item of this.oldFiles)
                data["oldFiles"].push(item);
        }
        if (this.newFiles && this.newFiles.constructor === Array) {
            data["newFiles"] = [];
            for (let item of this.newFiles)
                data["newFiles"].push(item);
        }
        return data; 
    }

    clone(): CM_ATTACH_FILE_INPUT {
        const json = this.toJSON();
        let result = new CM_ATTACH_FILE_INPUT();
        result.init(json);
        return result;
    }
}

export interface ICM_ATTACH_FILE_INPUT {
    attachFile: CM_ATTACH_FILE_ENTITY | undefined;
    childs: CM_ATTACH_FILE_ENTITY[] | undefined;
    ids: string | undefined;
    oldFiles: string[] | undefined;
    newFiles: string[] | undefined;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount: number | undefined;
    items: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfAuditLogListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number | undefined;
    items: AuditLogListDto[] | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment | undefined;
    executionDuration: number | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number | undefined;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }

    clone(): AuditLogListDto {
        const json = this.toJSON();
        let result = new AuditLogListDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment | undefined;
    executionDuration: number | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number | undefined;
}

export class NameValueDto implements INameValueDto {
    name: string | undefined;
    value: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): NameValueDto {
        const json = this.toJSON();
        let result = new NameValueDto();
        result.init(json);
        return result;
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount: number | undefined;
    items: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfEntityChangeListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number | undefined;
    items: EntityChangeListDto[] | undefined;
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment | undefined;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType | undefined;
    changeTypeName: string | undefined;
    entityChangeSetId: number | undefined;
    id: number | undefined;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.changeTime = data["changeTime"] ? moment(data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = data["entityTypeFullName"];
            this.changeType = data["changeType"];
            this.changeTypeName = data["changeTypeName"];
            this.entityChangeSetId = data["entityChangeSetId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityChangeListDto {
        const json = this.toJSON();
        let result = new EntityChangeListDto();
        result.init(json);
        return result;
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment | undefined;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType | undefined;
    changeTypeName: string | undefined;
    entityChangeSetId: number | undefined;
    id: number | undefined;
}

export enum EntityChangeType {
    Created = 0, 
    Updated = 1, 
    Deleted = 2, 
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId: number | undefined;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number | undefined;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.entityChangeId = data["entityChangeId"];
            this.newValue = data["newValue"];
            this.originalValue = data["originalValue"];
            this.propertyName = data["propertyName"];
            this.propertyTypeFullName = data["propertyTypeFullName"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityPropertyChangeDto {
        const json = this.toJSON();
        let result = new EntityPropertyChangeDto();
        result.init(json);
        return result;
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number | undefined;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number | undefined;
}

export class CM_BRANCH_ENTITY implements ICM_BRANCH_ENTITY {
    brancH_ID: string | undefined;
    fatheR_ID: string | undefined;
    iS_POTENTIAL: string | undefined;
    brancH_CODE: string | undefined;
    brancH_NAME: string | undefined;
    daO_CODE: string | undefined;
    daO_NAME: string | undefined;
    regioN_ID: string | undefined;
    brancH_TYPE: string | undefined;
    addr: string | undefined;
    provice: string | undefined;
    tel: string | undefined;
    taX_NO: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    f_BRANCH_CODE: string | undefined;
    f_BRANCH_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    brancH_FILTER: string | undefined;
    fatheR_CODE: string | undefined;
    regioN_CODE: string | undefined;
    top: number | undefined;
    brancH_LOGIN: string | undefined;
    totalCount: number | undefined;
    independenT_UNIT: boolean | undefined;
    isChecked: boolean | undefined;
    isLoadAll: boolean | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_BRANCH_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brancH_ID = data["brancH_ID"];
            this.fatheR_ID = data["fatheR_ID"];
            this.iS_POTENTIAL = data["iS_POTENTIAL"];
            this.brancH_CODE = data["brancH_CODE"];
            this.brancH_NAME = data["brancH_NAME"];
            this.daO_CODE = data["daO_CODE"];
            this.daO_NAME = data["daO_NAME"];
            this.regioN_ID = data["regioN_ID"];
            this.brancH_TYPE = data["brancH_TYPE"];
            this.addr = data["addr"];
            this.provice = data["provice"];
            this.tel = data["tel"];
            this.taX_NO = data["taX_NO"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.f_BRANCH_CODE = data["f_BRANCH_CODE"];
            this.f_BRANCH_NAME = data["f_BRANCH_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.brancH_FILTER = data["brancH_FILTER"];
            this.fatheR_CODE = data["fatheR_CODE"];
            this.regioN_CODE = data["regioN_CODE"];
            this.top = data["top"];
            this.brancH_LOGIN = data["brancH_LOGIN"];
            this.totalCount = data["totalCount"];
            this.independenT_UNIT = data["independenT_UNIT"];
            this.isChecked = data["isChecked"];
            this.isLoadAll = data["isLoadAll"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_BRANCH_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_BRANCH_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brancH_ID"] = this.brancH_ID;
        data["fatheR_ID"] = this.fatheR_ID;
        data["iS_POTENTIAL"] = this.iS_POTENTIAL;
        data["brancH_CODE"] = this.brancH_CODE;
        data["brancH_NAME"] = this.brancH_NAME;
        data["daO_CODE"] = this.daO_CODE;
        data["daO_NAME"] = this.daO_NAME;
        data["regioN_ID"] = this.regioN_ID;
        data["brancH_TYPE"] = this.brancH_TYPE;
        data["addr"] = this.addr;
        data["provice"] = this.provice;
        data["tel"] = this.tel;
        data["taX_NO"] = this.taX_NO;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["f_BRANCH_CODE"] = this.f_BRANCH_CODE;
        data["f_BRANCH_NAME"] = this.f_BRANCH_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["brancH_FILTER"] = this.brancH_FILTER;
        data["fatheR_CODE"] = this.fatheR_CODE;
        data["regioN_CODE"] = this.regioN_CODE;
        data["top"] = this.top;
        data["brancH_LOGIN"] = this.brancH_LOGIN;
        data["totalCount"] = this.totalCount;
        data["independenT_UNIT"] = this.independenT_UNIT;
        data["isChecked"] = this.isChecked;
        data["isLoadAll"] = this.isLoadAll;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_BRANCH_ENTITY {
        const json = this.toJSON();
        let result = new CM_BRANCH_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_BRANCH_ENTITY {
    brancH_ID: string | undefined;
    fatheR_ID: string | undefined;
    iS_POTENTIAL: string | undefined;
    brancH_CODE: string | undefined;
    brancH_NAME: string | undefined;
    daO_CODE: string | undefined;
    daO_NAME: string | undefined;
    regioN_ID: string | undefined;
    brancH_TYPE: string | undefined;
    addr: string | undefined;
    provice: string | undefined;
    tel: string | undefined;
    taX_NO: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    f_BRANCH_CODE: string | undefined;
    f_BRANCH_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    brancH_FILTER: string | undefined;
    fatheR_CODE: string | undefined;
    regioN_CODE: string | undefined;
    top: number | undefined;
    brancH_LOGIN: string | undefined;
    totalCount: number | undefined;
    independenT_UNIT: boolean | undefined;
    isChecked: boolean | undefined;
    isLoadAll: boolean | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_BRANCH_ENTITY implements IPagedResultDtoOfCM_BRANCH_ENTITY {
    totalCount: number | undefined;
    items: CM_BRANCH_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_BRANCH_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_BRANCH_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_BRANCH_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_BRANCH_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_BRANCH_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_BRANCH_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_BRANCH_ENTITY {
    totalCount: number | undefined;
    items: CM_BRANCH_ENTITY[] | undefined;
}

export class CM_BRANCH_LEV_ENTITY implements ICM_BRANCH_LEV_ENTITY {
    areas: CM_BRANCH_ENTITY[] | undefined;
    branchs: CM_BRANCH_ENTITY[] | undefined;
    subBranchs: CM_BRANCH_ENTITY[] | undefined;

    constructor(data?: ICM_BRANCH_LEV_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["areas"] && data["areas"].constructor === Array) {
                this.areas = [];
                for (let item of data["areas"])
                    this.areas.push(CM_BRANCH_ENTITY.fromJS(item));
            }
            if (data["branchs"] && data["branchs"].constructor === Array) {
                this.branchs = [];
                for (let item of data["branchs"])
                    this.branchs.push(CM_BRANCH_ENTITY.fromJS(item));
            }
            if (data["subBranchs"] && data["subBranchs"].constructor === Array) {
                this.subBranchs = [];
                for (let item of data["subBranchs"])
                    this.subBranchs.push(CM_BRANCH_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CM_BRANCH_LEV_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_BRANCH_LEV_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.areas && this.areas.constructor === Array) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        if (this.branchs && this.branchs.constructor === Array) {
            data["branchs"] = [];
            for (let item of this.branchs)
                data["branchs"].push(item.toJSON());
        }
        if (this.subBranchs && this.subBranchs.constructor === Array) {
            data["subBranchs"] = [];
            for (let item of this.subBranchs)
                data["subBranchs"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CM_BRANCH_LEV_ENTITY {
        const json = this.toJSON();
        let result = new CM_BRANCH_LEV_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_BRANCH_LEV_ENTITY {
    areas: CM_BRANCH_ENTITY[] | undefined;
    branchs: CM_BRANCH_ENTITY[] | undefined;
    subBranchs: CM_BRANCH_ENTITY[] | undefined;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfCacheDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfCacheDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;
}

export class CacheDto implements ICacheDto {
    name: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CacheDto {
        const json = this.toJSON();
        let result = new CacheDto();
        result.init(json);
        return result;
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDtoOfString {
        const json = this.toJSON();
        let result = new EntityDtoOfString();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export class ASS_GROUP_ENTITY implements IASS_GROUP_ENTITY {
    grouP_ID: string | undefined;
    typE_ID: string | undefined;
    grouP_CODE: string | undefined;
    grouP_NAME: string | undefined;
    parenT_ID: string | undefined;
    grouP_LEVEL: number | undefined;
    asS_CAT: string | undefined;
    amorT_ACCTNO: string | undefined;
    exP_ACCTNO: string | undefined;
    inC_ACCTNO: string | undefined;
    liQ_ACCTNO: string | undefined;
    asseT_ACCTNO: string | undefined;
    asseT_ACCTNO_NHNN: string | undefined;
    amorT_MONTH: string | undefined;
    amorT_RATE: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    parenT_NAME: string | undefined;
    parenT_CODE: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IASS_GROUP_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.grouP_ID = data["grouP_ID"];
            this.typE_ID = data["typE_ID"];
            this.grouP_CODE = data["grouP_CODE"];
            this.grouP_NAME = data["grouP_NAME"];
            this.parenT_ID = data["parenT_ID"];
            this.grouP_LEVEL = data["grouP_LEVEL"];
            this.asS_CAT = data["asS_CAT"];
            this.amorT_ACCTNO = data["amorT_ACCTNO"];
            this.exP_ACCTNO = data["exP_ACCTNO"];
            this.inC_ACCTNO = data["inC_ACCTNO"];
            this.liQ_ACCTNO = data["liQ_ACCTNO"];
            this.asseT_ACCTNO = data["asseT_ACCTNO"];
            this.asseT_ACCTNO_NHNN = data["asseT_ACCTNO_NHNN"];
            this.amorT_MONTH = data["amorT_MONTH"];
            this.amorT_RATE = data["amorT_RATE"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.parenT_NAME = data["parenT_NAME"];
            this.parenT_CODE = data["parenT_CODE"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): ASS_GROUP_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new ASS_GROUP_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grouP_ID"] = this.grouP_ID;
        data["typE_ID"] = this.typE_ID;
        data["grouP_CODE"] = this.grouP_CODE;
        data["grouP_NAME"] = this.grouP_NAME;
        data["parenT_ID"] = this.parenT_ID;
        data["grouP_LEVEL"] = this.grouP_LEVEL;
        data["asS_CAT"] = this.asS_CAT;
        data["amorT_ACCTNO"] = this.amorT_ACCTNO;
        data["exP_ACCTNO"] = this.exP_ACCTNO;
        data["inC_ACCTNO"] = this.inC_ACCTNO;
        data["liQ_ACCTNO"] = this.liQ_ACCTNO;
        data["asseT_ACCTNO"] = this.asseT_ACCTNO;
        data["asseT_ACCTNO_NHNN"] = this.asseT_ACCTNO_NHNN;
        data["amorT_MONTH"] = this.amorT_MONTH;
        data["amorT_RATE"] = this.amorT_RATE;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["parenT_NAME"] = this.parenT_NAME;
        data["parenT_CODE"] = this.parenT_CODE;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): ASS_GROUP_ENTITY {
        const json = this.toJSON();
        let result = new ASS_GROUP_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IASS_GROUP_ENTITY {
    grouP_ID: string | undefined;
    typE_ID: string | undefined;
    grouP_CODE: string | undefined;
    grouP_NAME: string | undefined;
    parenT_ID: string | undefined;
    grouP_LEVEL: number | undefined;
    asS_CAT: string | undefined;
    amorT_ACCTNO: string | undefined;
    exP_ACCTNO: string | undefined;
    inC_ACCTNO: string | undefined;
    liQ_ACCTNO: string | undefined;
    asseT_ACCTNO: string | undefined;
    asseT_ACCTNO_NHNN: string | undefined;
    amorT_MONTH: string | undefined;
    amorT_RATE: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    parenT_NAME: string | undefined;
    parenT_CODE: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfASS_GROUP_ENTITY implements IPagedResultDtoOfASS_GROUP_ENTITY {
    totalCount: number | undefined;
    items: ASS_GROUP_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfASS_GROUP_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ASS_GROUP_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfASS_GROUP_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfASS_GROUP_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfASS_GROUP_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfASS_GROUP_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfASS_GROUP_ENTITY {
    totalCount: number | undefined;
    items: ASS_GROUP_ENTITY[] | undefined;
}

export class CM_CAR_TYPE_ENTITY implements ICM_CAR_TYPE_ENTITY {
    caR_TYPE_ID: string | undefined;
    caR_TYPE_CODE: string | undefined;
    caR_TYPE_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_CAR_TYPE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.caR_TYPE_ID = data["caR_TYPE_ID"];
            this.caR_TYPE_CODE = data["caR_TYPE_CODE"];
            this.caR_TYPE_NAME = data["caR_TYPE_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_CAR_TYPE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_CAR_TYPE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caR_TYPE_ID"] = this.caR_TYPE_ID;
        data["caR_TYPE_CODE"] = this.caR_TYPE_CODE;
        data["caR_TYPE_NAME"] = this.caR_TYPE_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_CAR_TYPE_ENTITY {
        const json = this.toJSON();
        let result = new CM_CAR_TYPE_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_CAR_TYPE_ENTITY {
    caR_TYPE_ID: string | undefined;
    caR_TYPE_CODE: string | undefined;
    caR_TYPE_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_CAR_TYPE_ENTITY implements IPagedResultDtoOfCM_CAR_TYPE_ENTITY {
    totalCount: number | undefined;
    items: CM_CAR_TYPE_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_CAR_TYPE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_CAR_TYPE_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_CAR_TYPE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_CAR_TYPE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_CAR_TYPE_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_CAR_TYPE_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_CAR_TYPE_ENTITY {
    totalCount: number | undefined;
    items: CM_CAR_TYPE_ENTITY[] | undefined;
}

export class HR_CauHinhEmail_ENTITY implements IHR_CauHinhEmail_ENTITY {
    cauhinhemaiL_ID: string | undefined;
    tenmien: string | undefined;
    tentruycap: string | undefined;
    mailfrom: string | undefined;
    matkhau: string | undefined;
    diachiemail: string | undefined;
    tenhienthi: string | undefined;
    diachiip: string | undefined;
    congsmtp: string | undefined;
    checkssl: string | undefined;
    checkthongtin: string | undefined;
    maCTY: number | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    subject: string | undefined;
    body: string | undefined;
    nameAttach: string | undefined;
    subj: string | undefined;
    message: string | undefined;
    toEmail: string | undefined;
    portNumber: number | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    tenanT_ID: string | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    congty: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IHR_CauHinhEmail_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cauhinhemaiL_ID = data["cauhinhemaiL_ID"];
            this.tenmien = data["tenmien"];
            this.tentruycap = data["tentruycap"];
            this.mailfrom = data["mailfrom"];
            this.matkhau = data["matkhau"];
            this.diachiemail = data["diachiemail"];
            this.tenhienthi = data["tenhienthi"];
            this.diachiip = data["diachiip"];
            this.congsmtp = data["congsmtp"];
            this.checkssl = data["checkssl"];
            this.checkthongtin = data["checkthongtin"];
            this.maCTY = data["maCTY"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.subject = data["subject"];
            this.body = data["body"];
            this.nameAttach = data["nameAttach"];
            this.subj = data["subj"];
            this.message = data["message"];
            this.toEmail = data["toEmail"];
            this.portNumber = data["portNumber"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.tenanT_ID = data["tenanT_ID"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.congty = data["congty"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): HR_CauHinhEmail_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HR_CauHinhEmail_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cauhinhemaiL_ID"] = this.cauhinhemaiL_ID;
        data["tenmien"] = this.tenmien;
        data["tentruycap"] = this.tentruycap;
        data["mailfrom"] = this.mailfrom;
        data["matkhau"] = this.matkhau;
        data["diachiemail"] = this.diachiemail;
        data["tenhienthi"] = this.tenhienthi;
        data["diachiip"] = this.diachiip;
        data["congsmtp"] = this.congsmtp;
        data["checkssl"] = this.checkssl;
        data["checkthongtin"] = this.checkthongtin;
        data["maCTY"] = this.maCTY;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["nameAttach"] = this.nameAttach;
        data["subj"] = this.subj;
        data["message"] = this.message;
        data["toEmail"] = this.toEmail;
        data["portNumber"] = this.portNumber;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["tenanT_ID"] = this.tenanT_ID;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["congty"] = this.congty;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): HR_CauHinhEmail_ENTITY {
        const json = this.toJSON();
        let result = new HR_CauHinhEmail_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHR_CauHinhEmail_ENTITY {
    cauhinhemaiL_ID: string | undefined;
    tenmien: string | undefined;
    tentruycap: string | undefined;
    mailfrom: string | undefined;
    matkhau: string | undefined;
    diachiemail: string | undefined;
    tenhienthi: string | undefined;
    diachiip: string | undefined;
    congsmtp: string | undefined;
    checkssl: string | undefined;
    checkthongtin: string | undefined;
    maCTY: number | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    subject: string | undefined;
    body: string | undefined;
    nameAttach: string | undefined;
    subj: string | undefined;
    message: string | undefined;
    toEmail: string | undefined;
    portNumber: number | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    tenanT_ID: string | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    congty: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfHR_CauHinhEmail_ENTITY implements IPagedResultDtoOfHR_CauHinhEmail_ENTITY {
    totalCount: number | undefined;
    items: HR_CauHinhEmail_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfHR_CauHinhEmail_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(HR_CauHinhEmail_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfHR_CauHinhEmail_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfHR_CauHinhEmail_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfHR_CauHinhEmail_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfHR_CauHinhEmail_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfHR_CauHinhEmail_ENTITY {
    totalCount: number | undefined;
    items: HR_CauHinhEmail_ENTITY[] | undefined;
}

export class TLUSER_GETBY_BRANCHID_ENTITY implements ITLUSER_GETBY_BRANCHID_ENTITY {
    tlid: string | undefined;
    tlnanme: string | undefined;
    password: string | undefined;
    tlFullName: string | undefined;
    tlsubbrid: string | undefined;
    brancH_NAME: string | undefined;
    brancH_TYPE: string | undefined;
    roleName: string | undefined;
    emailAddress: string | undefined;
    roles: string | undefined;
    rolE_ID: number | undefined;
    email: string | undefined;
    address: string | undefined;
    phone: string | undefined;
    autH_STATUS: string | undefined;
    markeR_ID: string | undefined;
    autH_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    isapprove: string | undefined;
    birthday: moment.Moment | undefined;
    isfirsttime: string | undefined;
    secuR_CODE: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ITLUSER_GETBY_BRANCHID_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tlid = data["tlid"];
            this.tlnanme = data["tlnanme"];
            this.password = data["password"];
            this.tlFullName = data["tlFullName"];
            this.tlsubbrid = data["tlsubbrid"];
            this.brancH_NAME = data["brancH_NAME"];
            this.brancH_TYPE = data["brancH_TYPE"];
            this.roleName = data["roleName"];
            this.emailAddress = data["emailAddress"];
            this.roles = data["roles"];
            this.rolE_ID = data["rolE_ID"];
            this.email = data["email"];
            this.address = data["address"];
            this.phone = data["phone"];
            this.autH_STATUS = data["autH_STATUS"];
            this.markeR_ID = data["markeR_ID"];
            this.autH_ID = data["autH_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.isapprove = data["isapprove"];
            this.birthday = data["birthday"] ? moment(data["birthday"].toString()) : <any>undefined;
            this.isfirsttime = data["isfirsttime"];
            this.secuR_CODE = data["secuR_CODE"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): TLUSER_GETBY_BRANCHID_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new TLUSER_GETBY_BRANCHID_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tlid"] = this.tlid;
        data["tlnanme"] = this.tlnanme;
        data["password"] = this.password;
        data["tlFullName"] = this.tlFullName;
        data["tlsubbrid"] = this.tlsubbrid;
        data["brancH_NAME"] = this.brancH_NAME;
        data["brancH_TYPE"] = this.brancH_TYPE;
        data["roleName"] = this.roleName;
        data["emailAddress"] = this.emailAddress;
        data["roles"] = this.roles;
        data["rolE_ID"] = this.rolE_ID;
        data["email"] = this.email;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["autH_STATUS"] = this.autH_STATUS;
        data["markeR_ID"] = this.markeR_ID;
        data["autH_ID"] = this.autH_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["isapprove"] = this.isapprove;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["isfirsttime"] = this.isfirsttime;
        data["secuR_CODE"] = this.secuR_CODE;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): TLUSER_GETBY_BRANCHID_ENTITY {
        const json = this.toJSON();
        let result = new TLUSER_GETBY_BRANCHID_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ITLUSER_GETBY_BRANCHID_ENTITY {
    tlid: string | undefined;
    tlnanme: string | undefined;
    password: string | undefined;
    tlFullName: string | undefined;
    tlsubbrid: string | undefined;
    brancH_NAME: string | undefined;
    brancH_TYPE: string | undefined;
    roleName: string | undefined;
    emailAddress: string | undefined;
    roles: string | undefined;
    rolE_ID: number | undefined;
    email: string | undefined;
    address: string | undefined;
    phone: string | undefined;
    autH_STATUS: string | undefined;
    markeR_ID: string | undefined;
    autH_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    isapprove: string | undefined;
    birthday: moment.Moment | undefined;
    isfirsttime: string | undefined;
    secuR_CODE: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY implements IPagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY {
    totalCount: number | undefined;
    items: TLUSER_GETBY_BRANCHID_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TLUSER_GETBY_BRANCHID_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY {
    totalCount: number | undefined;
    items: TLUSER_GETBY_BRANCHID_ENTITY[] | undefined;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfSubscribableEditionComboboxItemDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isFree = data["isFree"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }

    clone(): SubscribableEditionComboboxItemDto {
        const json = this.toJSON();
        let result = new SubscribableEditionComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }

    clone(): FindUsersInput {
        const json = this.toJSON();
        let result = new FindUsersInput();
        result.init(json);
        return result;
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount: number | undefined;
    items: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfNameValueDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfNameValueDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number | undefined;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): GetDefaultEditionNameOutput {
        const json = this.toJSON();
        let result = new GetDefaultEditionNameOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class HR_DaTa_ChamCong_ENTITY implements IHR_DaTa_ChamCong_ENTITY {
    id: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    maChamCong: string | undefined;
    processDate: moment.Moment | undefined;
    status: string | undefined;
    timeOTDuration: number | undefined;
    checkTime: string | undefined;
    timeViolatingRuleFirstDuration: number | undefined;
    timeViolatingRuleLastDuration: number | undefined;
    checkIn: string | undefined;
    checkOut: string | undefined;
    timeWorkAfternoonDuration: number | undefined;
    timeWorkMorningDuration: number | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    tenanT_ID: string | undefined;
    hoVaTen: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IHR_DaTa_ChamCong_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.maChamCong = data["maChamCong"];
            this.processDate = data["processDate"] ? moment(data["processDate"].toString()) : <any>undefined;
            this.status = data["status"];
            this.timeOTDuration = data["timeOTDuration"];
            this.checkTime = data["checkTime"];
            this.timeViolatingRuleFirstDuration = data["timeViolatingRuleFirstDuration"];
            this.timeViolatingRuleLastDuration = data["timeViolatingRuleLastDuration"];
            this.checkIn = data["checkIn"];
            this.checkOut = data["checkOut"];
            this.timeWorkAfternoonDuration = data["timeWorkAfternoonDuration"];
            this.timeWorkMorningDuration = data["timeWorkMorningDuration"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.tenanT_ID = data["tenanT_ID"];
            this.hoVaTen = data["hoVaTen"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): HR_DaTa_ChamCong_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HR_DaTa_ChamCong_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["maChamCong"] = this.maChamCong;
        data["processDate"] = this.processDate ? this.processDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["timeOTDuration"] = this.timeOTDuration;
        data["checkTime"] = this.checkTime;
        data["timeViolatingRuleFirstDuration"] = this.timeViolatingRuleFirstDuration;
        data["timeViolatingRuleLastDuration"] = this.timeViolatingRuleLastDuration;
        data["checkIn"] = this.checkIn;
        data["checkOut"] = this.checkOut;
        data["timeWorkAfternoonDuration"] = this.timeWorkAfternoonDuration;
        data["timeWorkMorningDuration"] = this.timeWorkMorningDuration;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["tenanT_ID"] = this.tenanT_ID;
        data["hoVaTen"] = this.hoVaTen;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): HR_DaTa_ChamCong_ENTITY {
        const json = this.toJSON();
        let result = new HR_DaTa_ChamCong_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHR_DaTa_ChamCong_ENTITY {
    id: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    maChamCong: string | undefined;
    processDate: moment.Moment | undefined;
    status: string | undefined;
    timeOTDuration: number | undefined;
    checkTime: string | undefined;
    timeViolatingRuleFirstDuration: number | undefined;
    timeViolatingRuleLastDuration: number | undefined;
    checkIn: string | undefined;
    checkOut: string | undefined;
    timeWorkAfternoonDuration: number | undefined;
    timeWorkMorningDuration: number | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    tenanT_ID: string | undefined;
    hoVaTen: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfHR_DaTa_ChamCong_ENTITY implements IPagedResultDtoOfHR_DaTa_ChamCong_ENTITY {
    totalCount: number | undefined;
    items: HR_DaTa_ChamCong_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfHR_DaTa_ChamCong_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(HR_DaTa_ChamCong_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfHR_DaTa_ChamCong_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfHR_DaTa_ChamCong_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfHR_DaTa_ChamCong_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfHR_DaTa_ChamCong_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfHR_DaTa_ChamCong_ENTITY {
    totalCount: number | undefined;
    items: HR_DaTa_ChamCong_ENTITY[] | undefined;
}

export class GetAllDataChamCongsInput implements IGetAllDataChamCongsInput {
    filter: string | undefined;
    minProcessDate: moment.Moment | undefined;
    maxProcessDate: moment.Moment | undefined;
    tenCTy: string | undefined;
    phongBan: string | undefined;
    chucDanh: string | undefined;
    diTre: boolean | undefined;
    veSom: boolean | undefined;
    tangCa: boolean | undefined;
    nghiPhep: boolean | undefined;
    congTac: boolean | undefined;
    quenChamCong: boolean | undefined;
    isExportExcel: boolean | undefined;
    totalCount: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;

    constructor(data?: IGetAllDataChamCongsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.minProcessDate = data["minProcessDate"] ? moment(data["minProcessDate"].toString()) : <any>undefined;
            this.maxProcessDate = data["maxProcessDate"] ? moment(data["maxProcessDate"].toString()) : <any>undefined;
            this.tenCTy = data["tenCTy"];
            this.phongBan = data["phongBan"];
            this.chucDanh = data["chucDanh"];
            this.diTre = data["diTre"];
            this.veSom = data["veSom"];
            this.tangCa = data["tangCa"];
            this.nghiPhep = data["nghiPhep"];
            this.congTac = data["congTac"];
            this.quenChamCong = data["quenChamCong"];
            this.isExportExcel = data["isExportExcel"];
            this.totalCount = data["totalCount"];
            this.sorting = data["sorting"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): GetAllDataChamCongsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDataChamCongsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["minProcessDate"] = this.minProcessDate ? this.minProcessDate.toISOString() : <any>undefined;
        data["maxProcessDate"] = this.maxProcessDate ? this.maxProcessDate.toISOString() : <any>undefined;
        data["tenCTy"] = this.tenCTy;
        data["phongBan"] = this.phongBan;
        data["chucDanh"] = this.chucDanh;
        data["diTre"] = this.diTre;
        data["veSom"] = this.veSom;
        data["tangCa"] = this.tangCa;
        data["nghiPhep"] = this.nghiPhep;
        data["congTac"] = this.congTac;
        data["quenChamCong"] = this.quenChamCong;
        data["isExportExcel"] = this.isExportExcel;
        data["totalCount"] = this.totalCount;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone(): GetAllDataChamCongsInput {
        const json = this.toJSON();
        let result = new GetAllDataChamCongsInput();
        result.init(json);
        return result;
    }
}

export interface IGetAllDataChamCongsInput {
    filter: string | undefined;
    minProcessDate: moment.Moment | undefined;
    maxProcessDate: moment.Moment | undefined;
    tenCTy: string | undefined;
    phongBan: string | undefined;
    chucDanh: string | undefined;
    diTre: boolean | undefined;
    veSom: boolean | undefined;
    tangCa: boolean | undefined;
    nghiPhep: boolean | undefined;
    congTac: boolean | undefined;
    quenChamCong: boolean | undefined;
    isExportExcel: boolean | undefined;
    totalCount: number | undefined;
    sorting: string | undefined;
    skipCount: number | undefined;
    maxResultCount: number | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number | undefined;
    roleCount: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
            this.roleCount = data["roleCount"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationUnitDto {
        const json = this.toJSON();
        let result = new OrganizationUnitDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number | undefined;
    roleCount: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment | undefined;
    friends: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serverTime = data["serverTime"] ? moment(data["serverTime"].toString()) : <any>undefined;
            if (data["friends"] && data["friends"].constructor === Array) {
                this.friends = [];
                for (let item of data["friends"])
                    this.friends.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        if (this.friends && this.friends.constructor === Array) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetUserChatFriendsWithSettingsOutput {
        const json = this.toJSON();
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment | undefined;
    friends: FriendDto[] | undefined;
}

export class FriendDto implements IFriendDto {
    friendUserId: number | undefined;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number | undefined;
    isOnline: boolean | undefined;
    state: FriendshipState | undefined;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.friendUserId = data["friendUserId"];
            this.friendTenantId = data["friendTenantId"];
            this.friendUserName = data["friendUserName"];
            this.friendTenancyName = data["friendTenancyName"];
            this.friendProfilePictureId = data["friendProfilePictureId"];
            this.unreadMessageCount = data["unreadMessageCount"];
            this.isOnline = data["isOnline"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data; 
    }

    clone(): FriendDto {
        const json = this.toJSON();
        let result = new FriendDto();
        result.init(json);
        return result;
    }
}

export interface IFriendDto {
    friendUserId: number | undefined;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number | undefined;
    isOnline: boolean | undefined;
    state: FriendshipState | undefined;
}

export enum FriendshipState {
    Accepted = 1, 
    Blocked = 2, 
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfChatMessageDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfChatMessageDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;
}

export class ChatMessageDto implements IChatMessageDto {
    userId: number | undefined;
    tenantId: number | undefined;
    targetUserId: number | undefined;
    targetTenantId: number | undefined;
    side: ChatSide | undefined;
    readState: ChatMessageReadState | undefined;
    receiverReadState: ChatMessageReadState | undefined;
    message: string | undefined;
    creationTime: moment.Moment | undefined;
    sharedMessageId: string | undefined;
    id: number | undefined;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.targetUserId = data["targetUserId"];
            this.targetTenantId = data["targetTenantId"];
            this.side = data["side"];
            this.readState = data["readState"];
            this.receiverReadState = data["receiverReadState"];
            this.message = data["message"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = data["sharedMessageId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ChatMessageDto {
        const json = this.toJSON();
        let result = new ChatMessageDto();
        result.init(json);
        return result;
    }
}

export interface IChatMessageDto {
    userId: number | undefined;
    tenantId: number | undefined;
    targetUserId: number | undefined;
    targetTenantId: number | undefined;
    side: ChatSide | undefined;
    readState: ChatMessageReadState | undefined;
    receiverReadState: ChatMessageReadState | undefined;
    message: string | undefined;
    creationTime: moment.Moment | undefined;
    sharedMessageId: string | undefined;
    id: number | undefined;
}

export enum ChatSide {
    Sender = 1, 
    Receiver = 2, 
}

export enum ChatMessageReadState {
    Unread = 1, 
    Read = 2, 
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number | undefined;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): MarkAllUnreadMessagesOfUserAsReadInput {
        const json = this.toJSON();
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(json);
        return result;
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class DashboardDto implements IDashboardDto {
    dashboardCode: string | undefined;
    name: string | undefined;
    descriptions: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dashboardCode = data["dashboardCode"];
            this.name = data["name"];
            this.descriptions = data["descriptions"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardCode"] = this.dashboardCode;
        data["name"] = this.name;
        data["descriptions"] = this.descriptions;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DashboardDto {
        const json = this.toJSON();
        let result = new DashboardDto();
        result.init(json);
        return result;
    }
}

export interface IDashboardDto {
    dashboardCode: string | undefined;
    name: string | undefined;
    descriptions: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PageDto implements IPageDto {
    pageCode: string | undefined;
    name: string | undefined;
    descriptions: string | undefined;
    dashboardId: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IPageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pageCode = data["pageCode"];
            this.name = data["name"];
            this.descriptions = data["descriptions"];
            this.dashboardId = data["dashboardId"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageCode"] = this.pageCode;
        data["name"] = this.name;
        data["descriptions"] = this.descriptions;
        data["dashboardId"] = this.dashboardId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PageDto {
        const json = this.toJSON();
        let result = new PageDto();
        result.init(json);
        return result;
    }
}

export interface IPageDto {
    pageCode: string | undefined;
    name: string | undefined;
    descriptions: string | undefined;
    dashboardId: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class FDataVm implements IFDataVm {
    isSucceeded: boolean | undefined;
    data: any | undefined;
    message: string | undefined;
    code: string | undefined;

    constructor(data?: IFDataVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isSucceeded = data["isSucceeded"];
            this.data = data["data"];
            this.message = data["message"];
            this.code = data["code"];
        }
    }

    static fromJS(data: any): FDataVm {
        data = typeof data === 'object' ? data : {};
        let result = new FDataVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSucceeded"] = this.isSucceeded;
        data["data"] = this.data;
        data["message"] = this.message;
        data["code"] = this.code;
        return data; 
    }

    clone(): FDataVm {
        const json = this.toJSON();
        let result = new FDataVm();
        result.init(json);
        return result;
    }
}

export interface IFDataVm {
    isSucceeded: boolean | undefined;
    data: any | undefined;
    message: string | undefined;
    code: string | undefined;
}

export class AddWidgetMapInput implements IAddWidgetMapInput {
    widgetId: number | undefined;
    pageId: number | undefined;
    width: number | undefined;
    height: number | undefined;

    constructor(data?: IAddWidgetMapInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.widgetId = data["widgetId"];
            this.pageId = data["pageId"];
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): AddWidgetMapInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddWidgetMapInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetId"] = this.widgetId;
        data["pageId"] = this.pageId;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }

    clone(): AddWidgetMapInput {
        const json = this.toJSON();
        let result = new AddWidgetMapInput();
        result.init(json);
        return result;
    }
}

export interface IAddWidgetMapInput {
    widgetId: number | undefined;
    pageId: number | undefined;
    width: number | undefined;
    height: number | undefined;
}

export class WidgetMapOutput implements IWidgetMapOutput {
    id: number | undefined;
    widgetItemId: number | undefined;
    widgetCode: string | undefined;
    positionX: number | undefined;
    positionY: number | undefined;
    height: number | undefined;
    width: number | undefined;

    constructor(data?: IWidgetMapOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.widgetItemId = data["widgetItemId"];
            this.widgetCode = data["widgetCode"];
            this.positionX = data["positionX"];
            this.positionY = data["positionY"];
            this.height = data["height"];
            this.width = data["width"];
        }
    }

    static fromJS(data: any): WidgetMapOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetMapOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["widgetItemId"] = this.widgetItemId;
        data["widgetCode"] = this.widgetCode;
        data["positionX"] = this.positionX;
        data["positionY"] = this.positionY;
        data["height"] = this.height;
        data["width"] = this.width;
        return data; 
    }

    clone(): WidgetMapOutput {
        const json = this.toJSON();
        let result = new WidgetMapOutput();
        result.init(json);
        return result;
    }
}

export interface IWidgetMapOutput {
    id: number | undefined;
    widgetItemId: number | undefined;
    widgetCode: string | undefined;
    positionX: number | undefined;
    positionY: number | undefined;
    height: number | undefined;
    width: number | undefined;
}

export class AddNewPageInput implements IAddNewPageInput {
    dashboardCode: string | undefined;
    name: string | undefined;
    code: string | undefined;

    constructor(data?: IAddNewPageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dashboardCode = data["dashboardCode"];
            this.name = data["name"];
            this.code = data["code"];
        }
    }

    static fromJS(data: any): AddNewPageInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewPageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardCode"] = this.dashboardCode;
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }

    clone(): AddNewPageInput {
        const json = this.toJSON();
        let result = new AddNewPageInput();
        result.init(json);
        return result;
    }
}

export interface IAddNewPageInput {
    dashboardCode: string | undefined;
    name: string | undefined;
    code: string | undefined;
}

export class FParameter implements IFParameter {
    variable: string | undefined;
    value: any | undefined;

    constructor(data?: IFParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.variable = data["variable"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): FParameter {
        data = typeof data === 'object' ? data : {};
        let result = new FParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["variable"] = this.variable;
        data["value"] = this.value;
        return data; 
    }

    clone(): FParameter {
        const json = this.toJSON();
        let result = new FParameter();
        result.init(json);
        return result;
    }
}

export interface IFParameter {
    variable: string | undefined;
    value: any | undefined;
}

export class WidgetFilterOutput implements IWidgetFilterOutput {
    id: string | undefined;
    name: string | undefined;

    constructor(data?: IWidgetFilterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): WidgetFilterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetFilterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): WidgetFilterOutput {
        const json = this.toJSON();
        let result = new WidgetFilterOutput();
        result.init(json);
        return result;
    }
}

export interface IWidgetFilterOutput {
    id: string | undefined;
    name: string | undefined;
}

export class SavePageInput implements ISavePageInput {
    dashboardName: string | undefined;
    application: string | undefined;
    pages: PageViewDto[] | undefined;

    constructor(data?: ISavePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dashboardName = data["dashboardName"];
            this.application = data["application"];
            if (data["pages"] && data["pages"].constructor === Array) {
                this.pages = [];
                for (let item of data["pages"])
                    this.pages.push(PageViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SavePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SavePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["application"] = this.application;
        if (this.pages && this.pages.constructor === Array) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SavePageInput {
        const json = this.toJSON();
        let result = new SavePageInput();
        result.init(json);
        return result;
    }
}

export interface ISavePageInput {
    dashboardName: string | undefined;
    application: string | undefined;
    pages: PageViewDto[] | undefined;
}

export class PageViewDto implements IPageViewDto {
    id: number | undefined;
    pageCode: string | undefined;
    name: string | undefined;
    widgets: WidgetViewDto[] | undefined;

    constructor(data?: IPageViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.pageCode = data["pageCode"];
            this.name = data["name"];
            if (data["widgets"] && data["widgets"].constructor === Array) {
                this.widgets = [];
                for (let item of data["widgets"])
                    this.widgets.push(WidgetViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pageCode"] = this.pageCode;
        data["name"] = this.name;
        if (this.widgets && this.widgets.constructor === Array) {
            data["widgets"] = [];
            for (let item of this.widgets)
                data["widgets"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PageViewDto {
        const json = this.toJSON();
        let result = new PageViewDto();
        result.init(json);
        return result;
    }
}

export interface IPageViewDto {
    id: number | undefined;
    pageCode: string | undefined;
    name: string | undefined;
    widgets: WidgetViewDto[] | undefined;
}

export class WidgetViewDto implements IWidgetViewDto {
    id: number | undefined;
    widgetCode: string | undefined;
    name: string | undefined;
    positionX: number | undefined;
    positionY: number | undefined;
    height: number | undefined;
    width: number | undefined;

    constructor(data?: IWidgetViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.widgetCode = data["widgetCode"];
            this.name = data["name"];
            this.positionX = data["positionX"];
            this.positionY = data["positionY"];
            this.height = data["height"];
            this.width = data["width"];
        }
    }

    static fromJS(data: any): WidgetViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["widgetCode"] = this.widgetCode;
        data["name"] = this.name;
        data["positionX"] = this.positionX;
        data["positionY"] = this.positionY;
        data["height"] = this.height;
        data["width"] = this.width;
        return data; 
    }

    clone(): WidgetViewDto {
        const json = this.toJSON();
        let result = new WidgetViewDto();
        result.init(json);
        return result;
    }
}

export interface IWidgetViewDto {
    id: number | undefined;
    widgetCode: string | undefined;
    name: string | undefined;
    positionX: number | undefined;
    positionY: number | undefined;
    height: number | undefined;
    width: number | undefined;
}

export class T_DELETE_ASS_ENTITY implements IT_DELETE_ASS_ENTITY {
    deL_ASS_ID: string | undefined;
    deL_ASS_CODE: string | undefined;
    asS_ID: string | undefined;
    asS_CODE: string | undefined;
    reason: string | undefined;
    requesT_NAME: string | undefined;
    requesT_DT: moment.Moment | undefined;
    brancH_ID: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    notes: string | undefined;
    autH_STATUS_NAME: string | undefined;
    asseT_NAME: string | undefined;
    level: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IT_DELETE_ASS_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deL_ASS_ID = data["deL_ASS_ID"];
            this.deL_ASS_CODE = data["deL_ASS_CODE"];
            this.asS_ID = data["asS_ID"];
            this.asS_CODE = data["asS_CODE"];
            this.reason = data["reason"];
            this.requesT_NAME = data["requesT_NAME"];
            this.requesT_DT = data["requesT_DT"] ? moment(data["requesT_DT"].toString()) : <any>undefined;
            this.brancH_ID = data["brancH_ID"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.autH_STATUS = data["autH_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.asseT_NAME = data["asseT_NAME"];
            this.level = data["level"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): T_DELETE_ASS_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new T_DELETE_ASS_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deL_ASS_ID"] = this.deL_ASS_ID;
        data["deL_ASS_CODE"] = this.deL_ASS_CODE;
        data["asS_ID"] = this.asS_ID;
        data["asS_CODE"] = this.asS_CODE;
        data["reason"] = this.reason;
        data["requesT_NAME"] = this.requesT_NAME;
        data["requesT_DT"] = this.requesT_DT ? this.requesT_DT.toISOString() : <any>undefined;
        data["brancH_ID"] = this.brancH_ID;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["autH_STATUS"] = this.autH_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["asseT_NAME"] = this.asseT_NAME;
        data["level"] = this.level;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): T_DELETE_ASS_ENTITY {
        const json = this.toJSON();
        let result = new T_DELETE_ASS_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IT_DELETE_ASS_ENTITY {
    deL_ASS_ID: string | undefined;
    deL_ASS_CODE: string | undefined;
    asS_ID: string | undefined;
    asS_CODE: string | undefined;
    reason: string | undefined;
    requesT_NAME: string | undefined;
    requesT_DT: moment.Moment | undefined;
    brancH_ID: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    notes: string | undefined;
    autH_STATUS_NAME: string | undefined;
    asseT_NAME: string | undefined;
    level: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfT_DELETE_ASS_ENTITY implements IPagedResultDtoOfT_DELETE_ASS_ENTITY {
    totalCount: number | undefined;
    items: T_DELETE_ASS_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfT_DELETE_ASS_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(T_DELETE_ASS_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfT_DELETE_ASS_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfT_DELETE_ASS_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfT_DELETE_ASS_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfT_DELETE_ASS_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfT_DELETE_ASS_ENTITY {
    totalCount: number | undefined;
    items: T_DELETE_ASS_ENTITY[] | undefined;
}

export class T_DEL_ASS_MUL_ENTITY implements IT_DEL_ASS_MUL_ENTITY {
    deL_ASS_MUL_ID: string | undefined;
    deL_ASS_MUL_CODE: string | undefined;
    reason: string | undefined;
    requesT_NAME: string | undefined;
    requesT_DT: moment.Moment | undefined;
    brancH_ID: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    notes: string | undefined;
    xmL_TEMP: string | undefined;
    autH_STATUS_NAME: string | undefined;
    nguoI_XOA_TS: string | undefined;
    nguoI_DUYET_TS: string | undefined;
    doN_VI_XOA_TS: string | undefined;
    fromdate: moment.Moment | undefined;
    todate: moment.Moment | undefined;
    deL_ASS_MUL_DTs: T_DEL_ASS_MUL_DT_ENTITY[] | undefined;
    level: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IT_DEL_ASS_MUL_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deL_ASS_MUL_ID = data["deL_ASS_MUL_ID"];
            this.deL_ASS_MUL_CODE = data["deL_ASS_MUL_CODE"];
            this.reason = data["reason"];
            this.requesT_NAME = data["requesT_NAME"];
            this.requesT_DT = data["requesT_DT"] ? moment(data["requesT_DT"].toString()) : <any>undefined;
            this.brancH_ID = data["brancH_ID"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.autH_STATUS = data["autH_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.xmL_TEMP = data["xmL_TEMP"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.nguoI_XOA_TS = data["nguoI_XOA_TS"];
            this.nguoI_DUYET_TS = data["nguoI_DUYET_TS"];
            this.doN_VI_XOA_TS = data["doN_VI_XOA_TS"];
            this.fromdate = data["fromdate"] ? moment(data["fromdate"].toString()) : <any>undefined;
            this.todate = data["todate"] ? moment(data["todate"].toString()) : <any>undefined;
            if (data["deL_ASS_MUL_DTs"] && data["deL_ASS_MUL_DTs"].constructor === Array) {
                this.deL_ASS_MUL_DTs = [];
                for (let item of data["deL_ASS_MUL_DTs"])
                    this.deL_ASS_MUL_DTs.push(T_DEL_ASS_MUL_DT_ENTITY.fromJS(item));
            }
            this.level = data["level"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): T_DEL_ASS_MUL_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new T_DEL_ASS_MUL_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deL_ASS_MUL_ID"] = this.deL_ASS_MUL_ID;
        data["deL_ASS_MUL_CODE"] = this.deL_ASS_MUL_CODE;
        data["reason"] = this.reason;
        data["requesT_NAME"] = this.requesT_NAME;
        data["requesT_DT"] = this.requesT_DT ? this.requesT_DT.toISOString() : <any>undefined;
        data["brancH_ID"] = this.brancH_ID;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["autH_STATUS"] = this.autH_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["xmL_TEMP"] = this.xmL_TEMP;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["nguoI_XOA_TS"] = this.nguoI_XOA_TS;
        data["nguoI_DUYET_TS"] = this.nguoI_DUYET_TS;
        data["doN_VI_XOA_TS"] = this.doN_VI_XOA_TS;
        data["fromdate"] = this.fromdate ? this.fromdate.toISOString() : <any>undefined;
        data["todate"] = this.todate ? this.todate.toISOString() : <any>undefined;
        if (this.deL_ASS_MUL_DTs && this.deL_ASS_MUL_DTs.constructor === Array) {
            data["deL_ASS_MUL_DTs"] = [];
            for (let item of this.deL_ASS_MUL_DTs)
                data["deL_ASS_MUL_DTs"].push(item.toJSON());
        }
        data["level"] = this.level;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): T_DEL_ASS_MUL_ENTITY {
        const json = this.toJSON();
        let result = new T_DEL_ASS_MUL_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IT_DEL_ASS_MUL_ENTITY {
    deL_ASS_MUL_ID: string | undefined;
    deL_ASS_MUL_CODE: string | undefined;
    reason: string | undefined;
    requesT_NAME: string | undefined;
    requesT_DT: moment.Moment | undefined;
    brancH_ID: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    notes: string | undefined;
    xmL_TEMP: string | undefined;
    autH_STATUS_NAME: string | undefined;
    nguoI_XOA_TS: string | undefined;
    nguoI_DUYET_TS: string | undefined;
    doN_VI_XOA_TS: string | undefined;
    fromdate: moment.Moment | undefined;
    todate: moment.Moment | undefined;
    deL_ASS_MUL_DTs: T_DEL_ASS_MUL_DT_ENTITY[] | undefined;
    level: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class T_DEL_ASS_MUL_DT_ENTITY implements IT_DEL_ASS_MUL_DT_ENTITY {
    deL_ASS_MUL_DT_ID: string | undefined;
    deL_DT_MUL_ASS_CODE: string | undefined;
    deL_MUL_ASS_ID: string | undefined;
    asS_ID: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    notes: string | undefined;
    asseT_NAME: string | undefined;
    asseT_CODE: string | undefined;
    asseT_SERIAL_NO: string | undefined;
    thongtiN_MOTA: string | undefined;
    ngaybD_KHAUHAO: moment.Moment | undefined;
    ngaykT_KHAUHAO: moment.Moment | undefined;
    sotieN_KHAUHAO: number | undefined;
    sothanG_KHAUHAO: number | undefined;
    nguyeN_GIA: number | undefined;
    loaI_TAI_SAN: string | undefined;
    nhoM_TAI_SAN: string | undefined;
    no: number | undefined;
    page: number | undefined;
    isChecked: boolean | undefined;

    constructor(data?: IT_DEL_ASS_MUL_DT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deL_ASS_MUL_DT_ID = data["deL_ASS_MUL_DT_ID"];
            this.deL_DT_MUL_ASS_CODE = data["deL_DT_MUL_ASS_CODE"];
            this.deL_MUL_ASS_ID = data["deL_MUL_ASS_ID"];
            this.asS_ID = data["asS_ID"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.autH_STATUS = data["autH_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.asseT_NAME = data["asseT_NAME"];
            this.asseT_CODE = data["asseT_CODE"];
            this.asseT_SERIAL_NO = data["asseT_SERIAL_NO"];
            this.thongtiN_MOTA = data["thongtiN_MOTA"];
            this.ngaybD_KHAUHAO = data["ngaybD_KHAUHAO"] ? moment(data["ngaybD_KHAUHAO"].toString()) : <any>undefined;
            this.ngaykT_KHAUHAO = data["ngaykT_KHAUHAO"] ? moment(data["ngaykT_KHAUHAO"].toString()) : <any>undefined;
            this.sotieN_KHAUHAO = data["sotieN_KHAUHAO"];
            this.sothanG_KHAUHAO = data["sothanG_KHAUHAO"];
            this.nguyeN_GIA = data["nguyeN_GIA"];
            this.loaI_TAI_SAN = data["loaI_TAI_SAN"];
            this.nhoM_TAI_SAN = data["nhoM_TAI_SAN"];
            this.no = data["no"];
            this.page = data["page"];
            this.isChecked = data["isChecked"];
        }
    }

    static fromJS(data: any): T_DEL_ASS_MUL_DT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new T_DEL_ASS_MUL_DT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deL_ASS_MUL_DT_ID"] = this.deL_ASS_MUL_DT_ID;
        data["deL_DT_MUL_ASS_CODE"] = this.deL_DT_MUL_ASS_CODE;
        data["deL_MUL_ASS_ID"] = this.deL_MUL_ASS_ID;
        data["asS_ID"] = this.asS_ID;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["autH_STATUS"] = this.autH_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["asseT_NAME"] = this.asseT_NAME;
        data["asseT_CODE"] = this.asseT_CODE;
        data["asseT_SERIAL_NO"] = this.asseT_SERIAL_NO;
        data["thongtiN_MOTA"] = this.thongtiN_MOTA;
        data["ngaybD_KHAUHAO"] = this.ngaybD_KHAUHAO ? this.ngaybD_KHAUHAO.toISOString() : <any>undefined;
        data["ngaykT_KHAUHAO"] = this.ngaykT_KHAUHAO ? this.ngaykT_KHAUHAO.toISOString() : <any>undefined;
        data["sotieN_KHAUHAO"] = this.sotieN_KHAUHAO;
        data["sothanG_KHAUHAO"] = this.sothanG_KHAUHAO;
        data["nguyeN_GIA"] = this.nguyeN_GIA;
        data["loaI_TAI_SAN"] = this.loaI_TAI_SAN;
        data["nhoM_TAI_SAN"] = this.nhoM_TAI_SAN;
        data["no"] = this.no;
        data["page"] = this.page;
        data["isChecked"] = this.isChecked;
        return data; 
    }

    clone(): T_DEL_ASS_MUL_DT_ENTITY {
        const json = this.toJSON();
        let result = new T_DEL_ASS_MUL_DT_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IT_DEL_ASS_MUL_DT_ENTITY {
    deL_ASS_MUL_DT_ID: string | undefined;
    deL_DT_MUL_ASS_CODE: string | undefined;
    deL_MUL_ASS_ID: string | undefined;
    asS_ID: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    notes: string | undefined;
    asseT_NAME: string | undefined;
    asseT_CODE: string | undefined;
    asseT_SERIAL_NO: string | undefined;
    thongtiN_MOTA: string | undefined;
    ngaybD_KHAUHAO: moment.Moment | undefined;
    ngaykT_KHAUHAO: moment.Moment | undefined;
    sotieN_KHAUHAO: number | undefined;
    sothanG_KHAUHAO: number | undefined;
    nguyeN_GIA: number | undefined;
    loaI_TAI_SAN: string | undefined;
    nhoM_TAI_SAN: string | undefined;
    no: number | undefined;
    page: number | undefined;
    isChecked: boolean | undefined;
}

export class PagedResultDtoOfT_DEL_ASS_MUL_ENTITY implements IPagedResultDtoOfT_DEL_ASS_MUL_ENTITY {
    totalCount: number | undefined;
    items: T_DEL_ASS_MUL_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfT_DEL_ASS_MUL_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(T_DEL_ASS_MUL_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfT_DEL_ASS_MUL_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfT_DEL_ASS_MUL_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfT_DEL_ASS_MUL_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfT_DEL_ASS_MUL_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfT_DEL_ASS_MUL_ENTITY {
    totalCount: number | undefined;
    items: T_DEL_ASS_MUL_ENTITY[] | undefined;
}

export class DateToStringOutput implements IDateToStringOutput {
    dateString: string | undefined;

    constructor(data?: IDateToStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateString = data["dateString"];
        }
    }

    static fromJS(data: any): DateToStringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateToStringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateString"] = this.dateString;
        return data; 
    }

    clone(): DateToStringOutput {
        const json = this.toJSON();
        let result = new DateToStringOutput();
        result.init(json);
        return result;
    }
}

export interface IDateToStringOutput {
    dateString: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name: string | undefined;
    value: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): NameValueOfString {
        const json = this.toJSON();
        let result = new NameValueOfString();
        result.init(json);
        return result;
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class StringOutput implements IStringOutput {
    output: string | undefined;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.output = data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data; 
    }

    clone(): StringOutput {
        const json = this.toJSON();
        let result = new StringOutput();
        result.init(json);
        return result;
    }
}

export interface IStringOutput {
    output: string | undefined;
}

export class CM_DEPARTMENT_ENTITY implements ICM_DEPARTMENT_ENTITY {
    deP_ID: string | undefined;
    deP_CODE: string | undefined;
    deP_NAME: string | undefined;
    daO_CODE: string | undefined;
    daO_NAME: string | undefined;
    brancH_ID: string | undefined;
    brancH_NAME: string | undefined;
    brancH_CODE: string | undefined;
    grouP_ID: string | undefined;
    tel: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    khoI_ID: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_DEPARTMENT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deP_ID = data["deP_ID"];
            this.deP_CODE = data["deP_CODE"];
            this.deP_NAME = data["deP_NAME"];
            this.daO_CODE = data["daO_CODE"];
            this.daO_NAME = data["daO_NAME"];
            this.brancH_ID = data["brancH_ID"];
            this.brancH_NAME = data["brancH_NAME"];
            this.brancH_CODE = data["brancH_CODE"];
            this.grouP_ID = data["grouP_ID"];
            this.tel = data["tel"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.khoI_ID = data["khoI_ID"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_DEPARTMENT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_DEPARTMENT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deP_ID"] = this.deP_ID;
        data["deP_CODE"] = this.deP_CODE;
        data["deP_NAME"] = this.deP_NAME;
        data["daO_CODE"] = this.daO_CODE;
        data["daO_NAME"] = this.daO_NAME;
        data["brancH_ID"] = this.brancH_ID;
        data["brancH_NAME"] = this.brancH_NAME;
        data["brancH_CODE"] = this.brancH_CODE;
        data["grouP_ID"] = this.grouP_ID;
        data["tel"] = this.tel;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["khoI_ID"] = this.khoI_ID;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_DEPARTMENT_ENTITY {
        const json = this.toJSON();
        let result = new CM_DEPARTMENT_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_DEPARTMENT_ENTITY {
    deP_ID: string | undefined;
    deP_CODE: string | undefined;
    deP_NAME: string | undefined;
    daO_CODE: string | undefined;
    daO_NAME: string | undefined;
    brancH_ID: string | undefined;
    brancH_NAME: string | undefined;
    brancH_CODE: string | undefined;
    grouP_ID: string | undefined;
    tel: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    khoI_ID: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_DEPARTMENT_ENTITY implements IPagedResultDtoOfCM_DEPARTMENT_ENTITY {
    totalCount: number | undefined;
    items: CM_DEPARTMENT_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_DEPARTMENT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_DEPARTMENT_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_DEPARTMENT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_DEPARTMENT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_DEPARTMENT_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_DEPARTMENT_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_DEPARTMENT_ENTITY {
    totalCount: number | undefined;
    items: CM_DEPARTMENT_ENTITY[] | undefined;
}

export class CM_DEPT_GROUP_ENTITY implements ICM_DEPT_GROUP_ENTITY {
    grouP_ID: string | undefined;
    grouP_CODE: string | undefined;
    grouP_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_DEPT_GROUP_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.grouP_ID = data["grouP_ID"];
            this.grouP_CODE = data["grouP_CODE"];
            this.grouP_NAME = data["grouP_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_DEPT_GROUP_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_DEPT_GROUP_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grouP_ID"] = this.grouP_ID;
        data["grouP_CODE"] = this.grouP_CODE;
        data["grouP_NAME"] = this.grouP_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_DEPT_GROUP_ENTITY {
        const json = this.toJSON();
        let result = new CM_DEPT_GROUP_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_DEPT_GROUP_ENTITY {
    grouP_ID: string | undefined;
    grouP_CODE: string | undefined;
    grouP_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_DEPT_GROUP_ENTITY implements IPagedResultDtoOfCM_DEPT_GROUP_ENTITY {
    totalCount: number | undefined;
    items: CM_DEPT_GROUP_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_DEPT_GROUP_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_DEPT_GROUP_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_DEPT_GROUP_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_DEPT_GROUP_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_DEPT_GROUP_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_DEPT_GROUP_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_DEPT_GROUP_ENTITY {
    totalCount: number | undefined;
    items: CM_DEPT_GROUP_ENTITY[] | undefined;
}

export class DISTRIBUTION_DELETE_LIST_ENTITY implements IDISTRIBUTION_DELETE_LIST_ENTITY {
    deL_DISTR_ID: string | undefined;
    deL_DISTR_CODE: string | undefined;
    brancH_ID: string | undefined;
    distribution: string | undefined;
    typE_ID: string | undefined;
    requesT_NAME: string | undefined;
    reason: string | undefined;
    requesT_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    notes: string | undefined;
    autH_STATUS_NAME: string | undefined;
    brancH_NAME: string | undefined;
    level: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IDISTRIBUTION_DELETE_LIST_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deL_DISTR_ID = data["deL_DISTR_ID"];
            this.deL_DISTR_CODE = data["deL_DISTR_CODE"];
            this.brancH_ID = data["brancH_ID"];
            this.distribution = data["distribution"];
            this.typE_ID = data["typE_ID"];
            this.requesT_NAME = data["requesT_NAME"];
            this.reason = data["reason"];
            this.requesT_DT = data["requesT_DT"] ? moment(data["requesT_DT"].toString()) : <any>undefined;
            this.recorD_STATUS = data["recorD_STATUS"];
            this.autH_STATUS = data["autH_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.brancH_NAME = data["brancH_NAME"];
            this.level = data["level"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): DISTRIBUTION_DELETE_LIST_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new DISTRIBUTION_DELETE_LIST_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deL_DISTR_ID"] = this.deL_DISTR_ID;
        data["deL_DISTR_CODE"] = this.deL_DISTR_CODE;
        data["brancH_ID"] = this.brancH_ID;
        data["distribution"] = this.distribution;
        data["typE_ID"] = this.typE_ID;
        data["requesT_NAME"] = this.requesT_NAME;
        data["reason"] = this.reason;
        data["requesT_DT"] = this.requesT_DT ? this.requesT_DT.toISOString() : <any>undefined;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["autH_STATUS"] = this.autH_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["brancH_NAME"] = this.brancH_NAME;
        data["level"] = this.level;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): DISTRIBUTION_DELETE_LIST_ENTITY {
        const json = this.toJSON();
        let result = new DISTRIBUTION_DELETE_LIST_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IDISTRIBUTION_DELETE_LIST_ENTITY {
    deL_DISTR_ID: string | undefined;
    deL_DISTR_CODE: string | undefined;
    brancH_ID: string | undefined;
    distribution: string | undefined;
    typE_ID: string | undefined;
    requesT_NAME: string | undefined;
    reason: string | undefined;
    requesT_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    notes: string | undefined;
    autH_STATUS_NAME: string | undefined;
    brancH_NAME: string | undefined;
    level: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfDISTRIBUTION_DELETE_LIST_ENTITY implements IPagedResultDtoOfDISTRIBUTION_DELETE_LIST_ENTITY {
    totalCount: number | undefined;
    items: DISTRIBUTION_DELETE_LIST_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfDISTRIBUTION_DELETE_LIST_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DISTRIBUTION_DELETE_LIST_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDISTRIBUTION_DELETE_LIST_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDISTRIBUTION_DELETE_LIST_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDISTRIBUTION_DELETE_LIST_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDISTRIBUTION_DELETE_LIST_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDISTRIBUTION_DELETE_LIST_ENTITY {
    totalCount: number | undefined;
    items: DISTRIBUTION_DELETE_LIST_ENTITY[] | undefined;
}

export class DISTRIBUTION_EXECUTE_LIST_ENTITY implements IDISTRIBUTION_EXECUTE_LIST_ENTITY {
    exeC_DISTR_ID: string | undefined;
    exeC_DISTR_CODE: string | undefined;
    brancH_ID: string | undefined;
    distribution: string | undefined;
    typE_ID: string | undefined;
    requesT_NAME: string | undefined;
    reason: string | undefined;
    executE_DT: moment.Moment | undefined;
    requesT_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    notes: string | undefined;
    autH_STATUS_NAME: string | undefined;
    brancH_NAME: string | undefined;
    level: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IDISTRIBUTION_EXECUTE_LIST_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exeC_DISTR_ID = data["exeC_DISTR_ID"];
            this.exeC_DISTR_CODE = data["exeC_DISTR_CODE"];
            this.brancH_ID = data["brancH_ID"];
            this.distribution = data["distribution"];
            this.typE_ID = data["typE_ID"];
            this.requesT_NAME = data["requesT_NAME"];
            this.reason = data["reason"];
            this.executE_DT = data["executE_DT"] ? moment(data["executE_DT"].toString()) : <any>undefined;
            this.requesT_DT = data["requesT_DT"] ? moment(data["requesT_DT"].toString()) : <any>undefined;
            this.recorD_STATUS = data["recorD_STATUS"];
            this.autH_STATUS = data["autH_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.brancH_NAME = data["brancH_NAME"];
            this.level = data["level"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): DISTRIBUTION_EXECUTE_LIST_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new DISTRIBUTION_EXECUTE_LIST_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exeC_DISTR_ID"] = this.exeC_DISTR_ID;
        data["exeC_DISTR_CODE"] = this.exeC_DISTR_CODE;
        data["brancH_ID"] = this.brancH_ID;
        data["distribution"] = this.distribution;
        data["typE_ID"] = this.typE_ID;
        data["requesT_NAME"] = this.requesT_NAME;
        data["reason"] = this.reason;
        data["executE_DT"] = this.executE_DT ? this.executE_DT.toISOString() : <any>undefined;
        data["requesT_DT"] = this.requesT_DT ? this.requesT_DT.toISOString() : <any>undefined;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["autH_STATUS"] = this.autH_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["brancH_NAME"] = this.brancH_NAME;
        data["level"] = this.level;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): DISTRIBUTION_EXECUTE_LIST_ENTITY {
        const json = this.toJSON();
        let result = new DISTRIBUTION_EXECUTE_LIST_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IDISTRIBUTION_EXECUTE_LIST_ENTITY {
    exeC_DISTR_ID: string | undefined;
    exeC_DISTR_CODE: string | undefined;
    brancH_ID: string | undefined;
    distribution: string | undefined;
    typE_ID: string | undefined;
    requesT_NAME: string | undefined;
    reason: string | undefined;
    executE_DT: moment.Moment | undefined;
    requesT_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    notes: string | undefined;
    autH_STATUS_NAME: string | undefined;
    brancH_NAME: string | undefined;
    level: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfDISTRIBUTION_EXECUTE_LIST_ENTITY implements IPagedResultDtoOfDISTRIBUTION_EXECUTE_LIST_ENTITY {
    totalCount: number | undefined;
    items: DISTRIBUTION_EXECUTE_LIST_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfDISTRIBUTION_EXECUTE_LIST_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DISTRIBUTION_EXECUTE_LIST_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDISTRIBUTION_EXECUTE_LIST_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDISTRIBUTION_EXECUTE_LIST_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDISTRIBUTION_EXECUTE_LIST_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDISTRIBUTION_EXECUTE_LIST_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDISTRIBUTION_EXECUTE_LIST_ENTITY {
    totalCount: number | undefined;
    items: DISTRIBUTION_EXECUTE_LIST_ENTITY[] | undefined;
}

export class CM_DIVISION_ENTITY implements ICM_DIVISION_ENTITY {
    diV_ID: string | undefined;
    diV_CODE: string | undefined;
    diV_NAME: string | undefined;
    addr: string | undefined;
    brancH_ID: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    brancH_CODE: string | undefined;
    brancH_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    brancH_LOGIN: string | undefined;
    independenT_UNIT: boolean | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_DIVISION_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.diV_ID = data["diV_ID"];
            this.diV_CODE = data["diV_CODE"];
            this.diV_NAME = data["diV_NAME"];
            this.addr = data["addr"];
            this.brancH_ID = data["brancH_ID"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.brancH_CODE = data["brancH_CODE"];
            this.brancH_NAME = data["brancH_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.brancH_LOGIN = data["brancH_LOGIN"];
            this.independenT_UNIT = data["independenT_UNIT"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_DIVISION_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_DIVISION_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["diV_ID"] = this.diV_ID;
        data["diV_CODE"] = this.diV_CODE;
        data["diV_NAME"] = this.diV_NAME;
        data["addr"] = this.addr;
        data["brancH_ID"] = this.brancH_ID;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["brancH_CODE"] = this.brancH_CODE;
        data["brancH_NAME"] = this.brancH_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["brancH_LOGIN"] = this.brancH_LOGIN;
        data["independenT_UNIT"] = this.independenT_UNIT;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_DIVISION_ENTITY {
        const json = this.toJSON();
        let result = new CM_DIVISION_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_DIVISION_ENTITY {
    diV_ID: string | undefined;
    diV_CODE: string | undefined;
    diV_NAME: string | undefined;
    addr: string | undefined;
    brancH_ID: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    brancH_CODE: string | undefined;
    brancH_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    brancH_LOGIN: string | undefined;
    independenT_UNIT: boolean | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_DIVISION_ENTITY implements IPagedResultDtoOfCM_DIVISION_ENTITY {
    totalCount: number | undefined;
    items: CM_DIVISION_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_DIVISION_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_DIVISION_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_DIVISION_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_DIVISION_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_DIVISION_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_DIVISION_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_DIVISION_ENTITY {
    totalCount: number | undefined;
    items: CM_DIVISION_ENTITY[] | undefined;
}

export class DRColumnDto implements IDRColumnDto {
    isParent: boolean | undefined;
    isFreePane: boolean | undefined;
    isSum: boolean | undefined;
    textAlign: string | undefined;
    order: number | undefined;
    isDisplay: boolean | undefined;
    parentCode: string | undefined;
    groupLevel: number | undefined;
    width: string | undefined;
    type: string | undefined;
    format: string | undefined;
    name: string | undefined;
    code: string | undefined;
    reportId: number | undefined;
    colNum: number | undefined;
    groupSort: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IDRColumnDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isParent = data["isParent"];
            this.isFreePane = data["isFreePane"];
            this.isSum = data["isSum"];
            this.textAlign = data["textAlign"];
            this.order = data["order"];
            this.isDisplay = data["isDisplay"];
            this.parentCode = data["parentCode"];
            this.groupLevel = data["groupLevel"];
            this.width = data["width"];
            this.type = data["type"];
            this.format = data["format"];
            this.name = data["name"];
            this.code = data["code"];
            this.reportId = data["reportId"];
            this.colNum = data["colNum"];
            this.groupSort = data["groupSort"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DRColumnDto {
        data = typeof data === 'object' ? data : {};
        let result = new DRColumnDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isParent"] = this.isParent;
        data["isFreePane"] = this.isFreePane;
        data["isSum"] = this.isSum;
        data["textAlign"] = this.textAlign;
        data["order"] = this.order;
        data["isDisplay"] = this.isDisplay;
        data["parentCode"] = this.parentCode;
        data["groupLevel"] = this.groupLevel;
        data["width"] = this.width;
        data["type"] = this.type;
        data["format"] = this.format;
        data["name"] = this.name;
        data["code"] = this.code;
        data["reportId"] = this.reportId;
        data["colNum"] = this.colNum;
        data["groupSort"] = this.groupSort;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DRColumnDto {
        const json = this.toJSON();
        let result = new DRColumnDto();
        result.init(json);
        return result;
    }
}

export interface IDRColumnDto {
    isParent: boolean | undefined;
    isFreePane: boolean | undefined;
    isSum: boolean | undefined;
    textAlign: string | undefined;
    order: number | undefined;
    isDisplay: boolean | undefined;
    parentCode: string | undefined;
    groupLevel: number | undefined;
    width: string | undefined;
    type: string | undefined;
    format: string | undefined;
    name: string | undefined;
    code: string | undefined;
    reportId: number | undefined;
    colNum: number | undefined;
    groupSort: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class DRChartDto implements IDRChartDto {
    argumentField: string | undefined;
    seriesField: string | undefined;
    valueField: string | undefined;
    reportId: number | undefined;
    lineField: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IDRChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.argumentField = data["argumentField"];
            this.seriesField = data["seriesField"];
            this.valueField = data["valueField"];
            this.reportId = data["reportId"];
            this.lineField = data["lineField"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DRChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new DRChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentField"] = this.argumentField;
        data["seriesField"] = this.seriesField;
        data["valueField"] = this.valueField;
        data["reportId"] = this.reportId;
        data["lineField"] = this.lineField;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DRChartDto {
        const json = this.toJSON();
        let result = new DRChartDto();
        result.init(json);
        return result;
    }
}

export interface IDRChartDto {
    argumentField: string | undefined;
    seriesField: string | undefined;
    valueField: string | undefined;
    reportId: number | undefined;
    lineField: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class DRDataSourceDto implements IDRDataSourceDto {
    code: string | undefined;
    name: string | undefined;
    type: number | undefined;
    sqlType: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IDRDataSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.type = data["type"];
            this.sqlType = data["sqlType"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DRDataSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new DRDataSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["type"] = this.type;
        data["sqlType"] = this.sqlType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DRDataSourceDto {
        const json = this.toJSON();
        let result = new DRDataSourceDto();
        result.init(json);
        return result;
    }
}

export interface IDRDataSourceDto {
    code: string | undefined;
    name: string | undefined;
    type: number | undefined;
    sqlType: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class DRDataSourceDetailDto implements IDRDataSourceDetailDto {
    configId: number | undefined;
    priority: number | undefined;
    isDefault: boolean | undefined;
    host: string | undefined;
    dbName: string | undefined;
    user: string | undefined;
    password: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IDRDataSourceDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.configId = data["configId"];
            this.priority = data["priority"];
            this.isDefault = data["isDefault"];
            this.host = data["host"];
            this.dbName = data["dbName"];
            this.user = data["user"];
            this.password = data["password"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DRDataSourceDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new DRDataSourceDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["configId"] = this.configId;
        data["priority"] = this.priority;
        data["isDefault"] = this.isDefault;
        data["host"] = this.host;
        data["dbName"] = this.dbName;
        data["user"] = this.user;
        data["password"] = this.password;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DRDataSourceDetailDto {
        const json = this.toJSON();
        let result = new DRDataSourceDetailDto();
        result.init(json);
        return result;
    }
}

export interface IDRDataSourceDetailDto {
    configId: number | undefined;
    priority: number | undefined;
    isDefault: boolean | undefined;
    host: string | undefined;
    dbName: string | undefined;
    user: string | undefined;
    password: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class DRFilterDto implements IDRFilterDto {
    orderId: number | undefined;
    version: number | undefined;
    format: string | undefined;
    width: string | undefined;
    required: boolean | undefined;
    disable: boolean | undefined;
    seviceId: number | undefined;
    isActive: boolean | undefined;
    lookupId: number | undefined;
    code: string | undefined;
    parentComboId: number | undefined;
    comboLevel: number | undefined;
    name: string | undefined;
    value: string | undefined;
    dynamicFieldID: number | undefined;
    reportId: number | undefined;
    dataType: boolean | undefined;
    isValue: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IDRFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderId = data["orderId"];
            this.version = data["version"];
            this.format = data["format"];
            this.width = data["width"];
            this.required = data["required"];
            this.disable = data["disable"];
            this.seviceId = data["seviceId"];
            this.isActive = data["isActive"];
            this.lookupId = data["lookupId"];
            this.code = data["code"];
            this.parentComboId = data["parentComboId"];
            this.comboLevel = data["comboLevel"];
            this.name = data["name"];
            this.value = data["value"];
            this.dynamicFieldID = data["dynamicFieldID"];
            this.reportId = data["reportId"];
            this.dataType = data["dataType"];
            this.isValue = data["isValue"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DRFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new DRFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["version"] = this.version;
        data["format"] = this.format;
        data["width"] = this.width;
        data["required"] = this.required;
        data["disable"] = this.disable;
        data["seviceId"] = this.seviceId;
        data["isActive"] = this.isActive;
        data["lookupId"] = this.lookupId;
        data["code"] = this.code;
        data["parentComboId"] = this.parentComboId;
        data["comboLevel"] = this.comboLevel;
        data["name"] = this.name;
        data["value"] = this.value;
        data["dynamicFieldID"] = this.dynamicFieldID;
        data["reportId"] = this.reportId;
        data["dataType"] = this.dataType;
        data["isValue"] = this.isValue;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DRFilterDto {
        const json = this.toJSON();
        let result = new DRFilterDto();
        result.init(json);
        return result;
    }
}

export interface IDRFilterDto {
    orderId: number | undefined;
    version: number | undefined;
    format: string | undefined;
    width: string | undefined;
    required: boolean | undefined;
    disable: boolean | undefined;
    seviceId: number | undefined;
    isActive: boolean | undefined;
    lookupId: number | undefined;
    code: string | undefined;
    parentComboId: number | undefined;
    comboLevel: number | undefined;
    name: string | undefined;
    value: string | undefined;
    dynamicFieldID: number | undefined;
    reportId: number | undefined;
    dataType: boolean | undefined;
    isValue: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class DRLookUpDto implements IDRLookUpDto {
    code: string;
    name: string;
    isActive: boolean | undefined;
    version: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IDRLookUpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.version = data["version"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DRLookUpDto {
        data = typeof data === 'object' ? data : {};
        let result = new DRLookUpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["version"] = this.version;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DRLookUpDto {
        const json = this.toJSON();
        let result = new DRLookUpDto();
        result.init(json);
        return result;
    }
}

export interface IDRLookUpDto {
    code: string;
    name: string;
    isActive: boolean | undefined;
    version: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class DRLookupDetailDto implements IDRLookupDetailDto {
    code: string | undefined;
    name: string | undefined;
    lookupId: number | undefined;
    isDefault: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IDRLookupDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.lookupId = data["lookupId"];
            this.isDefault = data["isDefault"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DRLookupDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new DRLookupDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["lookupId"] = this.lookupId;
        data["isDefault"] = this.isDefault;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DRLookupDetailDto {
        const json = this.toJSON();
        let result = new DRLookupDetailDto();
        result.init(json);
        return result;
    }
}

export interface IDRLookupDetailDto {
    code: string | undefined;
    name: string | undefined;
    lookupId: number | undefined;
    isDefault: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class SearchInputLookup implements ISearchInputLookup {
    name: string | undefined;
    code: string | undefined;

    constructor(data?: ISearchInputLookup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.code = data["code"];
        }
    }

    static fromJS(data: any): SearchInputLookup {
        data = typeof data === 'object' ? data : {};
        let result = new SearchInputLookup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }

    clone(): SearchInputLookup {
        const json = this.toJSON();
        let result = new SearchInputLookup();
        result.init(json);
        return result;
    }
}

export interface ISearchInputLookup {
    name: string | undefined;
    code: string | undefined;
}

export class DRReportDto implements IDRReportDto {
    code: string | undefined;
    name: string | undefined;
    sqlType: boolean | undefined;
    sqlContent: string | undefined;
    groupLevel: number | undefined;
    excel: string | undefined;
    dataSourceId: number | undefined;
    layoutpFilter: string | undefined;
    displayType: number | undefined;
    isDynamicColumn: boolean | undefined;
    formID: number | undefined;
    typeGetColumn: number | undefined;
    isExportWord: boolean | undefined;
    word: string | undefined;
    subTitle: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IDRReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.sqlType = data["sqlType"];
            this.sqlContent = data["sqlContent"];
            this.groupLevel = data["groupLevel"];
            this.excel = data["excel"];
            this.dataSourceId = data["dataSourceId"];
            this.layoutpFilter = data["layoutpFilter"];
            this.displayType = data["displayType"];
            this.isDynamicColumn = data["isDynamicColumn"];
            this.formID = data["formID"];
            this.typeGetColumn = data["typeGetColumn"];
            this.isExportWord = data["isExportWord"];
            this.word = data["word"];
            this.subTitle = data["subTitle"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DRReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new DRReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["sqlType"] = this.sqlType;
        data["sqlContent"] = this.sqlContent;
        data["groupLevel"] = this.groupLevel;
        data["excel"] = this.excel;
        data["dataSourceId"] = this.dataSourceId;
        data["layoutpFilter"] = this.layoutpFilter;
        data["displayType"] = this.displayType;
        data["isDynamicColumn"] = this.isDynamicColumn;
        data["formID"] = this.formID;
        data["typeGetColumn"] = this.typeGetColumn;
        data["isExportWord"] = this.isExportWord;
        data["word"] = this.word;
        data["subTitle"] = this.subTitle;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DRReportDto {
        const json = this.toJSON();
        let result = new DRReportDto();
        result.init(json);
        return result;
    }
}

export interface IDRReportDto {
    code: string | undefined;
    name: string | undefined;
    sqlType: boolean | undefined;
    sqlContent: string | undefined;
    groupLevel: number | undefined;
    excel: string | undefined;
    dataSourceId: number | undefined;
    layoutpFilter: string | undefined;
    displayType: number | undefined;
    isDynamicColumn: boolean | undefined;
    formID: number | undefined;
    typeGetColumn: number | undefined;
    isExportWord: boolean | undefined;
    word: string | undefined;
    subTitle: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class SearchInput implements ISearchInput {
    name: string | undefined;
    code: string | undefined;

    constructor(data?: ISearchInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.code = data["code"];
        }
    }

    static fromJS(data: any): SearchInput {
        data = typeof data === 'object' ? data : {};
        let result = new SearchInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }

    clone(): SearchInput {
        const json = this.toJSON();
        let result = new SearchInput();
        result.init(json);
        return result;
    }
}

export interface ISearchInput {
    name: string | undefined;
    code: string | undefined;
}

export class Parameter implements IParameter {
    variable: string | undefined;
    value: any | undefined;

    constructor(data?: IParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.variable = data["variable"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): Parameter {
        data = typeof data === 'object' ? data : {};
        let result = new Parameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["variable"] = this.variable;
        data["value"] = this.value;
        return data; 
    }

    clone(): Parameter {
        const json = this.toJSON();
        let result = new Parameter();
        result.init(json);
        return result;
    }
}

export interface IParameter {
    variable: string | undefined;
    value: any | undefined;
}

export class IFormFile implements IIFormFile {
    contentType: string | undefined;
    contentDisposition: string | undefined;
    headers: { [key: string] : string[]; } | undefined;
    length: number | undefined;
    name: string | undefined;
    fileName: string | undefined;

    constructor(data?: IIFormFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentType = data["contentType"];
            this.contentDisposition = data["contentDisposition"];
            if (data["headers"]) {
                this.headers = {};
                for (let key in data["headers"]) {
                    if (data["headers"].hasOwnProperty(key))
                        this.headers[key] = data["headers"][key] !== undefined ? data["headers"][key] : [];
                }
            }
            this.length = data["length"];
            this.name = data["name"];
            this.fileName = data["fileName"];
        }
    }

    static fromJS(data: any): IFormFile {
        data = typeof data === 'object' ? data : {};
        let result = new IFormFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentType"] = this.contentType;
        data["contentDisposition"] = this.contentDisposition;
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    data["headers"][key] = this.headers[key];
            }
        }
        data["length"] = this.length;
        data["name"] = this.name;
        data["fileName"] = this.fileName;
        return data; 
    }

    clone(): IFormFile {
        const json = this.toJSON();
        let result = new IFormFile();
        result.init(json);
        return result;
    }
}

export interface IIFormFile {
    contentType: string | undefined;
    contentDisposition: string | undefined;
    headers: { [key: string] : string[]; } | undefined;
    length: number | undefined;
    name: string | undefined;
    fileName: string | undefined;
}

export class DRServiceDto implements IDRServiceDto {
    code: string | undefined;
    name: string | undefined;
    dataSourceId: number | undefined;
    sqlType: boolean | undefined;
    sqlContent: string | undefined;
    colValue: string | undefined;
    colDisplay: string | undefined;
    colParent: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IDRServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.dataSourceId = data["dataSourceId"];
            this.sqlType = data["sqlType"];
            this.sqlContent = data["sqlContent"];
            this.colValue = data["colValue"];
            this.colDisplay = data["colDisplay"];
            this.colParent = data["colParent"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DRServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new DRServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["dataSourceId"] = this.dataSourceId;
        data["sqlType"] = this.sqlType;
        data["sqlContent"] = this.sqlContent;
        data["colValue"] = this.colValue;
        data["colDisplay"] = this.colDisplay;
        data["colParent"] = this.colParent;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DRServiceDto {
        const json = this.toJSON();
        let result = new DRServiceDto();
        result.init(json);
        return result;
    }
}

export interface IDRServiceDto {
    code: string | undefined;
    name: string | undefined;
    dataSourceId: number | undefined;
    sqlType: boolean | undefined;
    sqlContent: string | undefined;
    colValue: string | undefined;
    colDisplay: string | undefined;
    colParent: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class CM_DYNAMIC_CATEGORY_ENTITY implements ICM_DYNAMIC_CATEGORY_ENTITY {
    id: number | undefined;
    cdname: string | undefined;
    categorY_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_DYNAMIC_CATEGORY_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cdname = data["cdname"];
            this.categorY_NAME = data["categorY_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_DYNAMIC_CATEGORY_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_DYNAMIC_CATEGORY_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cdname"] = this.cdname;
        data["categorY_NAME"] = this.categorY_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_DYNAMIC_CATEGORY_ENTITY {
        const json = this.toJSON();
        let result = new CM_DYNAMIC_CATEGORY_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_DYNAMIC_CATEGORY_ENTITY {
    id: number | undefined;
    cdname: string | undefined;
    categorY_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_DYNAMIC_CATEGORY_ENTITY implements IPagedResultDtoOfCM_DYNAMIC_CATEGORY_ENTITY {
    totalCount: number | undefined;
    items: CM_DYNAMIC_CATEGORY_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_DYNAMIC_CATEGORY_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_DYNAMIC_CATEGORY_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_DYNAMIC_CATEGORY_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_DYNAMIC_CATEGORY_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_DYNAMIC_CATEGORY_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_DYNAMIC_CATEGORY_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_DYNAMIC_CATEGORY_ENTITY {
    totalCount: number | undefined;
    items: CM_DYNAMIC_CATEGORY_ENTITY[] | undefined;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfEditionListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfEditionListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class EditionListDto implements IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    waitingDayAfterExpire: number | undefined;
    trialDayCount: number | undefined;
    expiringEditionDisplayName: string | undefined;
    id: number | undefined;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.trialDayCount = data["trialDayCount"];
            this.expiringEditionDisplayName = data["expiringEditionDisplayName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["trialDayCount"] = this.trialDayCount;
        data["expiringEditionDisplayName"] = this.expiringEditionDisplayName;
        data["id"] = this.id;
        return data; 
    }

    clone(): EditionListDto {
        const json = this.toJSON();
        let result = new EditionListDto();
        result.init(json);
        return result;
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    waitingDayAfterExpire: number | undefined;
    trialDayCount: number | undefined;
    expiringEditionDisplayName: string | undefined;
    id: number | undefined;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition: EditionEditDto | undefined;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetEditionEditOutput {
        const json = this.toJSON();
        let result = new GetEditionEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto | undefined;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id: number | undefined;
    displayName: string;
    expiringEditionId: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }

    clone(): EditionEditDto {
        const json = this.toJSON();
        let result = new EditionEditDto();
        result.init(json);
        return result;
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    expiringEditionId: number | undefined;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto | undefined;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? FeatureInputTypeDto.fromJS(data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }

    clone(): FlatFeatureDto {
        const json = this.toJSON();
        let result = new FlatFeatureDto();
        result.init(json);
        return result;
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
    itemSource: LocalizableComboboxItemSourceDto | undefined;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
            this.itemSource = data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }

    clone(): FeatureInputTypeDto {
        const json = this.toJSON();
        let result = new FeatureInputTypeDto();
        result.init(json);
        return result;
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
    itemSource: LocalizableComboboxItemSourceDto | undefined;
}

export class IValueValidator implements IIValueValidator {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data; 
    }

    clone(): IValueValidator {
        const json = this.toJSON();
        let result = new IValueValidator();
        result.init(json);
        return result;
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): LocalizableComboboxItemSourceDto {
        const json = this.toJSON();
        let result = new LocalizableComboboxItemSourceDto();
        result.init(json);
        return result;
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }

    clone(): LocalizableComboboxItemDto {
        const json = this.toJSON();
        let result = new LocalizableComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class CreateEditionDto implements ICreateEditionDto {
    edition: EditionCreateDto;
    featureValues: NameValueDto[];

    constructor(data?: ICreateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionCreateDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionCreateDto.fromJS(data["edition"]) : new EditionCreateDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateEditionDto {
        const json = this.toJSON();
        let result = new CreateEditionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateEditionDto {
    edition: EditionCreateDto;
    featureValues: NameValueDto[];
}

export class EditionCreateDto implements IEditionCreateDto {
    id: number | undefined;
    displayName: string;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;

    constructor(data?: IEditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }

    clone(): EditionCreateDto {
        const json = this.toJSON();
        let result = new EditionCreateDto();
        result.init(json);
        return result;
    }
}

export interface IEditionCreateDto {
    id: number | undefined;
    displayName: string;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class UpdateEditionDto implements IUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];

    constructor(data?: IUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdateEditionDto {
        const json = this.toJSON();
        let result = new UpdateEditionDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number | undefined;
    targetEditionId: number | undefined;

    constructor(data?: IMoveTenantsToAnotherEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceEditionId = data["sourceEditionId"];
            this.targetEditionId = data["targetEditionId"];
        }
    }

    static fromJS(data: any): MoveTenantsToAnotherEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceEditionId"] = this.sourceEditionId;
        data["targetEditionId"] = this.targetEditionId;
        return data; 
    }

    clone(): MoveTenantsToAnotherEditionDto {
        const json = this.toJSON();
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(json);
        return result;
    }
}

export interface IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number | undefined;
    targetEditionId: number | undefined;
}

export class CM_EMPLOYEE_ENTITY implements ICM_EMPLOYEE_ENTITY {
    employeE_ID: string | undefined;
    employeE_CODE: string | undefined;
    employeE_NAME: string | undefined;
    deP_ID: string | undefined;
    functioN_ID: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    addresss: string | undefined;
    birtH_DT: moment.Moment | undefined;
    status: string | undefined;
    type: string | undefined;
    campaign: string | undefined;
    description: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    brancH_ID: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    editoR_ID: string | undefined;
    editoR_DT: moment.Moment | undefined;
    xmL_TEMP: string | undefined;
    datA_TEMP: string | undefined;
    autH_STATUS: string | undefined;
    autH_STATUS_NAME: string | undefined;
    deP_NAME: string | undefined;
    funC_NAME: string | undefined;
    staT_NAME: string | undefined;
    typE_NAME1: string | undefined;
    campaigN_NAME: string | undefined;
    brancH_NAME: string | undefined;
    level: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_EMPLOYEE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.employeE_ID = data["employeE_ID"];
            this.employeE_CODE = data["employeE_CODE"];
            this.employeE_NAME = data["employeE_NAME"];
            this.deP_ID = data["deP_ID"];
            this.functioN_ID = data["functioN_ID"];
            this.phone = data["phone"];
            this.email = data["email"];
            this.addresss = data["addresss"];
            this.birtH_DT = data["birtH_DT"] ? moment(data["birtH_DT"].toString()) : <any>undefined;
            this.status = data["status"];
            this.type = data["type"];
            this.campaign = data["campaign"];
            this.description = data["description"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.brancH_ID = data["brancH_ID"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.editoR_ID = data["editoR_ID"];
            this.editoR_DT = data["editoR_DT"] ? moment(data["editoR_DT"].toString()) : <any>undefined;
            this.xmL_TEMP = data["xmL_TEMP"];
            this.datA_TEMP = data["datA_TEMP"];
            this.autH_STATUS = data["autH_STATUS"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.deP_NAME = data["deP_NAME"];
            this.funC_NAME = data["funC_NAME"];
            this.staT_NAME = data["staT_NAME"];
            this.typE_NAME1 = data["typE_NAME1"];
            this.campaigN_NAME = data["campaigN_NAME"];
            this.brancH_NAME = data["brancH_NAME"];
            this.level = data["level"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_EMPLOYEE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_EMPLOYEE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeE_ID"] = this.employeE_ID;
        data["employeE_CODE"] = this.employeE_CODE;
        data["employeE_NAME"] = this.employeE_NAME;
        data["deP_ID"] = this.deP_ID;
        data["functioN_ID"] = this.functioN_ID;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["addresss"] = this.addresss;
        data["birtH_DT"] = this.birtH_DT ? this.birtH_DT.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["type"] = this.type;
        data["campaign"] = this.campaign;
        data["description"] = this.description;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["brancH_ID"] = this.brancH_ID;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["editoR_ID"] = this.editoR_ID;
        data["editoR_DT"] = this.editoR_DT ? this.editoR_DT.toISOString() : <any>undefined;
        data["xmL_TEMP"] = this.xmL_TEMP;
        data["datA_TEMP"] = this.datA_TEMP;
        data["autH_STATUS"] = this.autH_STATUS;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["deP_NAME"] = this.deP_NAME;
        data["funC_NAME"] = this.funC_NAME;
        data["staT_NAME"] = this.staT_NAME;
        data["typE_NAME1"] = this.typE_NAME1;
        data["campaigN_NAME"] = this.campaigN_NAME;
        data["brancH_NAME"] = this.brancH_NAME;
        data["level"] = this.level;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_EMPLOYEE_ENTITY {
        const json = this.toJSON();
        let result = new CM_EMPLOYEE_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_EMPLOYEE_ENTITY {
    employeE_ID: string | undefined;
    employeE_CODE: string | undefined;
    employeE_NAME: string | undefined;
    deP_ID: string | undefined;
    functioN_ID: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    addresss: string | undefined;
    birtH_DT: moment.Moment | undefined;
    status: string | undefined;
    type: string | undefined;
    campaign: string | undefined;
    description: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    brancH_ID: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    editoR_ID: string | undefined;
    editoR_DT: moment.Moment | undefined;
    xmL_TEMP: string | undefined;
    datA_TEMP: string | undefined;
    autH_STATUS: string | undefined;
    autH_STATUS_NAME: string | undefined;
    deP_NAME: string | undefined;
    funC_NAME: string | undefined;
    staT_NAME: string | undefined;
    typE_NAME1: string | undefined;
    campaigN_NAME: string | undefined;
    brancH_NAME: string | undefined;
    level: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_EMPLOYEE_ENTITY implements IPagedResultDtoOfCM_EMPLOYEE_ENTITY {
    totalCount: number | undefined;
    items: CM_EMPLOYEE_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_EMPLOYEE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_EMPLOYEE_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_EMPLOYEE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_EMPLOYEE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_EMPLOYEE_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_EMPLOYEE_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_EMPLOYEE_ENTITY {
    totalCount: number | undefined;
    items: CM_EMPLOYEE_ENTITY[] | undefined;
}

export class MT_CAMPAIGN_ENTITY implements IMT_CAMPAIGN_ENTITY {
    campaigN_ID: string | undefined;
    campaigN_CODE: string | undefined;
    campaigN_NAME: string | undefined;
    description: string | undefined;
    starT_DT: moment.Moment | undefined;
    enD_DT: moment.Moment | undefined;
    state: string | undefined;
    expecteD_COST: number | undefined;
    actuaL_COST: number | undefined;
    employeE_ID: string | undefined;
    notes: string | undefined;
    brancH_ID: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    approvE_DT: moment.Moment | undefined;
    editoR_ID: string | undefined;
    editoR_DT: moment.Moment | undefined;
    xmL_TEMP: XElement | undefined;
    datA_TEMP: string | undefined;
    checkeR_ID: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IMT_CAMPAIGN_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.campaigN_ID = data["campaigN_ID"];
            this.campaigN_CODE = data["campaigN_CODE"];
            this.campaigN_NAME = data["campaigN_NAME"];
            this.description = data["description"];
            this.starT_DT = data["starT_DT"] ? moment(data["starT_DT"].toString()) : <any>undefined;
            this.enD_DT = data["enD_DT"] ? moment(data["enD_DT"].toString()) : <any>undefined;
            this.state = data["state"];
            this.expecteD_COST = data["expecteD_COST"];
            this.actuaL_COST = data["actuaL_COST"];
            this.employeE_ID = data["employeE_ID"];
            this.notes = data["notes"];
            this.brancH_ID = data["brancH_ID"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.editoR_ID = data["editoR_ID"];
            this.editoR_DT = data["editoR_DT"] ? moment(data["editoR_DT"].toString()) : <any>undefined;
            this.xmL_TEMP = data["xmL_TEMP"] ? XElement.fromJS(data["xmL_TEMP"]) : <any>undefined;
            this.datA_TEMP = data["datA_TEMP"];
            this.checkeR_ID = data["checkeR_ID"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): MT_CAMPAIGN_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new MT_CAMPAIGN_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campaigN_ID"] = this.campaigN_ID;
        data["campaigN_CODE"] = this.campaigN_CODE;
        data["campaigN_NAME"] = this.campaigN_NAME;
        data["description"] = this.description;
        data["starT_DT"] = this.starT_DT ? this.starT_DT.toISOString() : <any>undefined;
        data["enD_DT"] = this.enD_DT ? this.enD_DT.toISOString() : <any>undefined;
        data["state"] = this.state;
        data["expecteD_COST"] = this.expecteD_COST;
        data["actuaL_COST"] = this.actuaL_COST;
        data["employeE_ID"] = this.employeE_ID;
        data["notes"] = this.notes;
        data["brancH_ID"] = this.brancH_ID;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["editoR_ID"] = this.editoR_ID;
        data["editoR_DT"] = this.editoR_DT ? this.editoR_DT.toISOString() : <any>undefined;
        data["xmL_TEMP"] = this.xmL_TEMP ? this.xmL_TEMP.toJSON() : <any>undefined;
        data["datA_TEMP"] = this.datA_TEMP;
        data["checkeR_ID"] = this.checkeR_ID;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): MT_CAMPAIGN_ENTITY {
        const json = this.toJSON();
        let result = new MT_CAMPAIGN_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IMT_CAMPAIGN_ENTITY {
    campaigN_ID: string | undefined;
    campaigN_CODE: string | undefined;
    campaigN_NAME: string | undefined;
    description: string | undefined;
    starT_DT: moment.Moment | undefined;
    enD_DT: moment.Moment | undefined;
    state: string | undefined;
    expecteD_COST: number | undefined;
    actuaL_COST: number | undefined;
    employeE_ID: string | undefined;
    notes: string | undefined;
    brancH_ID: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    approvE_DT: moment.Moment | undefined;
    editoR_ID: string | undefined;
    editoR_DT: moment.Moment | undefined;
    xmL_TEMP: XElement | undefined;
    datA_TEMP: string | undefined;
    checkeR_ID: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class XElement implements IXElement {
    firstAttribute: XAttribute | undefined;
    hasAttributes: boolean | undefined;
    hasElements: boolean | undefined;
    isEmpty: boolean | undefined;
    lastAttribute: XAttribute | undefined;
    name: XName | undefined;
    nodeType: XmlNodeType | undefined;
    value: string | undefined;
    firstNode: XNode | undefined;
    lastNode: XNode | undefined;
    nextNode: XNode | undefined;
    previousNode: XNode | undefined;
    baseUri: string | undefined;
    document: XDocument | undefined;
    parent: XElement | undefined;

    constructor(data?: IXElement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstAttribute = data["firstAttribute"] ? XAttribute.fromJS(data["firstAttribute"]) : <any>undefined;
            this.hasAttributes = data["hasAttributes"];
            this.hasElements = data["hasElements"];
            this.isEmpty = data["isEmpty"];
            this.lastAttribute = data["lastAttribute"] ? XAttribute.fromJS(data["lastAttribute"]) : <any>undefined;
            this.name = data["name"] ? XName.fromJS(data["name"]) : <any>undefined;
            this.nodeType = data["nodeType"];
            this.value = data["value"];
            this.firstNode = data["firstNode"] ? XNode.fromJS(data["firstNode"]) : <any>undefined;
            this.lastNode = data["lastNode"] ? XNode.fromJS(data["lastNode"]) : <any>undefined;
            this.nextNode = data["nextNode"] ? XNode.fromJS(data["nextNode"]) : <any>undefined;
            this.previousNode = data["previousNode"] ? XNode.fromJS(data["previousNode"]) : <any>undefined;
            this.baseUri = data["baseUri"];
            this.document = data["document"] ? XDocument.fromJS(data["document"]) : <any>undefined;
            this.parent = data["parent"] ? XElement.fromJS(data["parent"]) : <any>undefined;
        }
    }

    static fromJS(data: any): XElement {
        data = typeof data === 'object' ? data : {};
        let result = new XElement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstAttribute"] = this.firstAttribute ? this.firstAttribute.toJSON() : <any>undefined;
        data["hasAttributes"] = this.hasAttributes;
        data["hasElements"] = this.hasElements;
        data["isEmpty"] = this.isEmpty;
        data["lastAttribute"] = this.lastAttribute ? this.lastAttribute.toJSON() : <any>undefined;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["nodeType"] = this.nodeType;
        data["value"] = this.value;
        data["firstNode"] = this.firstNode ? this.firstNode.toJSON() : <any>undefined;
        data["lastNode"] = this.lastNode ? this.lastNode.toJSON() : <any>undefined;
        data["nextNode"] = this.nextNode ? this.nextNode.toJSON() : <any>undefined;
        data["previousNode"] = this.previousNode ? this.previousNode.toJSON() : <any>undefined;
        data["baseUri"] = this.baseUri;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        return data; 
    }

    clone(): XElement {
        const json = this.toJSON();
        let result = new XElement();
        result.init(json);
        return result;
    }
}

export interface IXElement {
    firstAttribute: XAttribute | undefined;
    hasAttributes: boolean | undefined;
    hasElements: boolean | undefined;
    isEmpty: boolean | undefined;
    lastAttribute: XAttribute | undefined;
    name: XName | undefined;
    nodeType: XmlNodeType | undefined;
    value: string | undefined;
    firstNode: XNode | undefined;
    lastNode: XNode | undefined;
    nextNode: XNode | undefined;
    previousNode: XNode | undefined;
    baseUri: string | undefined;
    document: XDocument | undefined;
    parent: XElement | undefined;
}

export class XAttribute implements IXAttribute {
    isNamespaceDeclaration: boolean | undefined;
    name: XName | undefined;
    nextAttribute: XAttribute | undefined;
    nodeType: XmlNodeType | undefined;
    previousAttribute: XAttribute | undefined;
    value: string | undefined;
    baseUri: string | undefined;
    document: XDocument | undefined;
    parent: XElement | undefined;

    constructor(data?: IXAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isNamespaceDeclaration = data["isNamespaceDeclaration"];
            this.name = data["name"] ? XName.fromJS(data["name"]) : <any>undefined;
            this.nextAttribute = data["nextAttribute"] ? XAttribute.fromJS(data["nextAttribute"]) : <any>undefined;
            this.nodeType = data["nodeType"];
            this.previousAttribute = data["previousAttribute"] ? XAttribute.fromJS(data["previousAttribute"]) : <any>undefined;
            this.value = data["value"];
            this.baseUri = data["baseUri"];
            this.document = data["document"] ? XDocument.fromJS(data["document"]) : <any>undefined;
            this.parent = data["parent"] ? XElement.fromJS(data["parent"]) : <any>undefined;
        }
    }

    static fromJS(data: any): XAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new XAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isNamespaceDeclaration"] = this.isNamespaceDeclaration;
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        data["nextAttribute"] = this.nextAttribute ? this.nextAttribute.toJSON() : <any>undefined;
        data["nodeType"] = this.nodeType;
        data["previousAttribute"] = this.previousAttribute ? this.previousAttribute.toJSON() : <any>undefined;
        data["value"] = this.value;
        data["baseUri"] = this.baseUri;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        return data; 
    }

    clone(): XAttribute {
        const json = this.toJSON();
        let result = new XAttribute();
        result.init(json);
        return result;
    }
}

export interface IXAttribute {
    isNamespaceDeclaration: boolean | undefined;
    name: XName | undefined;
    nextAttribute: XAttribute | undefined;
    nodeType: XmlNodeType | undefined;
    previousAttribute: XAttribute | undefined;
    value: string | undefined;
    baseUri: string | undefined;
    document: XDocument | undefined;
    parent: XElement | undefined;
}

export class XName implements IXName {
    localName: string | undefined;
    namespace: XNamespace | undefined;
    namespaceName: string | undefined;

    constructor(data?: IXName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.localName = data["localName"];
            this.namespace = data["namespace"] ? XNamespace.fromJS(data["namespace"]) : <any>undefined;
            this.namespaceName = data["namespaceName"];
        }
    }

    static fromJS(data: any): XName {
        data = typeof data === 'object' ? data : {};
        let result = new XName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localName"] = this.localName;
        data["namespace"] = this.namespace ? this.namespace.toJSON() : <any>undefined;
        data["namespaceName"] = this.namespaceName;
        return data; 
    }

    clone(): XName {
        const json = this.toJSON();
        let result = new XName();
        result.init(json);
        return result;
    }
}

export interface IXName {
    localName: string | undefined;
    namespace: XNamespace | undefined;
    namespaceName: string | undefined;
}

export enum XmlNodeType {
    None = 0, 
    Element = 1, 
    Attribute = 2, 
    Text = 3, 
    CDATA = 4, 
    EntityReference = 5, 
    Entity = 6, 
    ProcessingInstruction = 7, 
    Comment = 8, 
    Document = 9, 
    DocumentType = 10, 
    DocumentFragment = 11, 
    Notation = 12, 
    Whitespace = 13, 
    SignificantWhitespace = 14, 
    EndElement = 15, 
    EndEntity = 16, 
    XmlDeclaration = 17, 
}

export class XNode implements IXNode {
    nextNode: XNode | undefined;
    previousNode: XNode | undefined;
    baseUri: string | undefined;
    document: XDocument | undefined;
    nodeType: XmlNodeType | undefined;
    parent: XElement | undefined;

    constructor(data?: IXNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.nextNode = data["nextNode"] ? XNode.fromJS(data["nextNode"]) : <any>undefined;
            this.previousNode = data["previousNode"] ? XNode.fromJS(data["previousNode"]) : <any>undefined;
            this.baseUri = data["baseUri"];
            this.document = data["document"] ? XDocument.fromJS(data["document"]) : <any>undefined;
            this.nodeType = data["nodeType"];
            this.parent = data["parent"] ? XElement.fromJS(data["parent"]) : <any>undefined;
        }
    }

    static fromJS(data: any): XNode {
        data = typeof data === 'object' ? data : {};
        let result = new XNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nextNode"] = this.nextNode ? this.nextNode.toJSON() : <any>undefined;
        data["previousNode"] = this.previousNode ? this.previousNode.toJSON() : <any>undefined;
        data["baseUri"] = this.baseUri;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        data["nodeType"] = this.nodeType;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        return data; 
    }

    clone(): XNode {
        const json = this.toJSON();
        let result = new XNode();
        result.init(json);
        return result;
    }
}

export interface IXNode {
    nextNode: XNode | undefined;
    previousNode: XNode | undefined;
    baseUri: string | undefined;
    document: XDocument | undefined;
    nodeType: XmlNodeType | undefined;
    parent: XElement | undefined;
}

export class XDocument implements IXDocument {
    declaration: XDeclaration | undefined;
    documentType: XDocumentType | undefined;
    nodeType: XmlNodeType | undefined;
    root: XElement | undefined;
    firstNode: XNode | undefined;
    lastNode: XNode | undefined;
    nextNode: XNode | undefined;
    previousNode: XNode | undefined;
    baseUri: string | undefined;
    document: XDocument | undefined;
    parent: XElement | undefined;

    constructor(data?: IXDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.declaration = data["declaration"] ? XDeclaration.fromJS(data["declaration"]) : <any>undefined;
            this.documentType = data["documentType"] ? XDocumentType.fromJS(data["documentType"]) : <any>undefined;
            this.nodeType = data["nodeType"];
            this.root = data["root"] ? XElement.fromJS(data["root"]) : <any>undefined;
            this.firstNode = data["firstNode"] ? XNode.fromJS(data["firstNode"]) : <any>undefined;
            this.lastNode = data["lastNode"] ? XNode.fromJS(data["lastNode"]) : <any>undefined;
            this.nextNode = data["nextNode"] ? XNode.fromJS(data["nextNode"]) : <any>undefined;
            this.previousNode = data["previousNode"] ? XNode.fromJS(data["previousNode"]) : <any>undefined;
            this.baseUri = data["baseUri"];
            this.document = data["document"] ? XDocument.fromJS(data["document"]) : <any>undefined;
            this.parent = data["parent"] ? XElement.fromJS(data["parent"]) : <any>undefined;
        }
    }

    static fromJS(data: any): XDocument {
        data = typeof data === 'object' ? data : {};
        let result = new XDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["declaration"] = this.declaration ? this.declaration.toJSON() : <any>undefined;
        data["documentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        data["nodeType"] = this.nodeType;
        data["root"] = this.root ? this.root.toJSON() : <any>undefined;
        data["firstNode"] = this.firstNode ? this.firstNode.toJSON() : <any>undefined;
        data["lastNode"] = this.lastNode ? this.lastNode.toJSON() : <any>undefined;
        data["nextNode"] = this.nextNode ? this.nextNode.toJSON() : <any>undefined;
        data["previousNode"] = this.previousNode ? this.previousNode.toJSON() : <any>undefined;
        data["baseUri"] = this.baseUri;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        return data; 
    }

    clone(): XDocument {
        const json = this.toJSON();
        let result = new XDocument();
        result.init(json);
        return result;
    }
}

export interface IXDocument {
    declaration: XDeclaration | undefined;
    documentType: XDocumentType | undefined;
    nodeType: XmlNodeType | undefined;
    root: XElement | undefined;
    firstNode: XNode | undefined;
    lastNode: XNode | undefined;
    nextNode: XNode | undefined;
    previousNode: XNode | undefined;
    baseUri: string | undefined;
    document: XDocument | undefined;
    parent: XElement | undefined;
}

export class XNamespace implements IXNamespace {
    namespaceName: string | undefined;

    constructor(data?: IXNamespace) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.namespaceName = data["namespaceName"];
        }
    }

    static fromJS(data: any): XNamespace {
        data = typeof data === 'object' ? data : {};
        let result = new XNamespace();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["namespaceName"] = this.namespaceName;
        return data; 
    }

    clone(): XNamespace {
        const json = this.toJSON();
        let result = new XNamespace();
        result.init(json);
        return result;
    }
}

export interface IXNamespace {
    namespaceName: string | undefined;
}

export class XDeclaration implements IXDeclaration {
    encoding: string | undefined;
    standalone: string | undefined;
    version: string | undefined;

    constructor(data?: IXDeclaration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.encoding = data["encoding"];
            this.standalone = data["standalone"];
            this.version = data["version"];
        }
    }

    static fromJS(data: any): XDeclaration {
        data = typeof data === 'object' ? data : {};
        let result = new XDeclaration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["encoding"] = this.encoding;
        data["standalone"] = this.standalone;
        data["version"] = this.version;
        return data; 
    }

    clone(): XDeclaration {
        const json = this.toJSON();
        let result = new XDeclaration();
        result.init(json);
        return result;
    }
}

export interface IXDeclaration {
    encoding: string | undefined;
    standalone: string | undefined;
    version: string | undefined;
}

export class XDocumentType implements IXDocumentType {
    internalSubset: string | undefined;
    name: string | undefined;
    nodeType: XmlNodeType | undefined;
    publicId: string | undefined;
    systemId: string | undefined;
    nextNode: XNode | undefined;
    previousNode: XNode | undefined;
    baseUri: string | undefined;
    document: XDocument | undefined;
    parent: XElement | undefined;

    constructor(data?: IXDocumentType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.internalSubset = data["internalSubset"];
            this.name = data["name"];
            this.nodeType = data["nodeType"];
            this.publicId = data["publicId"];
            this.systemId = data["systemId"];
            this.nextNode = data["nextNode"] ? XNode.fromJS(data["nextNode"]) : <any>undefined;
            this.previousNode = data["previousNode"] ? XNode.fromJS(data["previousNode"]) : <any>undefined;
            this.baseUri = data["baseUri"];
            this.document = data["document"] ? XDocument.fromJS(data["document"]) : <any>undefined;
            this.parent = data["parent"] ? XElement.fromJS(data["parent"]) : <any>undefined;
        }
    }

    static fromJS(data: any): XDocumentType {
        data = typeof data === 'object' ? data : {};
        let result = new XDocumentType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalSubset"] = this.internalSubset;
        data["name"] = this.name;
        data["nodeType"] = this.nodeType;
        data["publicId"] = this.publicId;
        data["systemId"] = this.systemId;
        data["nextNode"] = this.nextNode ? this.nextNode.toJSON() : <any>undefined;
        data["previousNode"] = this.previousNode ? this.previousNode.toJSON() : <any>undefined;
        data["baseUri"] = this.baseUri;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        return data; 
    }

    clone(): XDocumentType {
        const json = this.toJSON();
        let result = new XDocumentType();
        result.init(json);
        return result;
    }
}

export interface IXDocumentType {
    internalSubset: string | undefined;
    name: string | undefined;
    nodeType: XmlNodeType | undefined;
    publicId: string | undefined;
    systemId: string | undefined;
    nextNode: XNode | undefined;
    previousNode: XNode | undefined;
    baseUri: string | undefined;
    document: XDocument | undefined;
    parent: XElement | undefined;
}

export class PagedResultDtoOfMT_CAMPAIGN_ENTITY implements IPagedResultDtoOfMT_CAMPAIGN_ENTITY {
    totalCount: number | undefined;
    items: MT_CAMPAIGN_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfMT_CAMPAIGN_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(MT_CAMPAIGN_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMT_CAMPAIGN_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMT_CAMPAIGN_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfMT_CAMPAIGN_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfMT_CAMPAIGN_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfMT_CAMPAIGN_ENTITY {
    totalCount: number | undefined;
    items: MT_CAMPAIGN_ENTITY[] | undefined;
}

export class ExecQueryDto implements IExecQueryDto {
    content: string | undefined;

    constructor(data?: IExecQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
        }
    }

    static fromJS(data: any): ExecQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExecQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        return data; 
    }

    clone(): ExecQueryDto {
        const json = this.toJSON();
        let result = new ExecQueryDto();
        result.init(json);
        return result;
    }
}

export interface IExecQueryDto {
    content: string | undefined;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): CreateFriendshipRequestInput {
        const json = this.toJSON();
        let result = new CreateFriendshipRequestInput();
        result.init(json);
        return result;
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data; 
    }

    clone(): CreateFriendshipRequestByUserNameInput {
        const json = this.toJSON();
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(json);
        return result;
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): BlockUserInput {
        const json = this.toJSON();
        let result = new BlockUserInput();
        result.init(json);
        return result;
    }
}

export interface IBlockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): UnblockUserInput {
        const json = this.toJSON();
        let result = new UnblockUserInput();
        result.init(json);
        return result;
    }
}

export interface IUnblockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): AcceptFriendshipRequestInput {
        const json = this.toJSON();
        let result = new AcceptFriendshipRequestInput();
        result.init(json);
        return result;
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class CM_GOODS_ENTITY implements ICM_GOODS_ENTITY {
    gD_ID: string | undefined;
    gD_CODE: string | undefined;
    gD_NAME: string | undefined;
    gD_TYPE_ID: string | undefined;
    usE_BRANCH: string | undefined;
    amorT_RATE: number | undefined;
    description: string | undefined;
    suP_ID: string | undefined;
    price: number | undefined;
    uniT_ID: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    uniT_CODE: string | undefined;
    uniT_NAME: string | undefined;
    gD_TYPE_NAME: string | undefined;
    gD_TYPE_CODE: string | undefined;
    suP_CODE: string | undefined;
    suP_NAME: string | undefined;
    cD_ID: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    isChecked: boolean | undefined;
    totalCount: number | undefined;
    asS_GROUP_ID: string | undefined;
    asS_GROUP_CODE: string | undefined;
    grouP_NAME: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_GOODS_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gD_ID = data["gD_ID"];
            this.gD_CODE = data["gD_CODE"];
            this.gD_NAME = data["gD_NAME"];
            this.gD_TYPE_ID = data["gD_TYPE_ID"];
            this.usE_BRANCH = data["usE_BRANCH"];
            this.amorT_RATE = data["amorT_RATE"];
            this.description = data["description"];
            this.suP_ID = data["suP_ID"];
            this.price = data["price"];
            this.uniT_ID = data["uniT_ID"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.uniT_CODE = data["uniT_CODE"];
            this.uniT_NAME = data["uniT_NAME"];
            this.gD_TYPE_NAME = data["gD_TYPE_NAME"];
            this.gD_TYPE_CODE = data["gD_TYPE_CODE"];
            this.suP_CODE = data["suP_CODE"];
            this.suP_NAME = data["suP_NAME"];
            this.cD_ID = data["cD_ID"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.isChecked = data["isChecked"];
            this.totalCount = data["totalCount"];
            this.asS_GROUP_ID = data["asS_GROUP_ID"];
            this.asS_GROUP_CODE = data["asS_GROUP_CODE"];
            this.grouP_NAME = data["grouP_NAME"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_GOODS_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_GOODS_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gD_ID"] = this.gD_ID;
        data["gD_CODE"] = this.gD_CODE;
        data["gD_NAME"] = this.gD_NAME;
        data["gD_TYPE_ID"] = this.gD_TYPE_ID;
        data["usE_BRANCH"] = this.usE_BRANCH;
        data["amorT_RATE"] = this.amorT_RATE;
        data["description"] = this.description;
        data["suP_ID"] = this.suP_ID;
        data["price"] = this.price;
        data["uniT_ID"] = this.uniT_ID;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["uniT_CODE"] = this.uniT_CODE;
        data["uniT_NAME"] = this.uniT_NAME;
        data["gD_TYPE_NAME"] = this.gD_TYPE_NAME;
        data["gD_TYPE_CODE"] = this.gD_TYPE_CODE;
        data["suP_CODE"] = this.suP_CODE;
        data["suP_NAME"] = this.suP_NAME;
        data["cD_ID"] = this.cD_ID;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["isChecked"] = this.isChecked;
        data["totalCount"] = this.totalCount;
        data["asS_GROUP_ID"] = this.asS_GROUP_ID;
        data["asS_GROUP_CODE"] = this.asS_GROUP_CODE;
        data["grouP_NAME"] = this.grouP_NAME;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_GOODS_ENTITY {
        const json = this.toJSON();
        let result = new CM_GOODS_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_GOODS_ENTITY {
    gD_ID: string | undefined;
    gD_CODE: string | undefined;
    gD_NAME: string | undefined;
    gD_TYPE_ID: string | undefined;
    usE_BRANCH: string | undefined;
    amorT_RATE: number | undefined;
    description: string | undefined;
    suP_ID: string | undefined;
    price: number | undefined;
    uniT_ID: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    uniT_CODE: string | undefined;
    uniT_NAME: string | undefined;
    gD_TYPE_NAME: string | undefined;
    gD_TYPE_CODE: string | undefined;
    suP_CODE: string | undefined;
    suP_NAME: string | undefined;
    cD_ID: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    isChecked: boolean | undefined;
    totalCount: number | undefined;
    asS_GROUP_ID: string | undefined;
    asS_GROUP_CODE: string | undefined;
    grouP_NAME: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_GOODS_ENTITY implements IPagedResultDtoOfCM_GOODS_ENTITY {
    totalCount: number | undefined;
    items: CM_GOODS_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_GOODS_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_GOODS_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_GOODS_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_GOODS_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_GOODS_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_GOODS_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_GOODS_ENTITY {
    totalCount: number | undefined;
    items: CM_GOODS_ENTITY[] | undefined;
}

export class CM_GOODSTYPE_ENTITY implements ICM_GOODSTYPE_ENTITY {
    gD_TYPE_ID: string | undefined;
    gD_TYPE_CODE: string | undefined;
    gD_TYPE_NAME: string | undefined;
    asS_TYPE_ID: string | undefined;
    parenT_ID: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    asS_TYPE_NAME: string | undefined;
    parenT_NAME: string | undefined;
    asS_TYPE_CODE: string | undefined;
    parenT_CODE: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_GOODSTYPE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gD_TYPE_ID = data["gD_TYPE_ID"];
            this.gD_TYPE_CODE = data["gD_TYPE_CODE"];
            this.gD_TYPE_NAME = data["gD_TYPE_NAME"];
            this.asS_TYPE_ID = data["asS_TYPE_ID"];
            this.parenT_ID = data["parenT_ID"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.asS_TYPE_NAME = data["asS_TYPE_NAME"];
            this.parenT_NAME = data["parenT_NAME"];
            this.asS_TYPE_CODE = data["asS_TYPE_CODE"];
            this.parenT_CODE = data["parenT_CODE"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_GOODSTYPE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_GOODSTYPE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gD_TYPE_ID"] = this.gD_TYPE_ID;
        data["gD_TYPE_CODE"] = this.gD_TYPE_CODE;
        data["gD_TYPE_NAME"] = this.gD_TYPE_NAME;
        data["asS_TYPE_ID"] = this.asS_TYPE_ID;
        data["parenT_ID"] = this.parenT_ID;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["asS_TYPE_NAME"] = this.asS_TYPE_NAME;
        data["parenT_NAME"] = this.parenT_NAME;
        data["asS_TYPE_CODE"] = this.asS_TYPE_CODE;
        data["parenT_CODE"] = this.parenT_CODE;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_GOODSTYPE_ENTITY {
        const json = this.toJSON();
        let result = new CM_GOODSTYPE_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_GOODSTYPE_ENTITY {
    gD_TYPE_ID: string | undefined;
    gD_TYPE_CODE: string | undefined;
    gD_TYPE_NAME: string | undefined;
    asS_TYPE_ID: string | undefined;
    parenT_ID: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    asS_TYPE_NAME: string | undefined;
    parenT_NAME: string | undefined;
    asS_TYPE_CODE: string | undefined;
    parenT_CODE: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_GOODSTYPE_ENTITY implements IPagedResultDtoOfCM_GOODSTYPE_ENTITY {
    totalCount: number | undefined;
    items: CM_GOODSTYPE_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_GOODSTYPE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_GOODSTYPE_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_GOODSTYPE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_GOODSTYPE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_GOODSTYPE_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_GOODSTYPE_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_GOODSTYPE_ENTITY {
    totalCount: number | undefined;
    items: CM_GOODSTYPE_ENTITY[] | undefined;
}

export class CM_GOODSTYPE_REAL_ENTITY implements ICM_GOODSTYPE_REAL_ENTITY {
    gD_RETYPE_ID: string | undefined;
    gD_RETYPE_CODE: string | undefined;
    typE_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_GOODSTYPE_REAL_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gD_RETYPE_ID = data["gD_RETYPE_ID"];
            this.gD_RETYPE_CODE = data["gD_RETYPE_CODE"];
            this.typE_NAME = data["typE_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_GOODSTYPE_REAL_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_GOODSTYPE_REAL_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gD_RETYPE_ID"] = this.gD_RETYPE_ID;
        data["gD_RETYPE_CODE"] = this.gD_RETYPE_CODE;
        data["typE_NAME"] = this.typE_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_GOODSTYPE_REAL_ENTITY {
        const json = this.toJSON();
        let result = new CM_GOODSTYPE_REAL_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_GOODSTYPE_REAL_ENTITY {
    gD_RETYPE_ID: string | undefined;
    gD_RETYPE_CODE: string | undefined;
    typE_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY implements IPagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY {
    totalCount: number | undefined;
    items: CM_GOODSTYPE_REAL_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_GOODSTYPE_REAL_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY {
    totalCount: number | undefined;
    items: CM_GOODSTYPE_REAL_ENTITY[] | undefined;
}

export class HR_HopDong_ENTITY implements IHR_HopDong_ENTITY {
    soHopDong_Id: string | undefined;
    hopDong_Ten: string | undefined;
    loaiHopDong_Id: string | undefined;
    thoiHanHopDong_Id: string | undefined;
    nhanVien_Id: string | undefined;
    nhanVien_Ten: string | undefined;
    hinhThucLamViec_ID: string | undefined;
    congTy_Id: string | undefined;
    donViCongTac_Id: string | undefined;
    viTriCongViec_Id: string | undefined;
    luongCoBan: string | undefined;
    ngayKy: moment.Moment | undefined;
    ngayCoHieuLuc: moment.Moment | undefined;
    ngayHetHan: moment.Moment | undefined;
    nguoiDaiDien_Cty: string | undefined;
    chucDanh: string | undefined;
    ghiChu: string | undefined;
    isDeleted: string | undefined;
    record_Status: string | undefined;
    maker_Id: string | undefined;
    create_Dt: moment.Moment | undefined;
    update_Dt: moment.Moment | undefined;
    auth_Status: string | undefined;
    checker_Id: string | undefined;
    approve_Dt: moment.Moment | undefined;
    tenant_Id: string | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    ngayKy_Start: moment.Moment | undefined;
    ngayKy_END: moment.Moment | undefined;
    hinhThucLamViec: string | undefined;
    loaiHopDong: string | undefined;
    donViCongTac: string | undefined;
    viTriCongViec: string | undefined;
    congTy: string | undefined;
    tenHopDong: string | undefined;
    hoSo_Id: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IHR_HopDong_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.soHopDong_Id = data["soHopDong_Id"];
            this.hopDong_Ten = data["hopDong_Ten"];
            this.loaiHopDong_Id = data["loaiHopDong_Id"];
            this.thoiHanHopDong_Id = data["thoiHanHopDong_Id"];
            this.nhanVien_Id = data["nhanVien_Id"];
            this.nhanVien_Ten = data["nhanVien_Ten"];
            this.hinhThucLamViec_ID = data["hinhThucLamViec_ID"];
            this.congTy_Id = data["congTy_Id"];
            this.donViCongTac_Id = data["donViCongTac_Id"];
            this.viTriCongViec_Id = data["viTriCongViec_Id"];
            this.luongCoBan = data["luongCoBan"];
            this.ngayKy = data["ngayKy"] ? moment(data["ngayKy"].toString()) : <any>undefined;
            this.ngayCoHieuLuc = data["ngayCoHieuLuc"] ? moment(data["ngayCoHieuLuc"].toString()) : <any>undefined;
            this.ngayHetHan = data["ngayHetHan"] ? moment(data["ngayHetHan"].toString()) : <any>undefined;
            this.nguoiDaiDien_Cty = data["nguoiDaiDien_Cty"];
            this.chucDanh = data["chucDanh"];
            this.ghiChu = data["ghiChu"];
            this.isDeleted = data["isDeleted"];
            this.record_Status = data["record_Status"];
            this.maker_Id = data["maker_Id"];
            this.create_Dt = data["create_Dt"] ? moment(data["create_Dt"].toString()) : <any>undefined;
            this.update_Dt = data["update_Dt"] ? moment(data["update_Dt"].toString()) : <any>undefined;
            this.auth_Status = data["auth_Status"];
            this.checker_Id = data["checker_Id"];
            this.approve_Dt = data["approve_Dt"] ? moment(data["approve_Dt"].toString()) : <any>undefined;
            this.tenant_Id = data["tenant_Id"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.ngayKy_Start = data["ngayKy_Start"] ? moment(data["ngayKy_Start"].toString()) : <any>undefined;
            this.ngayKy_END = data["ngayKy_END"] ? moment(data["ngayKy_END"].toString()) : <any>undefined;
            this.hinhThucLamViec = data["hinhThucLamViec"];
            this.loaiHopDong = data["loaiHopDong"];
            this.donViCongTac = data["donViCongTac"];
            this.viTriCongViec = data["viTriCongViec"];
            this.congTy = data["congTy"];
            this.tenHopDong = data["tenHopDong"];
            this.hoSo_Id = data["hoSo_Id"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): HR_HopDong_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HR_HopDong_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["soHopDong_Id"] = this.soHopDong_Id;
        data["hopDong_Ten"] = this.hopDong_Ten;
        data["loaiHopDong_Id"] = this.loaiHopDong_Id;
        data["thoiHanHopDong_Id"] = this.thoiHanHopDong_Id;
        data["nhanVien_Id"] = this.nhanVien_Id;
        data["nhanVien_Ten"] = this.nhanVien_Ten;
        data["hinhThucLamViec_ID"] = this.hinhThucLamViec_ID;
        data["congTy_Id"] = this.congTy_Id;
        data["donViCongTac_Id"] = this.donViCongTac_Id;
        data["viTriCongViec_Id"] = this.viTriCongViec_Id;
        data["luongCoBan"] = this.luongCoBan;
        data["ngayKy"] = this.ngayKy ? this.ngayKy.toISOString() : <any>undefined;
        data["ngayCoHieuLuc"] = this.ngayCoHieuLuc ? this.ngayCoHieuLuc.toISOString() : <any>undefined;
        data["ngayHetHan"] = this.ngayHetHan ? this.ngayHetHan.toISOString() : <any>undefined;
        data["nguoiDaiDien_Cty"] = this.nguoiDaiDien_Cty;
        data["chucDanh"] = this.chucDanh;
        data["ghiChu"] = this.ghiChu;
        data["isDeleted"] = this.isDeleted;
        data["record_Status"] = this.record_Status;
        data["maker_Id"] = this.maker_Id;
        data["create_Dt"] = this.create_Dt ? this.create_Dt.toISOString() : <any>undefined;
        data["update_Dt"] = this.update_Dt ? this.update_Dt.toISOString() : <any>undefined;
        data["auth_Status"] = this.auth_Status;
        data["checker_Id"] = this.checker_Id;
        data["approve_Dt"] = this.approve_Dt ? this.approve_Dt.toISOString() : <any>undefined;
        data["tenant_Id"] = this.tenant_Id;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["ngayKy_Start"] = this.ngayKy_Start ? this.ngayKy_Start.toISOString() : <any>undefined;
        data["ngayKy_END"] = this.ngayKy_END ? this.ngayKy_END.toISOString() : <any>undefined;
        data["hinhThucLamViec"] = this.hinhThucLamViec;
        data["loaiHopDong"] = this.loaiHopDong;
        data["donViCongTac"] = this.donViCongTac;
        data["viTriCongViec"] = this.viTriCongViec;
        data["congTy"] = this.congTy;
        data["tenHopDong"] = this.tenHopDong;
        data["hoSo_Id"] = this.hoSo_Id;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): HR_HopDong_ENTITY {
        const json = this.toJSON();
        let result = new HR_HopDong_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHR_HopDong_ENTITY {
    soHopDong_Id: string | undefined;
    hopDong_Ten: string | undefined;
    loaiHopDong_Id: string | undefined;
    thoiHanHopDong_Id: string | undefined;
    nhanVien_Id: string | undefined;
    nhanVien_Ten: string | undefined;
    hinhThucLamViec_ID: string | undefined;
    congTy_Id: string | undefined;
    donViCongTac_Id: string | undefined;
    viTriCongViec_Id: string | undefined;
    luongCoBan: string | undefined;
    ngayKy: moment.Moment | undefined;
    ngayCoHieuLuc: moment.Moment | undefined;
    ngayHetHan: moment.Moment | undefined;
    nguoiDaiDien_Cty: string | undefined;
    chucDanh: string | undefined;
    ghiChu: string | undefined;
    isDeleted: string | undefined;
    record_Status: string | undefined;
    maker_Id: string | undefined;
    create_Dt: moment.Moment | undefined;
    update_Dt: moment.Moment | undefined;
    auth_Status: string | undefined;
    checker_Id: string | undefined;
    approve_Dt: moment.Moment | undefined;
    tenant_Id: string | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    ngayKy_Start: moment.Moment | undefined;
    ngayKy_END: moment.Moment | undefined;
    hinhThucLamViec: string | undefined;
    loaiHopDong: string | undefined;
    donViCongTac: string | undefined;
    viTriCongViec: string | undefined;
    congTy: string | undefined;
    tenHopDong: string | undefined;
    hoSo_Id: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfHR_HopDong_ENTITY implements IPagedResultDtoOfHR_HopDong_ENTITY {
    totalCount: number | undefined;
    items: HR_HopDong_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfHR_HopDong_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(HR_HopDong_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfHR_HopDong_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfHR_HopDong_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfHR_HopDong_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfHR_HopDong_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfHR_HopDong_ENTITY {
    totalCount: number | undefined;
    items: HR_HopDong_ENTITY[] | undefined;
}

export class HR_Hoso_ENTITY implements IHR_Hoso_ENTITY {
    maHoSo: string | undefined;
    maNhanVien: string | undefined;
    hoVaTen: string | undefined;
    trinhDoVanHoa: string | undefined;
    trinhDoDaoTao_Code: string | undefined;
    khoa: string | undefined;
    namTotNghiep: number | undefined;
    tepDinhKem: string | undefined;
    dtDiDong: string | undefined;
    dtCoQuan: string | undefined;
    dtNhaRieng: string | undefined;
    dtKhac: string | undefined;
    emailCaNhan: string | undefined;
    emailCoQuan: string | undefined;
    emailKhac: string | undefined;
    nguyenQuan: string | undefined;
    tinhThanh_Id: string | undefined;
    noiSinh: string | undefined;
    skyPe: string | undefined;
    faceBook: string | undefined;
    quocGiahktt: string | undefined;
    diaChihktt: string | undefined;
    soSoHoKhau: string | undefined;
    soHoGiaDinh_Code: string | undefined;
    quocGiaHienNay: string | undefined;
    diaChiHienNay: string | undefined;
    hoVaTenlhkc: string | undefined;
    quanHelhkc: string | undefined;
    dtDiDonglhkc: string | undefined;
    dtNhaRienglhkc: string | undefined;
    emaillhkc: string | undefined;
    diaChilhkc: string | undefined;
    chamCong_Id: string | undefined;
    chucDanh: string | undefined;
    cap: string | undefined;
    trangThaiLamViec_Code: string | undefined;
    quanLyTrucTiep_Id: string | undefined;
    quanlyGianTiep_Id: string | undefined;
    diaDiemLamViec_Code: string | undefined;
    soSoqllaodong: string | undefined;
    ngayTapSu: moment.Moment | undefined;
    ngayThuViec: moment.Moment | undefined;
    ngayNghiViec: moment.Moment | undefined;
    ngayChinhThuc: moment.Moment | undefined;
    soNgayPhep: number | undefined;
    bacLuong_Code: string | undefined;
    luongDongbh: string | undefined;
    soCongChuan: string | undefined;
    donViSoCongChuan_Code: string | undefined;
    tkNganHang: string | undefined;
    thamGiaCongDoan: boolean | undefined;
    ngayThamGiaBH: moment.Moment | undefined;
    tyLeDongBH: number | undefined;
    soSoBHXH: string | undefined;
    maSoBBXH: string | undefined;
    tinhCap_Id: string | undefined;
    soTheBHYT: string | undefined;
    ngayHetHanBHYT: moment.Moment | undefined;
    noiKcb_Id: string | undefined;
    chonGoi: string | undefined;
    sohd: string | undefined;
    chiNhanh: string | undefined;
    dvt: string | undefined;
    ngayHetHan: moment.Moment | undefined;
    ngayKyHD: moment.Moment | undefined;
    donViCongTac_Id: string | undefined;
    noiDangKyKCB_Id: string | undefined;
    noiDaoTao_Id: string | undefined;
    tinhThanhHKTT_Id: string | undefined;
    chuyenNganh: string | undefined;
    gioiTinh_Code: string | undefined;
    anhDaiDien: string | undefined;
    ngaysinh: moment.Moment | undefined;
    mstCaNhan: string | undefined;
    danToc: string | undefined;
    tonGiao: string | undefined;
    quocTich: string | undefined;
    soCmnd: string | undefined;
    ngayCap: moment.Moment | undefined;
    froM_DATE: moment.Moment | undefined;
    tO_DATE: moment.Moment | undefined;
    froM_DATE_NV: moment.Moment | undefined;
    tO_DATE_NV: moment.Moment | undefined;
    froM_DATE_HHHD: moment.Moment | undefined;
    tO_DATE_HHHD: moment.Moment | undefined;
    tO_MONTH: string | undefined;
    noiCap: string | undefined;
    laChuHo: boolean | undefined;
    bac: string | undefined;
    loaiHopDong_Id: string | undefined;
    nganHang_Code: string | undefined;
    tinhThanHienNay_Id: string | undefined;
    tinhTrangHonNhan_Code: string | undefined;
    viTriCongViec_Id: string | undefined;
    xepLoai_Code: string | undefined;
    luongCoBan: string | undefined;
    hopDongHienTai: string | undefined;
    tenCty: string | undefined;
    sdt: string | undefined;
    nguoiNhapcv_Ten: string | undefined;
    maChamCong: string | undefined;
    isDeleted: boolean | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    tenant_Id: string | undefined;
    autH_STATUS_NAME: string | undefined;
    ungVien_Id: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    viTriCongViec: string | undefined;
    donViCongTac: string | undefined;
    loaiHopDong: string | undefined;
    congTY: string | undefined;
    trangThaiLamViec: string | undefined;
    totalCount: number | undefined;
    congTy_ID: number | undefined;
    soHopDong: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IHR_Hoso_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maHoSo = data["maHoSo"];
            this.maNhanVien = data["maNhanVien"];
            this.hoVaTen = data["hoVaTen"];
            this.trinhDoVanHoa = data["trinhDoVanHoa"];
            this.trinhDoDaoTao_Code = data["trinhDoDaoTao_Code"];
            this.khoa = data["khoa"];
            this.namTotNghiep = data["namTotNghiep"];
            this.tepDinhKem = data["tepDinhKem"];
            this.dtDiDong = data["dtDiDong"];
            this.dtCoQuan = data["dtCoQuan"];
            this.dtNhaRieng = data["dtNhaRieng"];
            this.dtKhac = data["dtKhac"];
            this.emailCaNhan = data["emailCaNhan"];
            this.emailCoQuan = data["emailCoQuan"];
            this.emailKhac = data["emailKhac"];
            this.nguyenQuan = data["nguyenQuan"];
            this.tinhThanh_Id = data["tinhThanh_Id"];
            this.noiSinh = data["noiSinh"];
            this.skyPe = data["skyPe"];
            this.faceBook = data["faceBook"];
            this.quocGiahktt = data["quocGiahktt"];
            this.diaChihktt = data["diaChihktt"];
            this.soSoHoKhau = data["soSoHoKhau"];
            this.soHoGiaDinh_Code = data["soHoGiaDinh_Code"];
            this.quocGiaHienNay = data["quocGiaHienNay"];
            this.diaChiHienNay = data["diaChiHienNay"];
            this.hoVaTenlhkc = data["hoVaTenlhkc"];
            this.quanHelhkc = data["quanHelhkc"];
            this.dtDiDonglhkc = data["dtDiDonglhkc"];
            this.dtNhaRienglhkc = data["dtNhaRienglhkc"];
            this.emaillhkc = data["emaillhkc"];
            this.diaChilhkc = data["diaChilhkc"];
            this.chamCong_Id = data["chamCong_Id"];
            this.chucDanh = data["chucDanh"];
            this.cap = data["cap"];
            this.trangThaiLamViec_Code = data["trangThaiLamViec_Code"];
            this.quanLyTrucTiep_Id = data["quanLyTrucTiep_Id"];
            this.quanlyGianTiep_Id = data["quanlyGianTiep_Id"];
            this.diaDiemLamViec_Code = data["diaDiemLamViec_Code"];
            this.soSoqllaodong = data["soSoqllaodong"];
            this.ngayTapSu = data["ngayTapSu"] ? moment(data["ngayTapSu"].toString()) : <any>undefined;
            this.ngayThuViec = data["ngayThuViec"] ? moment(data["ngayThuViec"].toString()) : <any>undefined;
            this.ngayNghiViec = data["ngayNghiViec"] ? moment(data["ngayNghiViec"].toString()) : <any>undefined;
            this.ngayChinhThuc = data["ngayChinhThuc"] ? moment(data["ngayChinhThuc"].toString()) : <any>undefined;
            this.soNgayPhep = data["soNgayPhep"];
            this.bacLuong_Code = data["bacLuong_Code"];
            this.luongDongbh = data["luongDongbh"];
            this.soCongChuan = data["soCongChuan"];
            this.donViSoCongChuan_Code = data["donViSoCongChuan_Code"];
            this.tkNganHang = data["tkNganHang"];
            this.thamGiaCongDoan = data["thamGiaCongDoan"];
            this.ngayThamGiaBH = data["ngayThamGiaBH"] ? moment(data["ngayThamGiaBH"].toString()) : <any>undefined;
            this.tyLeDongBH = data["tyLeDongBH"];
            this.soSoBHXH = data["soSoBHXH"];
            this.maSoBBXH = data["maSoBBXH"];
            this.tinhCap_Id = data["tinhCap_Id"];
            this.soTheBHYT = data["soTheBHYT"];
            this.ngayHetHanBHYT = data["ngayHetHanBHYT"] ? moment(data["ngayHetHanBHYT"].toString()) : <any>undefined;
            this.noiKcb_Id = data["noiKcb_Id"];
            this.chonGoi = data["chonGoi"];
            this.sohd = data["sohd"];
            this.chiNhanh = data["chiNhanh"];
            this.dvt = data["dvt"];
            this.ngayHetHan = data["ngayHetHan"] ? moment(data["ngayHetHan"].toString()) : <any>undefined;
            this.ngayKyHD = data["ngayKyHD"] ? moment(data["ngayKyHD"].toString()) : <any>undefined;
            this.donViCongTac_Id = data["donViCongTac_Id"];
            this.noiDangKyKCB_Id = data["noiDangKyKCB_Id"];
            this.noiDaoTao_Id = data["noiDaoTao_Id"];
            this.tinhThanhHKTT_Id = data["tinhThanhHKTT_Id"];
            this.chuyenNganh = data["chuyenNganh"];
            this.gioiTinh_Code = data["gioiTinh_Code"];
            this.anhDaiDien = data["anhDaiDien"];
            this.ngaysinh = data["ngaysinh"] ? moment(data["ngaysinh"].toString()) : <any>undefined;
            this.mstCaNhan = data["mstCaNhan"];
            this.danToc = data["danToc"];
            this.tonGiao = data["tonGiao"];
            this.quocTich = data["quocTich"];
            this.soCmnd = data["soCmnd"];
            this.ngayCap = data["ngayCap"] ? moment(data["ngayCap"].toString()) : <any>undefined;
            this.froM_DATE = data["froM_DATE"] ? moment(data["froM_DATE"].toString()) : <any>undefined;
            this.tO_DATE = data["tO_DATE"] ? moment(data["tO_DATE"].toString()) : <any>undefined;
            this.froM_DATE_NV = data["froM_DATE_NV"] ? moment(data["froM_DATE_NV"].toString()) : <any>undefined;
            this.tO_DATE_NV = data["tO_DATE_NV"] ? moment(data["tO_DATE_NV"].toString()) : <any>undefined;
            this.froM_DATE_HHHD = data["froM_DATE_HHHD"] ? moment(data["froM_DATE_HHHD"].toString()) : <any>undefined;
            this.tO_DATE_HHHD = data["tO_DATE_HHHD"] ? moment(data["tO_DATE_HHHD"].toString()) : <any>undefined;
            this.tO_MONTH = data["tO_MONTH"];
            this.noiCap = data["noiCap"];
            this.laChuHo = data["laChuHo"];
            this.bac = data["bac"];
            this.loaiHopDong_Id = data["loaiHopDong_Id"];
            this.nganHang_Code = data["nganHang_Code"];
            this.tinhThanHienNay_Id = data["tinhThanHienNay_Id"];
            this.tinhTrangHonNhan_Code = data["tinhTrangHonNhan_Code"];
            this.viTriCongViec_Id = data["viTriCongViec_Id"];
            this.xepLoai_Code = data["xepLoai_Code"];
            this.luongCoBan = data["luongCoBan"];
            this.hopDongHienTai = data["hopDongHienTai"];
            this.tenCty = data["tenCty"];
            this.sdt = data["sdt"];
            this.nguoiNhapcv_Ten = data["nguoiNhapcv_Ten"];
            this.maChamCong = data["maChamCong"];
            this.isDeleted = data["isDeleted"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.tenant_Id = data["tenant_Id"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.ungVien_Id = data["ungVien_Id"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.viTriCongViec = data["viTriCongViec"];
            this.donViCongTac = data["donViCongTac"];
            this.loaiHopDong = data["loaiHopDong"];
            this.congTY = data["congTY"];
            this.trangThaiLamViec = data["trangThaiLamViec"];
            this.totalCount = data["totalCount"];
            this.congTy_ID = data["congTy_ID"];
            this.soHopDong = data["soHopDong"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): HR_Hoso_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HR_Hoso_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maHoSo"] = this.maHoSo;
        data["maNhanVien"] = this.maNhanVien;
        data["hoVaTen"] = this.hoVaTen;
        data["trinhDoVanHoa"] = this.trinhDoVanHoa;
        data["trinhDoDaoTao_Code"] = this.trinhDoDaoTao_Code;
        data["khoa"] = this.khoa;
        data["namTotNghiep"] = this.namTotNghiep;
        data["tepDinhKem"] = this.tepDinhKem;
        data["dtDiDong"] = this.dtDiDong;
        data["dtCoQuan"] = this.dtCoQuan;
        data["dtNhaRieng"] = this.dtNhaRieng;
        data["dtKhac"] = this.dtKhac;
        data["emailCaNhan"] = this.emailCaNhan;
        data["emailCoQuan"] = this.emailCoQuan;
        data["emailKhac"] = this.emailKhac;
        data["nguyenQuan"] = this.nguyenQuan;
        data["tinhThanh_Id"] = this.tinhThanh_Id;
        data["noiSinh"] = this.noiSinh;
        data["skyPe"] = this.skyPe;
        data["faceBook"] = this.faceBook;
        data["quocGiahktt"] = this.quocGiahktt;
        data["diaChihktt"] = this.diaChihktt;
        data["soSoHoKhau"] = this.soSoHoKhau;
        data["soHoGiaDinh_Code"] = this.soHoGiaDinh_Code;
        data["quocGiaHienNay"] = this.quocGiaHienNay;
        data["diaChiHienNay"] = this.diaChiHienNay;
        data["hoVaTenlhkc"] = this.hoVaTenlhkc;
        data["quanHelhkc"] = this.quanHelhkc;
        data["dtDiDonglhkc"] = this.dtDiDonglhkc;
        data["dtNhaRienglhkc"] = this.dtNhaRienglhkc;
        data["emaillhkc"] = this.emaillhkc;
        data["diaChilhkc"] = this.diaChilhkc;
        data["chamCong_Id"] = this.chamCong_Id;
        data["chucDanh"] = this.chucDanh;
        data["cap"] = this.cap;
        data["trangThaiLamViec_Code"] = this.trangThaiLamViec_Code;
        data["quanLyTrucTiep_Id"] = this.quanLyTrucTiep_Id;
        data["quanlyGianTiep_Id"] = this.quanlyGianTiep_Id;
        data["diaDiemLamViec_Code"] = this.diaDiemLamViec_Code;
        data["soSoqllaodong"] = this.soSoqllaodong;
        data["ngayTapSu"] = this.ngayTapSu ? this.ngayTapSu.toISOString() : <any>undefined;
        data["ngayThuViec"] = this.ngayThuViec ? this.ngayThuViec.toISOString() : <any>undefined;
        data["ngayNghiViec"] = this.ngayNghiViec ? this.ngayNghiViec.toISOString() : <any>undefined;
        data["ngayChinhThuc"] = this.ngayChinhThuc ? this.ngayChinhThuc.toISOString() : <any>undefined;
        data["soNgayPhep"] = this.soNgayPhep;
        data["bacLuong_Code"] = this.bacLuong_Code;
        data["luongDongbh"] = this.luongDongbh;
        data["soCongChuan"] = this.soCongChuan;
        data["donViSoCongChuan_Code"] = this.donViSoCongChuan_Code;
        data["tkNganHang"] = this.tkNganHang;
        data["thamGiaCongDoan"] = this.thamGiaCongDoan;
        data["ngayThamGiaBH"] = this.ngayThamGiaBH ? this.ngayThamGiaBH.toISOString() : <any>undefined;
        data["tyLeDongBH"] = this.tyLeDongBH;
        data["soSoBHXH"] = this.soSoBHXH;
        data["maSoBBXH"] = this.maSoBBXH;
        data["tinhCap_Id"] = this.tinhCap_Id;
        data["soTheBHYT"] = this.soTheBHYT;
        data["ngayHetHanBHYT"] = this.ngayHetHanBHYT ? this.ngayHetHanBHYT.toISOString() : <any>undefined;
        data["noiKcb_Id"] = this.noiKcb_Id;
        data["chonGoi"] = this.chonGoi;
        data["sohd"] = this.sohd;
        data["chiNhanh"] = this.chiNhanh;
        data["dvt"] = this.dvt;
        data["ngayHetHan"] = this.ngayHetHan ? this.ngayHetHan.toISOString() : <any>undefined;
        data["ngayKyHD"] = this.ngayKyHD ? this.ngayKyHD.toISOString() : <any>undefined;
        data["donViCongTac_Id"] = this.donViCongTac_Id;
        data["noiDangKyKCB_Id"] = this.noiDangKyKCB_Id;
        data["noiDaoTao_Id"] = this.noiDaoTao_Id;
        data["tinhThanhHKTT_Id"] = this.tinhThanhHKTT_Id;
        data["chuyenNganh"] = this.chuyenNganh;
        data["gioiTinh_Code"] = this.gioiTinh_Code;
        data["anhDaiDien"] = this.anhDaiDien;
        data["ngaysinh"] = this.ngaysinh ? this.ngaysinh.toISOString() : <any>undefined;
        data["mstCaNhan"] = this.mstCaNhan;
        data["danToc"] = this.danToc;
        data["tonGiao"] = this.tonGiao;
        data["quocTich"] = this.quocTich;
        data["soCmnd"] = this.soCmnd;
        data["ngayCap"] = this.ngayCap ? this.ngayCap.toISOString() : <any>undefined;
        data["froM_DATE"] = this.froM_DATE ? this.froM_DATE.toISOString() : <any>undefined;
        data["tO_DATE"] = this.tO_DATE ? this.tO_DATE.toISOString() : <any>undefined;
        data["froM_DATE_NV"] = this.froM_DATE_NV ? this.froM_DATE_NV.toISOString() : <any>undefined;
        data["tO_DATE_NV"] = this.tO_DATE_NV ? this.tO_DATE_NV.toISOString() : <any>undefined;
        data["froM_DATE_HHHD"] = this.froM_DATE_HHHD ? this.froM_DATE_HHHD.toISOString() : <any>undefined;
        data["tO_DATE_HHHD"] = this.tO_DATE_HHHD ? this.tO_DATE_HHHD.toISOString() : <any>undefined;
        data["tO_MONTH"] = this.tO_MONTH;
        data["noiCap"] = this.noiCap;
        data["laChuHo"] = this.laChuHo;
        data["bac"] = this.bac;
        data["loaiHopDong_Id"] = this.loaiHopDong_Id;
        data["nganHang_Code"] = this.nganHang_Code;
        data["tinhThanHienNay_Id"] = this.tinhThanHienNay_Id;
        data["tinhTrangHonNhan_Code"] = this.tinhTrangHonNhan_Code;
        data["viTriCongViec_Id"] = this.viTriCongViec_Id;
        data["xepLoai_Code"] = this.xepLoai_Code;
        data["luongCoBan"] = this.luongCoBan;
        data["hopDongHienTai"] = this.hopDongHienTai;
        data["tenCty"] = this.tenCty;
        data["sdt"] = this.sdt;
        data["nguoiNhapcv_Ten"] = this.nguoiNhapcv_Ten;
        data["maChamCong"] = this.maChamCong;
        data["isDeleted"] = this.isDeleted;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["tenant_Id"] = this.tenant_Id;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["ungVien_Id"] = this.ungVien_Id;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["viTriCongViec"] = this.viTriCongViec;
        data["donViCongTac"] = this.donViCongTac;
        data["loaiHopDong"] = this.loaiHopDong;
        data["congTY"] = this.congTY;
        data["trangThaiLamViec"] = this.trangThaiLamViec;
        data["totalCount"] = this.totalCount;
        data["congTy_ID"] = this.congTy_ID;
        data["soHopDong"] = this.soHopDong;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): HR_Hoso_ENTITY {
        const json = this.toJSON();
        let result = new HR_Hoso_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHR_Hoso_ENTITY {
    maHoSo: string | undefined;
    maNhanVien: string | undefined;
    hoVaTen: string | undefined;
    trinhDoVanHoa: string | undefined;
    trinhDoDaoTao_Code: string | undefined;
    khoa: string | undefined;
    namTotNghiep: number | undefined;
    tepDinhKem: string | undefined;
    dtDiDong: string | undefined;
    dtCoQuan: string | undefined;
    dtNhaRieng: string | undefined;
    dtKhac: string | undefined;
    emailCaNhan: string | undefined;
    emailCoQuan: string | undefined;
    emailKhac: string | undefined;
    nguyenQuan: string | undefined;
    tinhThanh_Id: string | undefined;
    noiSinh: string | undefined;
    skyPe: string | undefined;
    faceBook: string | undefined;
    quocGiahktt: string | undefined;
    diaChihktt: string | undefined;
    soSoHoKhau: string | undefined;
    soHoGiaDinh_Code: string | undefined;
    quocGiaHienNay: string | undefined;
    diaChiHienNay: string | undefined;
    hoVaTenlhkc: string | undefined;
    quanHelhkc: string | undefined;
    dtDiDonglhkc: string | undefined;
    dtNhaRienglhkc: string | undefined;
    emaillhkc: string | undefined;
    diaChilhkc: string | undefined;
    chamCong_Id: string | undefined;
    chucDanh: string | undefined;
    cap: string | undefined;
    trangThaiLamViec_Code: string | undefined;
    quanLyTrucTiep_Id: string | undefined;
    quanlyGianTiep_Id: string | undefined;
    diaDiemLamViec_Code: string | undefined;
    soSoqllaodong: string | undefined;
    ngayTapSu: moment.Moment | undefined;
    ngayThuViec: moment.Moment | undefined;
    ngayNghiViec: moment.Moment | undefined;
    ngayChinhThuc: moment.Moment | undefined;
    soNgayPhep: number | undefined;
    bacLuong_Code: string | undefined;
    luongDongbh: string | undefined;
    soCongChuan: string | undefined;
    donViSoCongChuan_Code: string | undefined;
    tkNganHang: string | undefined;
    thamGiaCongDoan: boolean | undefined;
    ngayThamGiaBH: moment.Moment | undefined;
    tyLeDongBH: number | undefined;
    soSoBHXH: string | undefined;
    maSoBBXH: string | undefined;
    tinhCap_Id: string | undefined;
    soTheBHYT: string | undefined;
    ngayHetHanBHYT: moment.Moment | undefined;
    noiKcb_Id: string | undefined;
    chonGoi: string | undefined;
    sohd: string | undefined;
    chiNhanh: string | undefined;
    dvt: string | undefined;
    ngayHetHan: moment.Moment | undefined;
    ngayKyHD: moment.Moment | undefined;
    donViCongTac_Id: string | undefined;
    noiDangKyKCB_Id: string | undefined;
    noiDaoTao_Id: string | undefined;
    tinhThanhHKTT_Id: string | undefined;
    chuyenNganh: string | undefined;
    gioiTinh_Code: string | undefined;
    anhDaiDien: string | undefined;
    ngaysinh: moment.Moment | undefined;
    mstCaNhan: string | undefined;
    danToc: string | undefined;
    tonGiao: string | undefined;
    quocTich: string | undefined;
    soCmnd: string | undefined;
    ngayCap: moment.Moment | undefined;
    froM_DATE: moment.Moment | undefined;
    tO_DATE: moment.Moment | undefined;
    froM_DATE_NV: moment.Moment | undefined;
    tO_DATE_NV: moment.Moment | undefined;
    froM_DATE_HHHD: moment.Moment | undefined;
    tO_DATE_HHHD: moment.Moment | undefined;
    tO_MONTH: string | undefined;
    noiCap: string | undefined;
    laChuHo: boolean | undefined;
    bac: string | undefined;
    loaiHopDong_Id: string | undefined;
    nganHang_Code: string | undefined;
    tinhThanHienNay_Id: string | undefined;
    tinhTrangHonNhan_Code: string | undefined;
    viTriCongViec_Id: string | undefined;
    xepLoai_Code: string | undefined;
    luongCoBan: string | undefined;
    hopDongHienTai: string | undefined;
    tenCty: string | undefined;
    sdt: string | undefined;
    nguoiNhapcv_Ten: string | undefined;
    maChamCong: string | undefined;
    isDeleted: boolean | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    tenant_Id: string | undefined;
    autH_STATUS_NAME: string | undefined;
    ungVien_Id: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    viTriCongViec: string | undefined;
    donViCongTac: string | undefined;
    loaiHopDong: string | undefined;
    congTY: string | undefined;
    trangThaiLamViec: string | undefined;
    totalCount: number | undefined;
    congTy_ID: number | undefined;
    soHopDong: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class HR_Hoso_Filter implements IHR_Hoso_Filter {
    trangThaiLamViec_Code: string | undefined;
    congTy_ID: number | undefined;
    soHopDong: string | undefined;
    hoVaTen: string | undefined;
    froM_DATE: moment.Moment | undefined;
    tO_DATE: moment.Moment | undefined;
    froM_DATE_NV: moment.Moment | undefined;
    tO_DATE_NV: moment.Moment | undefined;
    froM_DATE_HHHD: moment.Moment | undefined;
    tO_DATE_HHHD: moment.Moment | undefined;
    tO_MONTH: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IHR_Hoso_Filter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trangThaiLamViec_Code = data["trangThaiLamViec_Code"];
            this.congTy_ID = data["congTy_ID"];
            this.soHopDong = data["soHopDong"];
            this.hoVaTen = data["hoVaTen"];
            this.froM_DATE = data["froM_DATE"] ? moment(data["froM_DATE"].toString()) : <any>undefined;
            this.tO_DATE = data["tO_DATE"] ? moment(data["tO_DATE"].toString()) : <any>undefined;
            this.froM_DATE_NV = data["froM_DATE_NV"] ? moment(data["froM_DATE_NV"].toString()) : <any>undefined;
            this.tO_DATE_NV = data["tO_DATE_NV"] ? moment(data["tO_DATE_NV"].toString()) : <any>undefined;
            this.froM_DATE_HHHD = data["froM_DATE_HHHD"] ? moment(data["froM_DATE_HHHD"].toString()) : <any>undefined;
            this.tO_DATE_HHHD = data["tO_DATE_HHHD"] ? moment(data["tO_DATE_HHHD"].toString()) : <any>undefined;
            this.tO_MONTH = data["tO_MONTH"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): HR_Hoso_Filter {
        data = typeof data === 'object' ? data : {};
        let result = new HR_Hoso_Filter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trangThaiLamViec_Code"] = this.trangThaiLamViec_Code;
        data["congTy_ID"] = this.congTy_ID;
        data["soHopDong"] = this.soHopDong;
        data["hoVaTen"] = this.hoVaTen;
        data["froM_DATE"] = this.froM_DATE ? this.froM_DATE.toISOString() : <any>undefined;
        data["tO_DATE"] = this.tO_DATE ? this.tO_DATE.toISOString() : <any>undefined;
        data["froM_DATE_NV"] = this.froM_DATE_NV ? this.froM_DATE_NV.toISOString() : <any>undefined;
        data["tO_DATE_NV"] = this.tO_DATE_NV ? this.tO_DATE_NV.toISOString() : <any>undefined;
        data["froM_DATE_HHHD"] = this.froM_DATE_HHHD ? this.froM_DATE_HHHD.toISOString() : <any>undefined;
        data["tO_DATE_HHHD"] = this.tO_DATE_HHHD ? this.tO_DATE_HHHD.toISOString() : <any>undefined;
        data["tO_MONTH"] = this.tO_MONTH;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): HR_Hoso_Filter {
        const json = this.toJSON();
        let result = new HR_Hoso_Filter();
        result.init(json);
        return result;
    }
}

export interface IHR_Hoso_Filter {
    trangThaiLamViec_Code: string | undefined;
    congTy_ID: number | undefined;
    soHopDong: string | undefined;
    hoVaTen: string | undefined;
    froM_DATE: moment.Moment | undefined;
    tO_DATE: moment.Moment | undefined;
    froM_DATE_NV: moment.Moment | undefined;
    tO_DATE_NV: moment.Moment | undefined;
    froM_DATE_HHHD: moment.Moment | undefined;
    tO_DATE_HHHD: moment.Moment | undefined;
    tO_MONTH: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfHR_Hoso_ENTITY implements IPagedResultDtoOfHR_Hoso_ENTITY {
    totalCount: number | undefined;
    items: HR_Hoso_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfHR_Hoso_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(HR_Hoso_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfHR_Hoso_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfHR_Hoso_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfHR_Hoso_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfHR_Hoso_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfHR_Hoso_ENTITY {
    totalCount: number | undefined;
    items: HR_Hoso_ENTITY[] | undefined;
}

export class DM_TINHTHANH_ENTITY implements IDM_TINHTHANH_ENTITY {
    tinhthanH_ID: string | undefined;
    tinhthanH_CODE: string | undefined;
    tentat: string | undefined;
    ten: string | undefined;
    tendaydu: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IDM_TINHTHANH_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tinhthanH_ID = data["tinhthanH_ID"];
            this.tinhthanH_CODE = data["tinhthanH_CODE"];
            this.tentat = data["tentat"];
            this.ten = data["ten"];
            this.tendaydu = data["tendaydu"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): DM_TINHTHANH_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new DM_TINHTHANH_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tinhthanH_ID"] = this.tinhthanH_ID;
        data["tinhthanH_CODE"] = this.tinhthanH_CODE;
        data["tentat"] = this.tentat;
        data["ten"] = this.ten;
        data["tendaydu"] = this.tendaydu;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): DM_TINHTHANH_ENTITY {
        const json = this.toJSON();
        let result = new DM_TINHTHANH_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IDM_TINHTHANH_ENTITY {
    tinhthanH_ID: string | undefined;
    tinhthanH_CODE: string | undefined;
    tentat: string | undefined;
    ten: string | undefined;
    tendaydu: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class HR_NoiDaoTao_ENTITY implements IHR_NoiDaoTao_ENTITY {
    noiDaoTao_Id: string | undefined;
    noiDaoTao_Code: string | undefined;
    noiDaoTao_Ten: string | undefined;
    diaChi: string | undefined;
    khuVuc: string | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IHR_NoiDaoTao_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.noiDaoTao_Id = data["noiDaoTao_Id"];
            this.noiDaoTao_Code = data["noiDaoTao_Code"];
            this.noiDaoTao_Ten = data["noiDaoTao_Ten"];
            this.diaChi = data["diaChi"];
            this.khuVuc = data["khuVuc"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): HR_NoiDaoTao_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HR_NoiDaoTao_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noiDaoTao_Id"] = this.noiDaoTao_Id;
        data["noiDaoTao_Code"] = this.noiDaoTao_Code;
        data["noiDaoTao_Ten"] = this.noiDaoTao_Ten;
        data["diaChi"] = this.diaChi;
        data["khuVuc"] = this.khuVuc;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): HR_NoiDaoTao_ENTITY {
        const json = this.toJSON();
        let result = new HR_NoiDaoTao_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHR_NoiDaoTao_ENTITY {
    noiDaoTao_Id: string | undefined;
    noiDaoTao_Code: string | undefined;
    noiDaoTao_Ten: string | undefined;
    diaChi: string | undefined;
    khuVuc: string | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class HR_NOIKHAMCHUABENH_ENTITY implements IHR_NOIKHAMCHUABENH_ENTITY {
    noiKhamChuaBenh_Id: string | undefined;
    noiKhamChuaBenh_Code: string | undefined;
    noiKhamChuaBenh_Ten: string | undefined;
    diaChiNoiKhamChuaBenh: string | undefined;
    tinhThanh_Id: string | undefined;
    ghiChu: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    tenant_Id: string | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IHR_NOIKHAMCHUABENH_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.noiKhamChuaBenh_Id = data["noiKhamChuaBenh_Id"];
            this.noiKhamChuaBenh_Code = data["noiKhamChuaBenh_Code"];
            this.noiKhamChuaBenh_Ten = data["noiKhamChuaBenh_Ten"];
            this.diaChiNoiKhamChuaBenh = data["diaChiNoiKhamChuaBenh"];
            this.tinhThanh_Id = data["tinhThanh_Id"];
            this.ghiChu = data["ghiChu"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.tenant_Id = data["tenant_Id"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): HR_NOIKHAMCHUABENH_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HR_NOIKHAMCHUABENH_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noiKhamChuaBenh_Id"] = this.noiKhamChuaBenh_Id;
        data["noiKhamChuaBenh_Code"] = this.noiKhamChuaBenh_Code;
        data["noiKhamChuaBenh_Ten"] = this.noiKhamChuaBenh_Ten;
        data["diaChiNoiKhamChuaBenh"] = this.diaChiNoiKhamChuaBenh;
        data["tinhThanh_Id"] = this.tinhThanh_Id;
        data["ghiChu"] = this.ghiChu;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["tenant_Id"] = this.tenant_Id;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): HR_NOIKHAMCHUABENH_ENTITY {
        const json = this.toJSON();
        let result = new HR_NOIKHAMCHUABENH_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHR_NOIKHAMCHUABENH_ENTITY {
    noiKhamChuaBenh_Id: string | undefined;
    noiKhamChuaBenh_Code: string | undefined;
    noiKhamChuaBenh_Ten: string | undefined;
    diaChiNoiKhamChuaBenh: string | undefined;
    tinhThanh_Id: string | undefined;
    ghiChu: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    tenant_Id: string | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export enum ChartDateInterval {
    Daily = 1, 
    Weekly = 2, 
    Monthly = 3, 
}

export class HostDashboardData implements IHostDashboardData {
    newTenantsCount: number | undefined;
    newSubscriptionAmount: number | undefined;
    dashboardPlaceholder1: number | undefined;
    dashboardPlaceholder2: number | undefined;
    incomeStatistics: IncomeStastistic[] | undefined;
    editionStatistics: TenantEdition[] | undefined;
    expiringTenants: ExpiringTenant[] | undefined;
    recentTenants: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount: number | undefined;
    maxRecentTenantsShownCount: number | undefined;
    subscriptionEndAlertDayCount: number | undefined;
    recentTenantsDayCount: number | undefined;
    subscriptionEndDateStart: moment.Moment | undefined;
    subscriptionEndDateEnd: moment.Moment | undefined;
    tenantCreationStartDate: moment.Moment | undefined;

    constructor(data?: IHostDashboardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newTenantsCount = data["newTenantsCount"];
            this.newSubscriptionAmount = data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = data["dashboardPlaceholder2"];
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [];
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics.push(IncomeStastistic.fromJS(item));
            }
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [];
                for (let item of data["editionStatistics"])
                    this.editionStatistics.push(TenantEdition.fromJS(item));
            }
            if (data["expiringTenants"] && data["expiringTenants"].constructor === Array) {
                this.expiringTenants = [];
                for (let item of data["expiringTenants"])
                    this.expiringTenants.push(ExpiringTenant.fromJS(item));
            }
            if (data["recentTenants"] && data["recentTenants"].constructor === Array) {
                this.recentTenants = [];
                for (let item of data["recentTenants"])
                    this.recentTenants.push(RecentTenant.fromJS(item));
            }
            this.maxExpiringTenantsShownCount = data["maxExpiringTenantsShownCount"];
            this.maxRecentTenantsShownCount = data["maxRecentTenantsShownCount"];
            this.subscriptionEndAlertDayCount = data["subscriptionEndAlertDayCount"];
            this.recentTenantsDayCount = data["recentTenantsDayCount"];
            this.subscriptionEndDateStart = data["subscriptionEndDateStart"] ? moment(data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = data["subscriptionEndDateEnd"] ? moment(data["subscriptionEndDateEnd"].toString()) : <any>undefined;
            this.tenantCreationStartDate = data["tenantCreationStartDate"] ? moment(data["tenantCreationStartDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HostDashboardData {
        data = typeof data === 'object' ? data : {};
        let result = new HostDashboardData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        if (this.expiringTenants && this.expiringTenants.constructor === Array) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        if (this.recentTenants && this.recentTenants.constructor === Array) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): HostDashboardData {
        const json = this.toJSON();
        let result = new HostDashboardData();
        result.init(json);
        return result;
    }
}

export interface IHostDashboardData {
    newTenantsCount: number | undefined;
    newSubscriptionAmount: number | undefined;
    dashboardPlaceholder1: number | undefined;
    dashboardPlaceholder2: number | undefined;
    incomeStatistics: IncomeStastistic[] | undefined;
    editionStatistics: TenantEdition[] | undefined;
    expiringTenants: ExpiringTenant[] | undefined;
    recentTenants: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount: number | undefined;
    maxRecentTenantsShownCount: number | undefined;
    subscriptionEndAlertDayCount: number | undefined;
    recentTenantsDayCount: number | undefined;
    subscriptionEndDateStart: moment.Moment | undefined;
    subscriptionEndDateEnd: moment.Moment | undefined;
    tenantCreationStartDate: moment.Moment | undefined;
}

export class IncomeStastistic implements IIncomeStastistic {
    label: string | undefined;
    date: moment.Moment | undefined;
    amount: number | undefined;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }

    clone(): IncomeStastistic {
        const json = this.toJSON();
        let result = new IncomeStastistic();
        result.init(json);
        return result;
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: moment.Moment | undefined;
    amount: number | undefined;
}

export class TenantEdition implements ITenantEdition {
    label: string | undefined;
    value: number | undefined;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }

    clone(): TenantEdition {
        const json = this.toJSON();
        let result = new TenantEdition();
        result.init(json);
        return result;
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number | undefined;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number | undefined;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantName = data["tenantName"];
            this.remainingDayCount = data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data; 
    }

    clone(): ExpiringTenant {
        const json = this.toJSON();
        let result = new ExpiringTenant();
        result.init(json);
        return result;
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number | undefined;
}

export class RecentTenant implements IRecentTenant {
    id: number | undefined;
    name: string | undefined;
    creationTime: moment.Moment | undefined;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): RecentTenant {
        const json = this.toJSON();
        let result = new RecentTenant();
        result.init(json);
        return result;
    }
}

export interface IRecentTenant {
    id: number | undefined;
    name: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [];
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetIncomeStatisticsDataOutput {
        const json = this.toJSON();
        let result = new GetIncomeStatisticsDataOutput();
        result.init(json);
        return result;
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [];
                for (let item of data["editionStatistics"])
                    this.editionStatistics.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetEditionTenantStatisticsOutput {
        const json = this.toJSON();
        let result = new GetEditionTenantStatisticsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto | undefined;
    otherSettings: OtherSettingsEditDto | undefined;
    userLoginSettingEditDto: UserLoginSettingEditDto | undefined;
    commonSettingEditDto: CommonSettingEditDto | undefined;
    logoCompanySettingDto: LogoCompanySettingDto | undefined;
    sftpSettingEditDto: SftpSettingEditDto | undefined;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? HostBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
            this.otherSettings = data["otherSettings"] ? OtherSettingsEditDto.fromJS(data["otherSettings"]) : <any>undefined;
            this.userLoginSettingEditDto = data["userLoginSettingEditDto"] ? UserLoginSettingEditDto.fromJS(data["userLoginSettingEditDto"]) : <any>undefined;
            this.commonSettingEditDto = data["commonSettingEditDto"] ? CommonSettingEditDto.fromJS(data["commonSettingEditDto"]) : <any>undefined;
            this.logoCompanySettingDto = data["logoCompanySettingDto"] ? LogoCompanySettingDto.fromJS(data["logoCompanySettingDto"]) : <any>undefined;
            this.sftpSettingEditDto = data["sftpSettingEditDto"] ? SftpSettingEditDto.fromJS(data["sftpSettingEditDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        data["userLoginSettingEditDto"] = this.userLoginSettingEditDto ? this.userLoginSettingEditDto.toJSON() : <any>undefined;
        data["commonSettingEditDto"] = this.commonSettingEditDto ? this.commonSettingEditDto.toJSON() : <any>undefined;
        data["logoCompanySettingDto"] = this.logoCompanySettingDto ? this.logoCompanySettingDto.toJSON() : <any>undefined;
        data["sftpSettingEditDto"] = this.sftpSettingEditDto ? this.sftpSettingEditDto.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HostSettingsEditDto {
        const json = this.toJSON();
        let result = new HostSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto | undefined;
    otherSettings: OtherSettingsEditDto | undefined;
    userLoginSettingEditDto: UserLoginSettingEditDto | undefined;
    commonSettingEditDto: CommonSettingEditDto | undefined;
    logoCompanySettingDto: LogoCompanySettingDto | undefined;
    sftpSettingEditDto: SftpSettingEditDto | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timezone = data["timezone"];
            this.timezoneForComparison = data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data; 
    }

    clone(): GeneralSettingsEditDto {
        const json = this.toJSON();
        let result = new GeneralSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    smsVerificationEnabled: boolean | undefined;
    isCookieConsentEnabled: boolean | undefined;
    isQuickThemeSelectEnabled: boolean | undefined;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = data["smsVerificationEnabled"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }

    clone(): HostUserManagementSettingsEditDto {
        const json = this.toJSON();
        let result = new HostUserManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    smsVerificationEnabled: boolean | undefined;
    isCookieConsentEnabled: boolean | undefined;
    isQuickThemeSelectEnabled: boolean | undefined;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }

    clone(): EmailSettingsEditDto {
        const json = this.toJSON();
        let result = new EmailSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredTenantActiveByDefault: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    defaultEditionId: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.defaultEditionId = data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }

    clone(): TenantManagementSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredTenantActiveByDefault: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    defaultEditionId: number | undefined;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings: boolean | undefined;
    passwordComplexity: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity: PasswordComplexitySetting | undefined;
    userLockOut: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin: TwoFactorLoginSettingsEditDto | undefined;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useDefaultPasswordComplexitySettings = data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }

    clone(): SecuritySettingsEditDto {
        const json = this.toJSON();
        let result = new SecuritySettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings: boolean | undefined;
    passwordComplexity: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity: PasswordComplexitySetting | undefined;
    userLockOut: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin: TwoFactorLoginSettingsEditDto | undefined;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data; 
    }

    clone(): HostBillingSettingsEditDto {
        const json = this.toJSON();
        let result = new HostBillingSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class OtherSettingsEditDto implements IOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean | undefined;

    constructor(data?: IOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): OtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }

    clone(): OtherSettingsEditDto {
        const json = this.toJSON();
        let result = new OtherSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean | undefined;
}

export class UserLoginSettingEditDto implements IUserLoginSettingEditDto {
    loginMethod: string | undefined;
    ldapServerName: string | undefined;
    adfsWtrealm: string | undefined;
    adfsMetadataAddress: string | undefined;
    emailActivationEnable: boolean | undefined;
    fogotPasswordEnable: boolean | undefined;

    constructor(data?: IUserLoginSettingEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.loginMethod = data["loginMethod"];
            this.ldapServerName = data["ldapServerName"];
            this.adfsWtrealm = data["adfsWtrealm"];
            this.adfsMetadataAddress = data["adfsMetadataAddress"];
            this.emailActivationEnable = data["emailActivationEnable"];
            this.fogotPasswordEnable = data["fogotPasswordEnable"];
        }
    }

    static fromJS(data: any): UserLoginSettingEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginSettingEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginMethod"] = this.loginMethod;
        data["ldapServerName"] = this.ldapServerName;
        data["adfsWtrealm"] = this.adfsWtrealm;
        data["adfsMetadataAddress"] = this.adfsMetadataAddress;
        data["emailActivationEnable"] = this.emailActivationEnable;
        data["fogotPasswordEnable"] = this.fogotPasswordEnable;
        return data; 
    }

    clone(): UserLoginSettingEditDto {
        const json = this.toJSON();
        let result = new UserLoginSettingEditDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginSettingEditDto {
    loginMethod: string | undefined;
    ldapServerName: string | undefined;
    adfsWtrealm: string | undefined;
    adfsMetadataAddress: string | undefined;
    emailActivationEnable: boolean | undefined;
    fogotPasswordEnable: boolean | undefined;
}

export class CommonSettingEditDto implements ICommonSettingEditDto {
    defaultRecordsCountPerPage: string | undefined;
    resizableColumns: string | undefined;
    isResponsive: string | undefined;
    predefinedRecordsCountPerPage: string | undefined;
    phoneNumberRegexValidation: string | undefined;
    dateTimeFormatClient: string | undefined;
    datePickerDisplayFormat: string | undefined;
    datePickerValueFormat: string | undefined;
    languageComboboxEnable: boolean | undefined;
    timeShowSuccessMessage: number | undefined;
    timeShowWarningMessage: number | undefined;
    timeShowErrorMessage: number | undefined;
    emailRegexValidation: string | undefined;
    coreNoteRegexValidation: string | undefined;
    codeNumberRegexValidation: string | undefined;
    numberPlateRegexValidation: string | undefined;
    maxQuantityNumber: number | undefined;
    taxNoRegexValidation: string | undefined;
    fullNameRegexValidation: string | undefined;
    maxLenghtRegexValidation: string | undefined;
    searchMenuVisible: boolean | undefined;
    fileSizeAttach: number | undefined;
    fileExtensionAttach: string | undefined;

    constructor(data?: ICommonSettingEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultRecordsCountPerPage = data["defaultRecordsCountPerPage"];
            this.resizableColumns = data["resizableColumns"];
            this.isResponsive = data["isResponsive"];
            this.predefinedRecordsCountPerPage = data["predefinedRecordsCountPerPage"];
            this.phoneNumberRegexValidation = data["phoneNumberRegexValidation"];
            this.dateTimeFormatClient = data["dateTimeFormatClient"];
            this.datePickerDisplayFormat = data["datePickerDisplayFormat"];
            this.datePickerValueFormat = data["datePickerValueFormat"];
            this.languageComboboxEnable = data["languageComboboxEnable"];
            this.timeShowSuccessMessage = data["timeShowSuccessMessage"];
            this.timeShowWarningMessage = data["timeShowWarningMessage"];
            this.timeShowErrorMessage = data["timeShowErrorMessage"];
            this.emailRegexValidation = data["emailRegexValidation"];
            this.coreNoteRegexValidation = data["coreNoteRegexValidation"];
            this.codeNumberRegexValidation = data["codeNumberRegexValidation"];
            this.numberPlateRegexValidation = data["numberPlateRegexValidation"];
            this.maxQuantityNumber = data["maxQuantityNumber"];
            this.taxNoRegexValidation = data["taxNoRegexValidation"];
            this.fullNameRegexValidation = data["fullNameRegexValidation"];
            this.maxLenghtRegexValidation = data["maxLenghtRegexValidation"];
            this.searchMenuVisible = data["searchMenuVisible"];
            this.fileSizeAttach = data["fileSizeAttach"];
            this.fileExtensionAttach = data["fileExtensionAttach"];
        }
    }

    static fromJS(data: any): CommonSettingEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonSettingEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultRecordsCountPerPage"] = this.defaultRecordsCountPerPage;
        data["resizableColumns"] = this.resizableColumns;
        data["isResponsive"] = this.isResponsive;
        data["predefinedRecordsCountPerPage"] = this.predefinedRecordsCountPerPage;
        data["phoneNumberRegexValidation"] = this.phoneNumberRegexValidation;
        data["dateTimeFormatClient"] = this.dateTimeFormatClient;
        data["datePickerDisplayFormat"] = this.datePickerDisplayFormat;
        data["datePickerValueFormat"] = this.datePickerValueFormat;
        data["languageComboboxEnable"] = this.languageComboboxEnable;
        data["timeShowSuccessMessage"] = this.timeShowSuccessMessage;
        data["timeShowWarningMessage"] = this.timeShowWarningMessage;
        data["timeShowErrorMessage"] = this.timeShowErrorMessage;
        data["emailRegexValidation"] = this.emailRegexValidation;
        data["coreNoteRegexValidation"] = this.coreNoteRegexValidation;
        data["codeNumberRegexValidation"] = this.codeNumberRegexValidation;
        data["numberPlateRegexValidation"] = this.numberPlateRegexValidation;
        data["maxQuantityNumber"] = this.maxQuantityNumber;
        data["taxNoRegexValidation"] = this.taxNoRegexValidation;
        data["fullNameRegexValidation"] = this.fullNameRegexValidation;
        data["maxLenghtRegexValidation"] = this.maxLenghtRegexValidation;
        data["searchMenuVisible"] = this.searchMenuVisible;
        data["fileSizeAttach"] = this.fileSizeAttach;
        data["fileExtensionAttach"] = this.fileExtensionAttach;
        return data; 
    }

    clone(): CommonSettingEditDto {
        const json = this.toJSON();
        let result = new CommonSettingEditDto();
        result.init(json);
        return result;
    }
}

export interface ICommonSettingEditDto {
    defaultRecordsCountPerPage: string | undefined;
    resizableColumns: string | undefined;
    isResponsive: string | undefined;
    predefinedRecordsCountPerPage: string | undefined;
    phoneNumberRegexValidation: string | undefined;
    dateTimeFormatClient: string | undefined;
    datePickerDisplayFormat: string | undefined;
    datePickerValueFormat: string | undefined;
    languageComboboxEnable: boolean | undefined;
    timeShowSuccessMessage: number | undefined;
    timeShowWarningMessage: number | undefined;
    timeShowErrorMessage: number | undefined;
    emailRegexValidation: string | undefined;
    coreNoteRegexValidation: string | undefined;
    codeNumberRegexValidation: string | undefined;
    numberPlateRegexValidation: string | undefined;
    maxQuantityNumber: number | undefined;
    taxNoRegexValidation: string | undefined;
    fullNameRegexValidation: string | undefined;
    maxLenghtRegexValidation: string | undefined;
    searchMenuVisible: boolean | undefined;
    fileSizeAttach: number | undefined;
    fileExtensionAttach: string | undefined;
}

export class LogoCompanySettingDto implements ILogoCompanySettingDto {
    loginLogo: string | undefined;
    webLogo: string | undefined;

    constructor(data?: ILogoCompanySettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.loginLogo = data["loginLogo"];
            this.webLogo = data["webLogo"];
        }
    }

    static fromJS(data: any): LogoCompanySettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogoCompanySettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginLogo"] = this.loginLogo;
        data["webLogo"] = this.webLogo;
        return data; 
    }

    clone(): LogoCompanySettingDto {
        const json = this.toJSON();
        let result = new LogoCompanySettingDto();
        result.init(json);
        return result;
    }
}

export interface ILogoCompanySettingDto {
    loginLogo: string | undefined;
    webLogo: string | undefined;
}

export class SftpSettingEditDto implements ISftpSettingEditDto {
    sftpurl: string | undefined;
    sftpUserName: string | undefined;
    sftpPassword: string | undefined;
    sftpSshHostKeyFingerPrint: string | undefined;
    sftpPortNumber: number | undefined;
    sftpsFilePath: string | undefined;
    sftP2URL: string | undefined;
    sftP2UserName: string | undefined;
    sftP2Password: string | undefined;
    sftP2SshHostKeyFingerPrint: string | undefined;
    sftP2PortNumber: number | undefined;
    sftP2SFilePath: string | undefined;

    constructor(data?: ISftpSettingEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sftpurl = data["sftpurl"];
            this.sftpUserName = data["sftpUserName"];
            this.sftpPassword = data["sftpPassword"];
            this.sftpSshHostKeyFingerPrint = data["sftpSshHostKeyFingerPrint"];
            this.sftpPortNumber = data["sftpPortNumber"];
            this.sftpsFilePath = data["sftpsFilePath"];
            this.sftP2URL = data["sftP2URL"];
            this.sftP2UserName = data["sftP2UserName"];
            this.sftP2Password = data["sftP2Password"];
            this.sftP2SshHostKeyFingerPrint = data["sftP2SshHostKeyFingerPrint"];
            this.sftP2PortNumber = data["sftP2PortNumber"];
            this.sftP2SFilePath = data["sftP2SFilePath"];
        }
    }

    static fromJS(data: any): SftpSettingEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SftpSettingEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sftpurl"] = this.sftpurl;
        data["sftpUserName"] = this.sftpUserName;
        data["sftpPassword"] = this.sftpPassword;
        data["sftpSshHostKeyFingerPrint"] = this.sftpSshHostKeyFingerPrint;
        data["sftpPortNumber"] = this.sftpPortNumber;
        data["sftpsFilePath"] = this.sftpsFilePath;
        data["sftP2URL"] = this.sftP2URL;
        data["sftP2UserName"] = this.sftP2UserName;
        data["sftP2Password"] = this.sftP2Password;
        data["sftP2SshHostKeyFingerPrint"] = this.sftP2SshHostKeyFingerPrint;
        data["sftP2PortNumber"] = this.sftP2PortNumber;
        data["sftP2SFilePath"] = this.sftP2SFilePath;
        return data; 
    }

    clone(): SftpSettingEditDto {
        const json = this.toJSON();
        let result = new SftpSettingEditDto();
        result.init(json);
        return result;
    }
}

export interface ISftpSettingEditDto {
    sftpurl: string | undefined;
    sftpUserName: string | undefined;
    sftpPassword: string | undefined;
    sftpSshHostKeyFingerPrint: string | undefined;
    sftpPortNumber: number | undefined;
    sftpsFilePath: string | undefined;
    sftP2URL: string | undefined;
    sftP2UserName: string | undefined;
    sftP2Password: string | undefined;
    sftP2SshHostKeyFingerPrint: string | undefined;
    sftP2PortNumber: number | undefined;
    sftP2SFilePath: string | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit: boolean | undefined;
    requireLowercase: boolean | undefined;
    requireNonAlphanumeric: boolean | undefined;
    requireUppercase: boolean | undefined;
    requiredLength: number | undefined;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireDigit = data["requireDigit"];
            this.requireLowercase = data["requireLowercase"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireUppercase = data["requireUppercase"];
            this.requiredLength = data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }

    clone(): PasswordComplexitySetting {
        const json = this.toJSON();
        let result = new PasswordComplexitySetting();
        result.init(json);
        return result;
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean | undefined;
    requireLowercase: boolean | undefined;
    requireNonAlphanumeric: boolean | undefined;
    requireUppercase: boolean | undefined;
    requiredLength: number | undefined;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout: number | undefined;
    defaultAccountLockoutSeconds: number | undefined;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }

    clone(): UserLockOutSettingsEditDto {
        const json = this.toJSON();
        let result = new UserLockOutSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout: number | undefined;
    defaultAccountLockoutSeconds: number | undefined;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean | undefined;
    isEnabled: boolean | undefined;
    isEmailProviderEnabled: boolean | undefined;
    isSmsProviderEnabled: boolean | undefined;
    isRememberBrowserEnabled: boolean | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabledForApplication = data["isEnabledForApplication"];
            this.isEnabled = data["isEnabled"];
            this.isEmailProviderEnabled = data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }

    clone(): TwoFactorLoginSettingsEditDto {
        const json = this.toJSON();
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean | undefined;
    isEnabled: boolean | undefined;
    isEmailProviderEnabled: boolean | undefined;
    isSmsProviderEnabled: boolean | undefined;
    isRememberBrowserEnabled: boolean | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class HostSettingResultDto implements IHostSettingResultDto {
    requiredLogout: boolean | undefined;
    requiredRefresh: boolean | undefined;

    constructor(data?: IHostSettingResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requiredLogout = data["requiredLogout"];
            this.requiredRefresh = data["requiredRefresh"];
        }
    }

    static fromJS(data: any): HostSettingResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requiredLogout"] = this.requiredLogout;
        data["requiredRefresh"] = this.requiredRefresh;
        return data; 
    }

    clone(): HostSettingResultDto {
        const json = this.toJSON();
        let result = new HostSettingResultDto();
        result.init(json);
        return result;
    }
}

export interface IHostSettingResultDto {
    requiredLogout: boolean | undefined;
    requiredRefresh: boolean | undefined;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): SendTestEmailInput {
        const json = this.toJSON();
        let result = new SendTestEmailInput();
        result.init(json);
        return result;
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class InstallDto implements IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto | undefined;
    billInfo: HostBillingSettingsEditDto | undefined;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.connectionString = data["connectionString"];
            this.adminPassword = data["adminPassword"];
            this.webSiteUrl = data["webSiteUrl"];
            this.serverUrl = data["serverUrl"];
            this.defaultLanguage = data["defaultLanguage"];
            this.smtpSettings = data["smtpSettings"] ? EmailSettingsEditDto.fromJS(data["smtpSettings"]) : <any>undefined;
            this.billInfo = data["billInfo"] ? HostBillingSettingsEditDto.fromJS(data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data; 
    }

    clone(): InstallDto {
        const json = this.toJSON();
        let result = new InstallDto();
        result.init(json);
        return result;
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto | undefined;
    billInfo: HostBillingSettingsEditDto | undefined;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.webSiteUrl = data["webSiteUrl"];
            this.serverSiteUrl = data["serverSiteUrl"];
            if (data["languages"] && data["languages"].constructor === Array) {
                this.languages = [];
                for (let item of data["languages"])
                    this.languages.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (this.languages && this.languages.constructor === Array) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AppSettingsJsonDto {
        const json = this.toJSON();
        let result = new AppSettingsJsonDto();
        result.init(json);
        return result;
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;
}

export class NameValue implements INameValue {
    name: string | undefined;
    value: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): NameValue {
        const json = this.toJSON();
        let result = new NameValue();
        result.init(json);
        return result;
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist: boolean | undefined;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isDatabaseExist = data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data; 
    }

    clone(): CheckDatabaseOutput {
        const json = this.toJSON();
        let result = new CheckDatabaseOutput();
        result.init(json);
        return result;
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean | undefined;
}

export class CM_INSU_COMPANY_ENTITY implements ICM_INSU_COMPANY_ENTITY {
    insU_COMPANY_ID: string | undefined;
    insU_COMPANY_CODE: string | undefined;
    name: string | undefined;
    addr: string | undefined;
    email: string | undefined;
    tel: string | undefined;
    taX_NO: string | undefined;
    contacT_PERSON: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_INSU_COMPANY_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.insU_COMPANY_ID = data["insU_COMPANY_ID"];
            this.insU_COMPANY_CODE = data["insU_COMPANY_CODE"];
            this.name = data["name"];
            this.addr = data["addr"];
            this.email = data["email"];
            this.tel = data["tel"];
            this.taX_NO = data["taX_NO"];
            this.contacT_PERSON = data["contacT_PERSON"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_INSU_COMPANY_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_INSU_COMPANY_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["insU_COMPANY_ID"] = this.insU_COMPANY_ID;
        data["insU_COMPANY_CODE"] = this.insU_COMPANY_CODE;
        data["name"] = this.name;
        data["addr"] = this.addr;
        data["email"] = this.email;
        data["tel"] = this.tel;
        data["taX_NO"] = this.taX_NO;
        data["contacT_PERSON"] = this.contacT_PERSON;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_INSU_COMPANY_ENTITY {
        const json = this.toJSON();
        let result = new CM_INSU_COMPANY_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_INSU_COMPANY_ENTITY {
    insU_COMPANY_ID: string | undefined;
    insU_COMPANY_CODE: string | undefined;
    name: string | undefined;
    addr: string | undefined;
    email: string | undefined;
    tel: string | undefined;
    taX_NO: string | undefined;
    contacT_PERSON: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_INSU_COMPANY_ENTITY implements IPagedResultDtoOfCM_INSU_COMPANY_ENTITY {
    totalCount: number | undefined;
    items: CM_INSU_COMPANY_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_INSU_COMPANY_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_INSU_COMPANY_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_INSU_COMPANY_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_INSU_COMPANY_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_INSU_COMPANY_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_INSU_COMPANY_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_INSU_COMPANY_ENTITY {
    totalCount: number | undefined;
    items: CM_INSU_COMPANY_ENTITY[] | undefined;
}

export class InvoiceDto implements IInvoiceDto {
    amount: number | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: moment.Moment | undefined;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.invoiceDate = data["invoiceDate"] ? moment(data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = data["tenantLegalName"];
            if (data["tenantAddress"] && data["tenantAddress"].constructor === Array) {
                this.tenantAddress = [];
                for (let item of data["tenantAddress"])
                    this.tenantAddress.push(item);
            }
            this.tenantTaxNo = data["tenantTaxNo"];
            this.hostLegalName = data["hostLegalName"];
            if (data["hostAddress"] && data["hostAddress"].constructor === Array) {
                this.hostAddress = [];
                for (let item of data["hostAddress"])
                    this.hostAddress.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (this.tenantAddress && this.tenantAddress.constructor === Array) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (this.hostAddress && this.hostAddress.constructor === Array) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data; 
    }

    clone(): InvoiceDto {
        const json = this.toJSON();
        let result = new InvoiceDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDto {
    amount: number | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: moment.Moment | undefined;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId: number | undefined;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionPaymentId = data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data; 
    }

    clone(): CreateInvoiceDto {
        const json = this.toJSON();
        let result = new CreateInvoiceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number | undefined;
}

export class CM_ALL_KEY_ENTITY implements ICM_ALL_KEY_ENTITY {
    keyworD_ID: string | undefined;
    keyworD_CODE: string | undefined;
    grouP_ID: string | undefined;
    content: string | undefined;
    numbeR_OF_SEARCH: number | undefined;
    allinanchor: number | undefined;
    indeX_RANK: number | undefined;
    difficultY_LEVEL: number | undefined;
    approvE_STATUS: number | undefined;
    solaN_TRINHKI: number | undefined;
    editoR_ID: string | undefined;
    editoR_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    grouP_NAME: string | undefined;
    grouP_LEVEL1: string | undefined;
    grouP_LEVEL2: string | undefined;
    grouP_LEVEL3: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_ALL_KEY_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.keyworD_ID = data["keyworD_ID"];
            this.keyworD_CODE = data["keyworD_CODE"];
            this.grouP_ID = data["grouP_ID"];
            this.content = data["content"];
            this.numbeR_OF_SEARCH = data["numbeR_OF_SEARCH"];
            this.allinanchor = data["allinanchor"];
            this.indeX_RANK = data["indeX_RANK"];
            this.difficultY_LEVEL = data["difficultY_LEVEL"];
            this.approvE_STATUS = data["approvE_STATUS"];
            this.solaN_TRINHKI = data["solaN_TRINHKI"];
            this.editoR_ID = data["editoR_ID"];
            this.editoR_DT = data["editoR_DT"] ? moment(data["editoR_DT"].toString()) : <any>undefined;
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.grouP_NAME = data["grouP_NAME"];
            this.grouP_LEVEL1 = data["grouP_LEVEL1"];
            this.grouP_LEVEL2 = data["grouP_LEVEL2"];
            this.grouP_LEVEL3 = data["grouP_LEVEL3"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_ALL_KEY_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_ALL_KEY_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyworD_ID"] = this.keyworD_ID;
        data["keyworD_CODE"] = this.keyworD_CODE;
        data["grouP_ID"] = this.grouP_ID;
        data["content"] = this.content;
        data["numbeR_OF_SEARCH"] = this.numbeR_OF_SEARCH;
        data["allinanchor"] = this.allinanchor;
        data["indeX_RANK"] = this.indeX_RANK;
        data["difficultY_LEVEL"] = this.difficultY_LEVEL;
        data["approvE_STATUS"] = this.approvE_STATUS;
        data["solaN_TRINHKI"] = this.solaN_TRINHKI;
        data["editoR_ID"] = this.editoR_ID;
        data["editoR_DT"] = this.editoR_DT ? this.editoR_DT.toISOString() : <any>undefined;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["grouP_NAME"] = this.grouP_NAME;
        data["grouP_LEVEL1"] = this.grouP_LEVEL1;
        data["grouP_LEVEL2"] = this.grouP_LEVEL2;
        data["grouP_LEVEL3"] = this.grouP_LEVEL3;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_ALL_KEY_ENTITY {
        const json = this.toJSON();
        let result = new CM_ALL_KEY_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_ALL_KEY_ENTITY {
    keyworD_ID: string | undefined;
    keyworD_CODE: string | undefined;
    grouP_ID: string | undefined;
    content: string | undefined;
    numbeR_OF_SEARCH: number | undefined;
    allinanchor: number | undefined;
    indeX_RANK: number | undefined;
    difficultY_LEVEL: number | undefined;
    approvE_STATUS: number | undefined;
    solaN_TRINHKI: number | undefined;
    editoR_ID: string | undefined;
    editoR_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    grouP_NAME: string | undefined;
    grouP_LEVEL1: string | undefined;
    grouP_LEVEL2: string | undefined;
    grouP_LEVEL3: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_ALL_KEY_ENTITY implements IPagedResultDtoOfCM_ALL_KEY_ENTITY {
    totalCount: number | undefined;
    items: CM_ALL_KEY_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_ALL_KEY_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_ALL_KEY_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_ALL_KEY_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_ALL_KEY_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_ALL_KEY_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_ALL_KEY_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_ALL_KEY_ENTITY {
    totalCount: number | undefined;
    items: CM_ALL_KEY_ENTITY[] | undefined;
}

export class CM_KHOI_ENTITY implements ICM_KHOI_ENTITY {
    khoI_ID: string | undefined;
    khoI_CODE: string | undefined;
    khoI_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    cM_KHOI_DTs: CM_KHOI_DT_ENTITY[] | undefined;
    cM_KHOI_XML: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_KHOI_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.khoI_ID = data["khoI_ID"];
            this.khoI_CODE = data["khoI_CODE"];
            this.khoI_NAME = data["khoI_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            if (data["cM_KHOI_DTs"] && data["cM_KHOI_DTs"].constructor === Array) {
                this.cM_KHOI_DTs = [];
                for (let item of data["cM_KHOI_DTs"])
                    this.cM_KHOI_DTs.push(CM_KHOI_DT_ENTITY.fromJS(item));
            }
            this.cM_KHOI_XML = data["cM_KHOI_XML"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_KHOI_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_KHOI_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["khoI_ID"] = this.khoI_ID;
        data["khoI_CODE"] = this.khoI_CODE;
        data["khoI_NAME"] = this.khoI_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        if (this.cM_KHOI_DTs && this.cM_KHOI_DTs.constructor === Array) {
            data["cM_KHOI_DTs"] = [];
            for (let item of this.cM_KHOI_DTs)
                data["cM_KHOI_DTs"].push(item.toJSON());
        }
        data["cM_KHOI_XML"] = this.cM_KHOI_XML;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_KHOI_ENTITY {
        const json = this.toJSON();
        let result = new CM_KHOI_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_KHOI_ENTITY {
    khoI_ID: string | undefined;
    khoI_CODE: string | undefined;
    khoI_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    cM_KHOI_DTs: CM_KHOI_DT_ENTITY[] | undefined;
    cM_KHOI_XML: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class CM_KHOI_DT_ENTITY implements ICM_KHOI_DT_ENTITY {
    kdT_ID: string | undefined;
    khoI_ID: string | undefined;
    khoI_CODE: string | undefined;
    khoI_NAME: string | undefined;
    deP_ID: string | undefined;
    brancH_ID: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    tscd: number | undefined;
    ccld: number | undefined;
    btsc: number | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    brancH_CODE: string | undefined;
    brancH_NAME: string | undefined;
    deP_CODE: string | undefined;
    deP_NAME: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_KHOI_DT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.kdT_ID = data["kdT_ID"];
            this.khoI_ID = data["khoI_ID"];
            this.khoI_CODE = data["khoI_CODE"];
            this.khoI_NAME = data["khoI_NAME"];
            this.deP_ID = data["deP_ID"];
            this.brancH_ID = data["brancH_ID"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.tscd = data["tscd"];
            this.ccld = data["ccld"];
            this.btsc = data["btsc"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.brancH_CODE = data["brancH_CODE"];
            this.brancH_NAME = data["brancH_NAME"];
            this.deP_CODE = data["deP_CODE"];
            this.deP_NAME = data["deP_NAME"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_KHOI_DT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_KHOI_DT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kdT_ID"] = this.kdT_ID;
        data["khoI_ID"] = this.khoI_ID;
        data["khoI_CODE"] = this.khoI_CODE;
        data["khoI_NAME"] = this.khoI_NAME;
        data["deP_ID"] = this.deP_ID;
        data["brancH_ID"] = this.brancH_ID;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["tscd"] = this.tscd;
        data["ccld"] = this.ccld;
        data["btsc"] = this.btsc;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["brancH_CODE"] = this.brancH_CODE;
        data["brancH_NAME"] = this.brancH_NAME;
        data["deP_CODE"] = this.deP_CODE;
        data["deP_NAME"] = this.deP_NAME;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_KHOI_DT_ENTITY {
        const json = this.toJSON();
        let result = new CM_KHOI_DT_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_KHOI_DT_ENTITY {
    kdT_ID: string | undefined;
    khoI_ID: string | undefined;
    khoI_CODE: string | undefined;
    khoI_NAME: string | undefined;
    deP_ID: string | undefined;
    brancH_ID: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    tscd: number | undefined;
    ccld: number | undefined;
    btsc: number | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    brancH_CODE: string | undefined;
    brancH_NAME: string | undefined;
    deP_CODE: string | undefined;
    deP_NAME: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_KHOI_ENTITY implements IPagedResultDtoOfCM_KHOI_ENTITY {
    totalCount: number | undefined;
    items: CM_KHOI_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_KHOI_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_KHOI_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_KHOI_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_KHOI_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_KHOI_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_KHOI_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_KHOI_ENTITY {
    totalCount: number | undefined;
    items: CM_KHOI_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_KHOI_DT_ENTITY implements IPagedResultDtoOfCM_KHOI_DT_ENTITY {
    totalCount: number | undefined;
    items: CM_KHOI_DT_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_KHOI_DT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_KHOI_DT_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_KHOI_DT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_KHOI_DT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_KHOI_DT_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_KHOI_DT_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_KHOI_DT_ENTITY {
    totalCount: number | undefined;
    items: CM_KHOI_DT_ENTITY[] | undefined;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultLanguageName = data["defaultLanguageName"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetLanguagesOutput {
        const json = this.toJSON();
        let result = new GetLanguagesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDisabled = data["isDisabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ApplicationLanguageListDto {
        const json = this.toJSON();
        let result = new ApplicationLanguageListDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto | undefined;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : <any>undefined;
            if (data["languageNames"] && data["languageNames"].constructor === Array) {
                this.languageNames = [];
                for (let item of data["languageNames"])
                    this.languageNames.push(ComboboxItemDto.fromJS(item));
            }
            if (data["flags"] && data["flags"].constructor === Array) {
                this.flags = [];
                for (let item of data["flags"])
                    this.flags.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (this.languageNames && this.languageNames.constructor === Array) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (this.flags && this.flags.constructor === Array) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetLanguageForEditOutput {
        const json = this.toJSON();
        let result = new GetLanguageForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto | undefined;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean | undefined;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): ApplicationLanguageEditDto {
        const json = this.toJSON();
        let result = new ApplicationLanguageEditDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean | undefined;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }

    clone(): ComboboxItemDto {
        const json = this.toJSON();
        let result = new ComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateLanguageInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateLanguageInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): SetDefaultLanguageInput {
        const json = this.toJSON();
        let result = new SetDefaultLanguageInput();
        result.init(json);
        return result;
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount: number | undefined;
    items: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfLanguageTextListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number | undefined;
    items: LanguageTextListDto[] | undefined;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    id: number | undefined;
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.key = data["key"];
            this.baseValue = data["baseValue"];
            this.targetValue = data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }

    clone(): LanguageTextListDto {
        const json = this.toJSON();
        let result = new LanguageTextListDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageTextListDto {
    id: number | undefined;
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    mode: string | undefined;
    languageName: string;
    sourceName: string;
    key: string;
    value: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mode = data["mode"];
            this.languageName = data["languageName"];
            this.sourceName = data["sourceName"];
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mode"] = this.mode;
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }

    clone(): UpdateLanguageTextInput {
        const json = this.toJSON();
        let result = new UpdateLanguageTextInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateLanguageTextInput {
    mode: string | undefined;
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class HR_LichSuGuiMail_ENTITY implements IHR_LichSuGuiMail_ENTITY {
    lichSuGuiMail_Id: string | undefined;
    mailTemplate_Id: string | undefined;
    creationTime: moment.Moment | undefined;
    creatorUser_Id: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUser_Id: string | undefined;
    deleterUser_Id: string | undefined;
    deletionTime: moment.Moment | undefined;
    ungVien_Id: string | undefined;
    noiDung: string | undefined;
    tepDinhKem: string | undefined;
    tieuDeEmail: string | undefined;
    phieuNghiPhep_Id: string | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IHR_LichSuGuiMail_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lichSuGuiMail_Id = data["lichSuGuiMail_Id"];
            this.mailTemplate_Id = data["mailTemplate_Id"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUser_Id = data["creatorUser_Id"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUser_Id = data["lastModifierUser_Id"];
            this.deleterUser_Id = data["deleterUser_Id"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.ungVien_Id = data["ungVien_Id"];
            this.noiDung = data["noiDung"];
            this.tepDinhKem = data["tepDinhKem"];
            this.tieuDeEmail = data["tieuDeEmail"];
            this.phieuNghiPhep_Id = data["phieuNghiPhep_Id"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): HR_LichSuGuiMail_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HR_LichSuGuiMail_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lichSuGuiMail_Id"] = this.lichSuGuiMail_Id;
        data["mailTemplate_Id"] = this.mailTemplate_Id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUser_Id"] = this.creatorUser_Id;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUser_Id"] = this.lastModifierUser_Id;
        data["deleterUser_Id"] = this.deleterUser_Id;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["ungVien_Id"] = this.ungVien_Id;
        data["noiDung"] = this.noiDung;
        data["tepDinhKem"] = this.tepDinhKem;
        data["tieuDeEmail"] = this.tieuDeEmail;
        data["phieuNghiPhep_Id"] = this.phieuNghiPhep_Id;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): HR_LichSuGuiMail_ENTITY {
        const json = this.toJSON();
        let result = new HR_LichSuGuiMail_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHR_LichSuGuiMail_ENTITY {
    lichSuGuiMail_Id: string | undefined;
    mailTemplate_Id: string | undefined;
    creationTime: moment.Moment | undefined;
    creatorUser_Id: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUser_Id: string | undefined;
    deleterUser_Id: string | undefined;
    deletionTime: moment.Moment | undefined;
    ungVien_Id: string | undefined;
    noiDung: string | undefined;
    tepDinhKem: string | undefined;
    tieuDeEmail: string | undefined;
    phieuNghiPhep_Id: string | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfHR_LichSuGuiMail_ENTITY implements IPagedResultDtoOfHR_LichSuGuiMail_ENTITY {
    totalCount: number | undefined;
    items: HR_LichSuGuiMail_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfHR_LichSuGuiMail_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(HR_LichSuGuiMail_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfHR_LichSuGuiMail_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfHR_LichSuGuiMail_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfHR_LichSuGuiMail_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfHR_LichSuGuiMail_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfHR_LichSuGuiMail_ENTITY {
    totalCount: number | undefined;
    items: HR_LichSuGuiMail_ENTITY[] | undefined;
}

export class T_LIQUID_CANCEL_ENTITY implements IT_LIQUID_CANCEL_ENTITY {
    liquiD_CANCEL_ID: string | undefined;
    liquiD_CANCEL_CODE: string | undefined;
    asS_ID: string | undefined;
    asS_CODE: string | undefined;
    reason: string | undefined;
    requesT_NAME: string | undefined;
    requesT_DT: moment.Moment | undefined;
    brancH_ID: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    notes: string | undefined;
    autH_STATUS_NAME: string | undefined;
    asseT_NAME: string | undefined;
    level: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IT_LIQUID_CANCEL_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.liquiD_CANCEL_ID = data["liquiD_CANCEL_ID"];
            this.liquiD_CANCEL_CODE = data["liquiD_CANCEL_CODE"];
            this.asS_ID = data["asS_ID"];
            this.asS_CODE = data["asS_CODE"];
            this.reason = data["reason"];
            this.requesT_NAME = data["requesT_NAME"];
            this.requesT_DT = data["requesT_DT"] ? moment(data["requesT_DT"].toString()) : <any>undefined;
            this.brancH_ID = data["brancH_ID"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.autH_STATUS = data["autH_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.asseT_NAME = data["asseT_NAME"];
            this.level = data["level"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): T_LIQUID_CANCEL_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new T_LIQUID_CANCEL_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["liquiD_CANCEL_ID"] = this.liquiD_CANCEL_ID;
        data["liquiD_CANCEL_CODE"] = this.liquiD_CANCEL_CODE;
        data["asS_ID"] = this.asS_ID;
        data["asS_CODE"] = this.asS_CODE;
        data["reason"] = this.reason;
        data["requesT_NAME"] = this.requesT_NAME;
        data["requesT_DT"] = this.requesT_DT ? this.requesT_DT.toISOString() : <any>undefined;
        data["brancH_ID"] = this.brancH_ID;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["autH_STATUS"] = this.autH_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["asseT_NAME"] = this.asseT_NAME;
        data["level"] = this.level;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): T_LIQUID_CANCEL_ENTITY {
        const json = this.toJSON();
        let result = new T_LIQUID_CANCEL_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IT_LIQUID_CANCEL_ENTITY {
    liquiD_CANCEL_ID: string | undefined;
    liquiD_CANCEL_CODE: string | undefined;
    asS_ID: string | undefined;
    asS_CODE: string | undefined;
    reason: string | undefined;
    requesT_NAME: string | undefined;
    requesT_DT: moment.Moment | undefined;
    brancH_ID: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    notes: string | undefined;
    autH_STATUS_NAME: string | undefined;
    asseT_NAME: string | undefined;
    level: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfT_LIQUID_CANCEL_ENTITY implements IPagedResultDtoOfT_LIQUID_CANCEL_ENTITY {
    totalCount: number | undefined;
    items: T_LIQUID_CANCEL_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfT_LIQUID_CANCEL_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(T_LIQUID_CANCEL_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfT_LIQUID_CANCEL_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfT_LIQUID_CANCEL_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfT_LIQUID_CANCEL_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfT_LIQUID_CANCEL_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfT_LIQUID_CANCEL_ENTITY {
    totalCount: number | undefined;
    items: T_LIQUID_CANCEL_ENTITY[] | undefined;
}

export class CM_LOCATION_ENTITY implements ICM_LOCATION_ENTITY {
    districTs: CM_DISTRICT[] | undefined;
    warDs: CM_WARD[] | undefined;
    natioNs: CM_NATION[] | undefined;
    provincEs: CM_PROVINCE[] | undefined;

    constructor(data?: ICM_LOCATION_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["districTs"] && data["districTs"].constructor === Array) {
                this.districTs = [];
                for (let item of data["districTs"])
                    this.districTs.push(CM_DISTRICT.fromJS(item));
            }
            if (data["warDs"] && data["warDs"].constructor === Array) {
                this.warDs = [];
                for (let item of data["warDs"])
                    this.warDs.push(CM_WARD.fromJS(item));
            }
            if (data["natioNs"] && data["natioNs"].constructor === Array) {
                this.natioNs = [];
                for (let item of data["natioNs"])
                    this.natioNs.push(CM_NATION.fromJS(item));
            }
            if (data["provincEs"] && data["provincEs"].constructor === Array) {
                this.provincEs = [];
                for (let item of data["provincEs"])
                    this.provincEs.push(CM_PROVINCE.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CM_LOCATION_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_LOCATION_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.districTs && this.districTs.constructor === Array) {
            data["districTs"] = [];
            for (let item of this.districTs)
                data["districTs"].push(item.toJSON());
        }
        if (this.warDs && this.warDs.constructor === Array) {
            data["warDs"] = [];
            for (let item of this.warDs)
                data["warDs"].push(item.toJSON());
        }
        if (this.natioNs && this.natioNs.constructor === Array) {
            data["natioNs"] = [];
            for (let item of this.natioNs)
                data["natioNs"].push(item.toJSON());
        }
        if (this.provincEs && this.provincEs.constructor === Array) {
            data["provincEs"] = [];
            for (let item of this.provincEs)
                data["provincEs"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CM_LOCATION_ENTITY {
        const json = this.toJSON();
        let result = new CM_LOCATION_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_LOCATION_ENTITY {
    districTs: CM_DISTRICT[] | undefined;
    warDs: CM_WARD[] | undefined;
    natioNs: CM_NATION[] | undefined;
    provincEs: CM_PROVINCE[] | undefined;
}

export class CM_DISTRICT implements ICM_DISTRICT {
    diS_ID: string | undefined;
    diS_CODE: string | undefined;
    prO_ID: string | undefined;
    diS_NAME: string | undefined;
    diS_TYPE: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    createdate: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeD_ID: string | undefined;
    datE_APPROVE: moment.Moment | undefined;

    constructor(data?: ICM_DISTRICT) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.diS_ID = data["diS_ID"];
            this.diS_CODE = data["diS_CODE"];
            this.prO_ID = data["prO_ID"];
            this.diS_NAME = data["diS_NAME"];
            this.diS_TYPE = data["diS_TYPE"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.createdate = data["createdate"] ? moment(data["createdate"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeD_ID = data["checkeD_ID"];
            this.datE_APPROVE = data["datE_APPROVE"] ? moment(data["datE_APPROVE"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CM_DISTRICT {
        data = typeof data === 'object' ? data : {};
        let result = new CM_DISTRICT();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["diS_ID"] = this.diS_ID;
        data["diS_CODE"] = this.diS_CODE;
        data["prO_ID"] = this.prO_ID;
        data["diS_NAME"] = this.diS_NAME;
        data["diS_TYPE"] = this.diS_TYPE;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["createdate"] = this.createdate ? this.createdate.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeD_ID"] = this.checkeD_ID;
        data["datE_APPROVE"] = this.datE_APPROVE ? this.datE_APPROVE.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CM_DISTRICT {
        const json = this.toJSON();
        let result = new CM_DISTRICT();
        result.init(json);
        return result;
    }
}

export interface ICM_DISTRICT {
    diS_ID: string | undefined;
    diS_CODE: string | undefined;
    prO_ID: string | undefined;
    diS_NAME: string | undefined;
    diS_TYPE: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    createdate: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeD_ID: string | undefined;
    datE_APPROVE: moment.Moment | undefined;
}

export class CM_WARD implements ICM_WARD {
    waR_ID: string | undefined;
    waR_CODE: string | undefined;
    diS_ID: string | undefined;
    waR_NAME: string | undefined;
    waR_TYPE: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    createdate: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeD_ID: string | undefined;
    datE_APPROVE: moment.Moment | undefined;

    constructor(data?: ICM_WARD) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.waR_ID = data["waR_ID"];
            this.waR_CODE = data["waR_CODE"];
            this.diS_ID = data["diS_ID"];
            this.waR_NAME = data["waR_NAME"];
            this.waR_TYPE = data["waR_TYPE"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.createdate = data["createdate"] ? moment(data["createdate"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeD_ID = data["checkeD_ID"];
            this.datE_APPROVE = data["datE_APPROVE"] ? moment(data["datE_APPROVE"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CM_WARD {
        data = typeof data === 'object' ? data : {};
        let result = new CM_WARD();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["waR_ID"] = this.waR_ID;
        data["waR_CODE"] = this.waR_CODE;
        data["diS_ID"] = this.diS_ID;
        data["waR_NAME"] = this.waR_NAME;
        data["waR_TYPE"] = this.waR_TYPE;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["createdate"] = this.createdate ? this.createdate.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeD_ID"] = this.checkeD_ID;
        data["datE_APPROVE"] = this.datE_APPROVE ? this.datE_APPROVE.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CM_WARD {
        const json = this.toJSON();
        let result = new CM_WARD();
        result.init(json);
        return result;
    }
}

export interface ICM_WARD {
    waR_ID: string | undefined;
    waR_CODE: string | undefined;
    diS_ID: string | undefined;
    waR_NAME: string | undefined;
    waR_TYPE: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    createdate: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeD_ID: string | undefined;
    datE_APPROVE: moment.Moment | undefined;
}

export class CM_NATION implements ICM_NATION {
    naT_ID: string | undefined;
    naT_CODE: string | undefined;
    naT_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    createdate: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeD_ID: string | undefined;
    datE_APPROVE: moment.Moment | undefined;

    constructor(data?: ICM_NATION) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.naT_ID = data["naT_ID"];
            this.naT_CODE = data["naT_CODE"];
            this.naT_NAME = data["naT_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.createdate = data["createdate"] ? moment(data["createdate"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeD_ID = data["checkeD_ID"];
            this.datE_APPROVE = data["datE_APPROVE"] ? moment(data["datE_APPROVE"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CM_NATION {
        data = typeof data === 'object' ? data : {};
        let result = new CM_NATION();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["naT_ID"] = this.naT_ID;
        data["naT_CODE"] = this.naT_CODE;
        data["naT_NAME"] = this.naT_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["createdate"] = this.createdate ? this.createdate.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeD_ID"] = this.checkeD_ID;
        data["datE_APPROVE"] = this.datE_APPROVE ? this.datE_APPROVE.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CM_NATION {
        const json = this.toJSON();
        let result = new CM_NATION();
        result.init(json);
        return result;
    }
}

export interface ICM_NATION {
    naT_ID: string | undefined;
    naT_CODE: string | undefined;
    naT_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    createdate: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeD_ID: string | undefined;
    datE_APPROVE: moment.Moment | undefined;
}

export class CM_PROVINCE implements ICM_PROVINCE {
    prO_ID: string | undefined;
    prO_CODE: string | undefined;
    naT_ID: string | undefined;
    prO_NAME: string | undefined;
    prO_TYPE: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    createdate: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeD_ID: string | undefined;
    datE_APPROVE: moment.Moment | undefined;

    constructor(data?: ICM_PROVINCE) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.prO_ID = data["prO_ID"];
            this.prO_CODE = data["prO_CODE"];
            this.naT_ID = data["naT_ID"];
            this.prO_NAME = data["prO_NAME"];
            this.prO_TYPE = data["prO_TYPE"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.createdate = data["createdate"] ? moment(data["createdate"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeD_ID = data["checkeD_ID"];
            this.datE_APPROVE = data["datE_APPROVE"] ? moment(data["datE_APPROVE"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CM_PROVINCE {
        data = typeof data === 'object' ? data : {};
        let result = new CM_PROVINCE();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prO_ID"] = this.prO_ID;
        data["prO_CODE"] = this.prO_CODE;
        data["naT_ID"] = this.naT_ID;
        data["prO_NAME"] = this.prO_NAME;
        data["prO_TYPE"] = this.prO_TYPE;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["createdate"] = this.createdate ? this.createdate.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeD_ID"] = this.checkeD_ID;
        data["datE_APPROVE"] = this.datE_APPROVE ? this.datE_APPROVE.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CM_PROVINCE {
        const json = this.toJSON();
        let result = new CM_PROVINCE();
        result.init(json);
        return result;
    }
}

export interface ICM_PROVINCE {
    prO_ID: string | undefined;
    prO_CODE: string | undefined;
    naT_ID: string | undefined;
    prO_NAME: string | undefined;
    prO_TYPE: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    createdate: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeD_ID: string | undefined;
    datE_APPROVE: moment.Moment | undefined;
}

export class CM_MODEL_ENTITY implements ICM_MODEL_ENTITY {
    mO_ID: string | undefined;
    mO_CODE: string | undefined;
    caR_TYPE_ID: string | undefined;
    manufacturer: string | undefined;
    poweR_RATE: number | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    mO_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    caR_TYPE_NAME: string | undefined;
    manufactureR_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_MODEL_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mO_ID = data["mO_ID"];
            this.mO_CODE = data["mO_CODE"];
            this.caR_TYPE_ID = data["caR_TYPE_ID"];
            this.manufacturer = data["manufacturer"];
            this.poweR_RATE = data["poweR_RATE"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.autH_STATUS = data["autH_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.mO_NAME = data["mO_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.caR_TYPE_NAME = data["caR_TYPE_NAME"];
            this.manufactureR_NAME = data["manufactureR_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_MODEL_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_MODEL_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mO_ID"] = this.mO_ID;
        data["mO_CODE"] = this.mO_CODE;
        data["caR_TYPE_ID"] = this.caR_TYPE_ID;
        data["manufacturer"] = this.manufacturer;
        data["poweR_RATE"] = this.poweR_RATE;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["autH_STATUS"] = this.autH_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["mO_NAME"] = this.mO_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["caR_TYPE_NAME"] = this.caR_TYPE_NAME;
        data["manufactureR_NAME"] = this.manufactureR_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_MODEL_ENTITY {
        const json = this.toJSON();
        let result = new CM_MODEL_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_MODEL_ENTITY {
    mO_ID: string | undefined;
    mO_CODE: string | undefined;
    caR_TYPE_ID: string | undefined;
    manufacturer: string | undefined;
    poweR_RATE: number | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    mO_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    caR_TYPE_NAME: string | undefined;
    manufactureR_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_MODEL_ENTITY implements IPagedResultDtoOfCM_MODEL_ENTITY {
    totalCount: number | undefined;
    items: CM_MODEL_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_MODEL_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_MODEL_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_MODEL_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_MODEL_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_MODEL_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_MODEL_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_MODEL_ENTITY {
    totalCount: number | undefined;
    items: CM_MODEL_ENTITY[] | undefined;
}

export class PagedResultDtoOfHR_NoiDaoTao_ENTITY implements IPagedResultDtoOfHR_NoiDaoTao_ENTITY {
    totalCount: number | undefined;
    items: HR_NoiDaoTao_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfHR_NoiDaoTao_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(HR_NoiDaoTao_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfHR_NoiDaoTao_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfHR_NoiDaoTao_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfHR_NoiDaoTao_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfHR_NoiDaoTao_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfHR_NoiDaoTao_ENTITY {
    totalCount: number | undefined;
    items: HR_NoiDaoTao_ENTITY[] | undefined;
}

export class PagedResultDtoOfHR_NOIKHAMCHUABENH_ENTITY implements IPagedResultDtoOfHR_NOIKHAMCHUABENH_ENTITY {
    totalCount: number | undefined;
    items: HR_NOIKHAMCHUABENH_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfHR_NOIKHAMCHUABENH_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(HR_NOIKHAMCHUABENH_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfHR_NOIKHAMCHUABENH_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfHR_NOIKHAMCHUABENH_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfHR_NOIKHAMCHUABENH_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfHR_NOIKHAMCHUABENH_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfHR_NOIKHAMCHUABENH_ENTITY {
    totalCount: number | undefined;
    items: HR_NOIKHAMCHUABENH_ENTITY[] | undefined;
}

export enum UserNotificationState {
    Unread = 0, 
    Read = 1, 
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount: number | undefined;
    totalCount: number | undefined;
    items: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unreadCount = data["unreadCount"];
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetNotificationsOutput {
        const json = this.toJSON();
        let result = new GetNotificationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number | undefined;
    totalCount: number | undefined;
    items: UserNotification[] | undefined;
}

export class UserNotification implements IUserNotification {
    tenantId: number | undefined;
    userId: number | undefined;
    state: UserNotificationState | undefined;
    notification: TenantNotification | undefined;
    id: string | undefined;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotification.fromJS(data["notification"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserNotification {
        const json = this.toJSON();
        let result = new UserNotification();
        result.init(json);
        return result;
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number | undefined;
    state: UserNotificationState | undefined;
    notification: TenantNotification | undefined;
    id: string | undefined;
}

export class TenantNotification implements ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData | undefined;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity | undefined;
    creationTime: moment.Moment | undefined;
    id: string | undefined;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.entityTypeName = data["entityTypeName"];
            this.entityId = data["entityId"];
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantNotification {
        const json = this.toJSON();
        let result = new TenantNotification();
        result.init(json);
        return result;
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData | undefined;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity | undefined;
    creationTime: moment.Moment | undefined;
    id: string | undefined;
}

export class NotificationData implements INotificationData {
    type: string | undefined;
    properties: { [key: string] : any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            if (data["properties"]) {
                this.properties = {};
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties[key] = data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }

    clone(): NotificationData {
        const json = this.toJSON();
        let result = new NotificationData();
        result.init(json);
        return result;
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string] : any; } | undefined;
}

export enum NotificationSeverity {
    Info = 0, 
    Success = 1, 
    Warn = 2, 
    Error = 3, 
    Fatal = 4, 
}

export class UserNotificationInfoWithNotificationInfo implements IUserNotificationInfoWithNotificationInfo {
    userNotification: UserNotificationInfo | undefined;
    notification: TenantNotificationInfo | undefined;

    constructor(data?: IUserNotificationInfoWithNotificationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNotification = data["userNotification"] ? UserNotificationInfo.fromJS(data["userNotification"]) : <any>undefined;
            this.notification = data["notification"] ? TenantNotificationInfo.fromJS(data["notification"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserNotificationInfoWithNotificationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotificationInfoWithNotificationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNotification"] = this.userNotification ? this.userNotification.toJSON() : <any>undefined;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        return data; 
    }

    clone(): UserNotificationInfoWithNotificationInfo {
        const json = this.toJSON();
        let result = new UserNotificationInfoWithNotificationInfo();
        result.init(json);
        return result;
    }
}

export interface IUserNotificationInfoWithNotificationInfo {
    userNotification: UserNotificationInfo | undefined;
    notification: TenantNotificationInfo | undefined;
}

export class UserNotificationInfo implements IUserNotificationInfo {
    tenantId: number | undefined;
    userId: number | undefined;
    tenantNotificationId: string;
    state: UserNotificationState | undefined;
    creationTime: moment.Moment | undefined;
    id: string | undefined;

    constructor(data?: IUserNotificationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.tenantNotificationId = data["tenantNotificationId"];
            this.state = data["state"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserNotificationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotificationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["tenantNotificationId"] = this.tenantNotificationId;
        data["state"] = this.state;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserNotificationInfo {
        const json = this.toJSON();
        let result = new UserNotificationInfo();
        result.init(json);
        return result;
    }
}

export interface IUserNotificationInfo {
    tenantId: number | undefined;
    userId: number | undefined;
    tenantNotificationId: string;
    state: UserNotificationState | undefined;
    creationTime: moment.Moment | undefined;
    id: string | undefined;
}

export class TenantNotificationInfo implements ITenantNotificationInfo {
    tenantId: number | undefined;
    notificationName: string;
    data: string | undefined;
    dataTypeName: string | undefined;
    entityTypeName: string | undefined;
    entityTypeAssemblyQualifiedName: string | undefined;
    entityId: string | undefined;
    severity: NotificationSeverity | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ITenantNotificationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"];
            this.dataTypeName = data["dataTypeName"];
            this.entityTypeName = data["entityTypeName"];
            this.entityTypeAssemblyQualifiedName = data["entityTypeAssemblyQualifiedName"];
            this.entityId = data["entityId"];
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantNotificationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotificationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data;
        data["dataTypeName"] = this.dataTypeName;
        data["entityTypeName"] = this.entityTypeName;
        data["entityTypeAssemblyQualifiedName"] = this.entityTypeAssemblyQualifiedName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantNotificationInfo {
        const json = this.toJSON();
        let result = new TenantNotificationInfo();
        result.init(json);
        return result;
    }
}

export interface ITenantNotificationInfo {
    tenantId: number | undefined;
    notificationName: string;
    data: string | undefined;
    dataTypeName: string | undefined;
    entityTypeName: string | undefined;
    entityTypeAssemblyQualifiedName: string | undefined;
    entityId: string | undefined;
    severity: NotificationSeverity | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id: string | undefined;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDtoOfGuid {
        const json = this.toJSON();
        let result = new EntityDtoOfGuid();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfGuid {
    id: string | undefined;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetNotificationSettingsOutput {
        const json = this.toJSON();
        let result = new GetNotificationSettingsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean | undefined;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }

    clone(): NotificationSubscriptionWithDisplayNameDto {
        const json = this.toJSON();
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(json);
        return result;
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean | undefined;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdateNotificationSettingsInput {
        const json = this.toJSON();
        let result = new UpdateNotificationSettingsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean | undefined;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }

    clone(): NotificationSubscriptionDto {
        const json = this.toJSON();
        let result = new NotificationSubscriptionDto();
        result.init(json);
        return result;
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean | undefined;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfOrganizationUnitDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number | undefined;
    items: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfOrganizationUnitUserListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number | undefined;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationUnitUserListDto {
        const json = this.toJSON();
        let result = new OrganizationUnitUserListDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number | undefined;
    items: OrganizationUnitRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfOrganizationUnitRoleListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number | undefined;
    items: OrganizationUnitRoleListDto[] | undefined;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.name = data["name"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationUnitRoleListDto {
        const json = this.toJSON();
        let result = new OrganizationUnitRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): CreateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new CreateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id: number | undefined;
    displayName: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): UpdateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UpdateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number | undefined;
    displayName: string;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id: number | undefined;
    newParentId: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }

    clone(): MoveOrganizationUnitInput {
        const json = this.toJSON();
        let result = new MoveOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IMoveOrganizationUnitInput {
    id: number | undefined;
    newParentId: number | undefined;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number | undefined;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [];
                for (let item of data["userIds"])
                    this.userIds.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone(): UsersToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UsersToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number | undefined;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["roleIds"] && data["roleIds"].constructor === Array) {
                this.roleIds = [];
                for (let item of data["roleIds"])
                    this.roleIds.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.roleIds && this.roleIds.constructor === Array) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone(): RolesToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new RolesToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }

    clone(): FindOrganizationUnitUsersInput {
        const json = this.toJSON();
        let result = new FindOrganizationUnitUsersInput();
        result.init(json);
        return result;
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;

    constructor(data?: IFindOrganizationUnitRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }

    clone(): FindOrganizationUnitRolesInput {
        const json = this.toJSON();
        let result = new FindOrganizationUnitRolesInput();
        result.init(json);
        return result;
    }
}

export interface IFindOrganizationUnitRolesInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition: EditionSelectDto | undefined;
    additionalPrice: number | undefined;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            this.additionalPrice = data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data; 
    }

    clone(): PaymentInfoDto {
        const json = this.toJSON();
        let result = new PaymentInfoDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto | undefined;
    additionalPrice: number | undefined;
}

export class EditionSelectDto implements IEditionSelectDto {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean | undefined;
    additionalData: AdditionalData | undefined;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.isFree = data["isFree"];
            this.additionalData = data["additionalData"] ? AdditionalData.fromJS(data["additionalData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        data["additionalData"] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
        return data; 
    }

    clone(): EditionSelectDto {
        const json = this.toJSON();
        let result = new EditionSelectDto();
        result.init(json);
        return result;
    }
}

export interface IEditionSelectDto {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean | undefined;
    additionalData: AdditionalData | undefined;
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId: number | undefined;
    editionPaymentType: EditionPaymentType | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    subscriptionPaymentGatewayType: SubscriptionPaymentGatewayType | undefined;
    recurringPaymentEnabled: boolean | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.editionId = data["editionId"];
            this.editionPaymentType = data["editionPaymentType"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = data["subscriptionPaymentGatewayType"];
            this.recurringPaymentEnabled = data["recurringPaymentEnabled"];
            this.successUrl = data["successUrl"];
            this.errorUrl = data["errorUrl"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        data["recurringPaymentEnabled"] = this.recurringPaymentEnabled;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        return data; 
    }

    clone(): CreatePaymentDto {
        const json = this.toJSON();
        let result = new CreatePaymentDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePaymentDto {
    editionId: number | undefined;
    editionPaymentType: EditionPaymentType | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    subscriptionPaymentGatewayType: SubscriptionPaymentGatewayType | undefined;
    recurringPaymentEnabled: boolean | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
}

export enum PaymentPeriodType {
    Monthly = 30, 
    Annual = 365, 
}

export enum EditionPaymentType {
    NewRegistration = 0, 
    BuyNow = 1, 
    Upgrade = 2, 
    Extend = 3, 
}

export enum SubscriptionPaymentGatewayType {
    Paypal = 1, 
    Stripe = 2, 
}

export class CancelPaymentDto implements ICancelPaymentDto {
    paymentId: string | undefined;
    gateway: SubscriptionPaymentGatewayType | undefined;

    constructor(data?: ICancelPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.gateway = data["gateway"];
        }
    }

    static fromJS(data: any): CancelPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CancelPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["gateway"] = this.gateway;
        return data; 
    }

    clone(): CancelPaymentDto {
        const json = this.toJSON();
        let result = new CancelPaymentDto();
        result.init(json);
        return result;
    }
}

export interface ICancelPaymentDto {
    paymentId: string | undefined;
    gateway: SubscriptionPaymentGatewayType | undefined;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number | undefined;
    items: SubscriptionPaymentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfSubscriptionPaymentListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number | undefined;
    items: SubscriptionPaymentListDto[] | undefined;
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: string | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number | undefined;
    invoiceNo: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.status = data["status"];
            this.editionDisplayName = data["editionDisplayName"];
            this.tenantId = data["tenantId"];
            this.invoiceNo = data["invoiceNo"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): SubscriptionPaymentListDto {
        const json = this.toJSON();
        let result = new SubscriptionPaymentListDto();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: string | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number | undefined;
    invoiceNo: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PaymentGatewayModel implements IPaymentGatewayModel {
    gatewayType: SubscriptionPaymentGatewayType | undefined;
    supportsRecurringPayments: boolean | undefined;

    constructor(data?: IPaymentGatewayModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gatewayType = data["gatewayType"];
            this.supportsRecurringPayments = data["supportsRecurringPayments"];
        }
    }

    static fromJS(data: any): PaymentGatewayModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayType"] = this.gatewayType;
        data["supportsRecurringPayments"] = this.supportsRecurringPayments;
        return data; 
    }

    clone(): PaymentGatewayModel {
        const json = this.toJSON();
        let result = new PaymentGatewayModel();
        result.init(json);
        return result;
    }
}

export interface IPaymentGatewayModel {
    gatewayType: SubscriptionPaymentGatewayType | undefined;
    supportsRecurringPayments: boolean | undefined;
}

export class SubscriptionPaymentDto implements ISubscriptionPaymentDto {
    description: string | undefined;
    gateway: SubscriptionPaymentGatewayType | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    tenantId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: number | undefined;
    status: SubscriptionPaymentStatus | undefined;
    isRecurring: boolean | undefined;
    externalPaymentId: string | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
    id: number | undefined;

    constructor(data?: ISubscriptionPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.tenantId = data["tenantId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.status = data["status"];
            this.isRecurring = data["isRecurring"];
            this.externalPaymentId = data["externalPaymentId"];
            this.successUrl = data["successUrl"];
            this.errorUrl = data["errorUrl"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["tenantId"] = this.tenantId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["status"] = this.status;
        data["isRecurring"] = this.isRecurring;
        data["externalPaymentId"] = this.externalPaymentId;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        data["id"] = this.id;
        return data; 
    }

    clone(): SubscriptionPaymentDto {
        const json = this.toJSON();
        let result = new SubscriptionPaymentDto();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPaymentDto {
    description: string | undefined;
    gateway: SubscriptionPaymentGatewayType | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    tenantId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: number | undefined;
    status: SubscriptionPaymentStatus | undefined;
    isRecurring: boolean | undefined;
    externalPaymentId: string | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
    id: number | undefined;
}

export enum SubscriptionPaymentStatus {
    NotPaid = 1, 
    Paid = 2, 
    Failed = 3, 
    Cancelled = 4, 
    Completed = 5, 
}

export class PayPalConfigurationDto implements IPayPalConfigurationDto {
    clientId: string | undefined;
    environment: string | undefined;
    demoUsername: string | undefined;
    demoPassword: string | undefined;

    constructor(data?: IPayPalConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.environment = data["environment"];
            this.demoUsername = data["demoUsername"];
            this.demoPassword = data["demoPassword"];
        }
    }

    static fromJS(data: any): PayPalConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["environment"] = this.environment;
        data["demoUsername"] = this.demoUsername;
        data["demoPassword"] = this.demoPassword;
        return data; 
    }

    clone(): PayPalConfigurationDto {
        const json = this.toJSON();
        let result = new PayPalConfigurationDto();
        result.init(json);
        return result;
    }
}

export interface IPayPalConfigurationDto {
    clientId: string | undefined;
    environment: string | undefined;
    demoUsername: string | undefined;
    demoPassword: string | undefined;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfFlatPermissionWithLevelDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level: number | undefined;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
    isRootAction: boolean | undefined;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.level = data["level"];
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
            this.isRootAction = data["isRootAction"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        data["isRootAction"] = this.isRootAction;
        return data; 
    }

    clone(): FlatPermissionWithLevelDto {
        const json = this.toJSON();
        let result = new FlatPermissionWithLevelDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number | undefined;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
    isRootAction: boolean | undefined;
}

export class UPLOAD_W_T_RESULT implements IUPLOAD_W_T_RESULT {
    result: string | undefined;
    message: string | undefined;
    cM_ATTACH_FILE_ENTITY: CM_ATTACH_FILE_ENTITY | undefined;

    constructor(data?: IUPLOAD_W_T_RESULT) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.result = data["result"];
            this.message = data["message"];
            this.cM_ATTACH_FILE_ENTITY = data["cM_ATTACH_FILE_ENTITY"] ? CM_ATTACH_FILE_ENTITY.fromJS(data["cM_ATTACH_FILE_ENTITY"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UPLOAD_W_T_RESULT {
        data = typeof data === 'object' ? data : {};
        let result = new UPLOAD_W_T_RESULT();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["message"] = this.message;
        data["cM_ATTACH_FILE_ENTITY"] = this.cM_ATTACH_FILE_ENTITY ? this.cM_ATTACH_FILE_ENTITY.toJSON() : <any>undefined;
        return data; 
    }

    clone(): UPLOAD_W_T_RESULT {
        const json = this.toJSON();
        let result = new UPLOAD_W_T_RESULT();
        result.init(json);
        return result;
    }
}

export interface IUPLOAD_W_T_RESULT {
    result: string | undefined;
    message: string | undefined;
    cM_ATTACH_FILE_ENTITY: CM_ATTACH_FILE_ENTITY | undefined;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name: string;
    surname: string | undefined;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    subbrId: string | undefined;
    deP_ID: string | undefined;
    roles: UserListRoleDto[] | undefined;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.timezone = data["timezone"];
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.subbrId = data["subbrId"];
            this.deP_ID = data["deP_ID"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserListRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["subbrId"] = this.subbrId;
        data["deP_ID"] = this.deP_ID;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CurrentUserProfileEditDto {
        const json = this.toJSON();
        let result = new CurrentUserProfileEditDto();
        result.init(json);
        return result;
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string | undefined;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    subbrId: string | undefined;
    deP_ID: string | undefined;
    roles: UserListRoleDto[] | undefined;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }

    clone(): UserListRoleDto {
        const json = this.toJSON();
        let result = new UserListRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUserListRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data; 
    }

    clone(): UpdateGoogleAuthenticatorKeyOutput {
        const json = this.toJSON();
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(json);
        return result;
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data; 
    }

    clone(): VerifySmsCodeInputDto {
        const json = this.toJSON();
        let result = new VerifySmsCodeInputDto();
        result.init(json);
        return result;
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordInput {
        const json = this.toJSON();
        let result = new ChangePasswordInput();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileToken: string;
    x: number | undefined;
    y: number | undefined;
    width: number | undefined;
    height: number | undefined;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileToken = data["fileToken"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }

    clone(): UpdateProfilePictureInput {
        const json = this.toJSON();
        let result = new UpdateProfilePictureInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateProfilePictureInput {
    fileToken: string;
    x: number | undefined;
    y: number | undefined;
    width: number | undefined;
    height: number | undefined;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting | undefined;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.setting = data["setting"] ? PasswordComplexitySetting.fromJS(data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetPasswordComplexitySettingOutput {
        const json = this.toJSON();
        let result = new GetPasswordComplexitySettingOutput();
        result.init(json);
        return result;
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting | undefined;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }

    clone(): GetProfilePictureOutput {
        const json = this.toJSON();
        let result = new GetProfilePictureOutput();
        result.init(json);
        return result;
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class HR_QuyTrinhCongTacs_ENTITY implements IHR_QuyTrinhCongTacs_ENTITY {
    id: string | undefined;
    tenCty: string | undefined;
    dateTo: moment.Moment | undefined;
    dateFrom: moment.Moment | undefined;
    viTriCongViecID: number | undefined;
    donViCongTacID: number | undefined;
    quanLyTrucTiep: string | undefined;
    trangThaiCode: string | undefined;
    ghiChu: string | undefined;
    maHoSo: string | undefined;
    ngayDuyet: moment.Moment | undefined;
    nguoiDuyetId: string | undefined;
    truongNhomId: string | undefined;
    truongBoPhanId: string | undefined;
    giamDocBoPhanId: string | undefined;
    phongCTNSId: string | undefined;
    giamDocId: string | undefined;
    status: string | undefined;
    lyDo: string | undefined;
    totalTimeWorkAfternoonDuration: number | undefined;
    totalTimeWorkMorningDuration: number | undefined;
    totalTimeWorkDuration: number | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    vitricongviec: string | undefined;
    donvicongtac: string | undefined;
    congty: string | undefined;
    tungaydenngay: string | undefined;
    trangthailamviec: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IHR_QuyTrinhCongTacs_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenCty = data["tenCty"];
            this.dateTo = data["dateTo"] ? moment(data["dateTo"].toString()) : <any>undefined;
            this.dateFrom = data["dateFrom"] ? moment(data["dateFrom"].toString()) : <any>undefined;
            this.viTriCongViecID = data["viTriCongViecID"];
            this.donViCongTacID = data["donViCongTacID"];
            this.quanLyTrucTiep = data["quanLyTrucTiep"];
            this.trangThaiCode = data["trangThaiCode"];
            this.ghiChu = data["ghiChu"];
            this.maHoSo = data["maHoSo"];
            this.ngayDuyet = data["ngayDuyet"] ? moment(data["ngayDuyet"].toString()) : <any>undefined;
            this.nguoiDuyetId = data["nguoiDuyetId"];
            this.truongNhomId = data["truongNhomId"];
            this.truongBoPhanId = data["truongBoPhanId"];
            this.giamDocBoPhanId = data["giamDocBoPhanId"];
            this.phongCTNSId = data["phongCTNSId"];
            this.giamDocId = data["giamDocId"];
            this.status = data["status"];
            this.lyDo = data["lyDo"];
            this.totalTimeWorkAfternoonDuration = data["totalTimeWorkAfternoonDuration"];
            this.totalTimeWorkMorningDuration = data["totalTimeWorkMorningDuration"];
            this.totalTimeWorkDuration = data["totalTimeWorkDuration"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.vitricongviec = data["vitricongviec"];
            this.donvicongtac = data["donvicongtac"];
            this.congty = data["congty"];
            this.tungaydenngay = data["tungaydenngay"];
            this.trangthailamviec = data["trangthailamviec"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): HR_QuyTrinhCongTacs_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HR_QuyTrinhCongTacs_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenCty"] = this.tenCty;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["viTriCongViecID"] = this.viTriCongViecID;
        data["donViCongTacID"] = this.donViCongTacID;
        data["quanLyTrucTiep"] = this.quanLyTrucTiep;
        data["trangThaiCode"] = this.trangThaiCode;
        data["ghiChu"] = this.ghiChu;
        data["maHoSo"] = this.maHoSo;
        data["ngayDuyet"] = this.ngayDuyet ? this.ngayDuyet.toISOString() : <any>undefined;
        data["nguoiDuyetId"] = this.nguoiDuyetId;
        data["truongNhomId"] = this.truongNhomId;
        data["truongBoPhanId"] = this.truongBoPhanId;
        data["giamDocBoPhanId"] = this.giamDocBoPhanId;
        data["phongCTNSId"] = this.phongCTNSId;
        data["giamDocId"] = this.giamDocId;
        data["status"] = this.status;
        data["lyDo"] = this.lyDo;
        data["totalTimeWorkAfternoonDuration"] = this.totalTimeWorkAfternoonDuration;
        data["totalTimeWorkMorningDuration"] = this.totalTimeWorkMorningDuration;
        data["totalTimeWorkDuration"] = this.totalTimeWorkDuration;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["vitricongviec"] = this.vitricongviec;
        data["donvicongtac"] = this.donvicongtac;
        data["congty"] = this.congty;
        data["tungaydenngay"] = this.tungaydenngay;
        data["trangthailamviec"] = this.trangthailamviec;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): HR_QuyTrinhCongTacs_ENTITY {
        const json = this.toJSON();
        let result = new HR_QuyTrinhCongTacs_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHR_QuyTrinhCongTacs_ENTITY {
    id: string | undefined;
    tenCty: string | undefined;
    dateTo: moment.Moment | undefined;
    dateFrom: moment.Moment | undefined;
    viTriCongViecID: number | undefined;
    donViCongTacID: number | undefined;
    quanLyTrucTiep: string | undefined;
    trangThaiCode: string | undefined;
    ghiChu: string | undefined;
    maHoSo: string | undefined;
    ngayDuyet: moment.Moment | undefined;
    nguoiDuyetId: string | undefined;
    truongNhomId: string | undefined;
    truongBoPhanId: string | undefined;
    giamDocBoPhanId: string | undefined;
    phongCTNSId: string | undefined;
    giamDocId: string | undefined;
    status: string | undefined;
    lyDo: string | undefined;
    totalTimeWorkAfternoonDuration: number | undefined;
    totalTimeWorkMorningDuration: number | undefined;
    totalTimeWorkDuration: number | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    vitricongviec: string | undefined;
    donvicongtac: string | undefined;
    congty: string | undefined;
    tungaydenngay: string | undefined;
    trangthailamviec: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfHR_QuyTrinhCongTacs_ENTITY implements IPagedResultDtoOfHR_QuyTrinhCongTacs_ENTITY {
    totalCount: number | undefined;
    items: HR_QuyTrinhCongTacs_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfHR_QuyTrinhCongTacs_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(HR_QuyTrinhCongTacs_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfHR_QuyTrinhCongTacs_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfHR_QuyTrinhCongTacs_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfHR_QuyTrinhCongTacs_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfHR_QuyTrinhCongTacs_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfHR_QuyTrinhCongTacs_ENTITY {
    totalCount: number | undefined;
    items: HR_QuyTrinhCongTacs_ENTITY[] | undefined;
}

export class RET_MASTER_ENTITY implements IRET_MASTER_ENTITY {
    totalCount: number | undefined;
    reT_ID: string | undefined;
    asseT_ID: string | undefined;
    asseT_CODE: string | undefined;
    owner: string | undefined;
    length: number | undefined;
    width: number | undefined;
    floors: number | undefined;
    currenT_STATE: string | undefined;
    reT_TYPE: string | undefined;
    status: string | undefined;
    lanD_SQUARE: number | undefined;
    construcT_SQUARE: number | undefined;
    totaL_SQUARE: number | undefined;
    boundary: string | undefined;
    housedes: string | undefined;
    purposE_IN_USE: string | undefined;
    w_USE_CON: string | undefined;
    usE_STATUS: string | undefined;
    consT_STATUS: string | undefined;
    owneR_TYPE: string | undefined;
    usE_PERIOD: number | undefined;
    persoN_HOLDER: string | undefined;
    reason: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    buY_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    content: string | undefined;
    asseT_NAME: string | undefined;
    brancH_ID: string | undefined;
    brancH_NAME: string | undefined;
    buY_PRICE: number | undefined;
    diV_ID: string | undefined;
    diV_CODE: string | undefined;
    diV_NAME: string | undefined;
    addr: string | undefined;
    reT_STATUS: string | undefined;
    usE_FORM: string | undefined;
    usE_FORM_DETAIL: string | undefined;
    usE_SOURCE: string | undefined;
    usE_PERIOD_DT: moment.Moment | undefined;
    owneR_TYPE_DETAIL: string | undefined;
    reT_SAVE_CODE: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IRET_MASTER_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            this.reT_ID = data["reT_ID"];
            this.asseT_ID = data["asseT_ID"];
            this.asseT_CODE = data["asseT_CODE"];
            this.owner = data["owner"];
            this.length = data["length"];
            this.width = data["width"];
            this.floors = data["floors"];
            this.currenT_STATE = data["currenT_STATE"];
            this.reT_TYPE = data["reT_TYPE"];
            this.status = data["status"];
            this.lanD_SQUARE = data["lanD_SQUARE"];
            this.construcT_SQUARE = data["construcT_SQUARE"];
            this.totaL_SQUARE = data["totaL_SQUARE"];
            this.boundary = data["boundary"];
            this.housedes = data["housedes"];
            this.purposE_IN_USE = data["purposE_IN_USE"];
            this.w_USE_CON = data["w_USE_CON"];
            this.usE_STATUS = data["usE_STATUS"];
            this.consT_STATUS = data["consT_STATUS"];
            this.owneR_TYPE = data["owneR_TYPE"];
            this.usE_PERIOD = data["usE_PERIOD"];
            this.persoN_HOLDER = data["persoN_HOLDER"];
            this.reason = data["reason"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.autH_STATUS = data["autH_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.buY_DT = data["buY_DT"] ? moment(data["buY_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.content = data["content"];
            this.asseT_NAME = data["asseT_NAME"];
            this.brancH_ID = data["brancH_ID"];
            this.brancH_NAME = data["brancH_NAME"];
            this.buY_PRICE = data["buY_PRICE"];
            this.diV_ID = data["diV_ID"];
            this.diV_CODE = data["diV_CODE"];
            this.diV_NAME = data["diV_NAME"];
            this.addr = data["addr"];
            this.reT_STATUS = data["reT_STATUS"];
            this.usE_FORM = data["usE_FORM"];
            this.usE_FORM_DETAIL = data["usE_FORM_DETAIL"];
            this.usE_SOURCE = data["usE_SOURCE"];
            this.usE_PERIOD_DT = data["usE_PERIOD_DT"] ? moment(data["usE_PERIOD_DT"].toString()) : <any>undefined;
            this.owneR_TYPE_DETAIL = data["owneR_TYPE_DETAIL"];
            this.reT_SAVE_CODE = data["reT_SAVE_CODE"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): RET_MASTER_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new RET_MASTER_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["reT_ID"] = this.reT_ID;
        data["asseT_ID"] = this.asseT_ID;
        data["asseT_CODE"] = this.asseT_CODE;
        data["owner"] = this.owner;
        data["length"] = this.length;
        data["width"] = this.width;
        data["floors"] = this.floors;
        data["currenT_STATE"] = this.currenT_STATE;
        data["reT_TYPE"] = this.reT_TYPE;
        data["status"] = this.status;
        data["lanD_SQUARE"] = this.lanD_SQUARE;
        data["construcT_SQUARE"] = this.construcT_SQUARE;
        data["totaL_SQUARE"] = this.totaL_SQUARE;
        data["boundary"] = this.boundary;
        data["housedes"] = this.housedes;
        data["purposE_IN_USE"] = this.purposE_IN_USE;
        data["w_USE_CON"] = this.w_USE_CON;
        data["usE_STATUS"] = this.usE_STATUS;
        data["consT_STATUS"] = this.consT_STATUS;
        data["owneR_TYPE"] = this.owneR_TYPE;
        data["usE_PERIOD"] = this.usE_PERIOD;
        data["persoN_HOLDER"] = this.persoN_HOLDER;
        data["reason"] = this.reason;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["autH_STATUS"] = this.autH_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["buY_DT"] = this.buY_DT ? this.buY_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["content"] = this.content;
        data["asseT_NAME"] = this.asseT_NAME;
        data["brancH_ID"] = this.brancH_ID;
        data["brancH_NAME"] = this.brancH_NAME;
        data["buY_PRICE"] = this.buY_PRICE;
        data["diV_ID"] = this.diV_ID;
        data["diV_CODE"] = this.diV_CODE;
        data["diV_NAME"] = this.diV_NAME;
        data["addr"] = this.addr;
        data["reT_STATUS"] = this.reT_STATUS;
        data["usE_FORM"] = this.usE_FORM;
        data["usE_FORM_DETAIL"] = this.usE_FORM_DETAIL;
        data["usE_SOURCE"] = this.usE_SOURCE;
        data["usE_PERIOD_DT"] = this.usE_PERIOD_DT ? this.usE_PERIOD_DT.toISOString() : <any>undefined;
        data["owneR_TYPE_DETAIL"] = this.owneR_TYPE_DETAIL;
        data["reT_SAVE_CODE"] = this.reT_SAVE_CODE;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): RET_MASTER_ENTITY {
        const json = this.toJSON();
        let result = new RET_MASTER_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IRET_MASTER_ENTITY {
    totalCount: number | undefined;
    reT_ID: string | undefined;
    asseT_ID: string | undefined;
    asseT_CODE: string | undefined;
    owner: string | undefined;
    length: number | undefined;
    width: number | undefined;
    floors: number | undefined;
    currenT_STATE: string | undefined;
    reT_TYPE: string | undefined;
    status: string | undefined;
    lanD_SQUARE: number | undefined;
    construcT_SQUARE: number | undefined;
    totaL_SQUARE: number | undefined;
    boundary: string | undefined;
    housedes: string | undefined;
    purposE_IN_USE: string | undefined;
    w_USE_CON: string | undefined;
    usE_STATUS: string | undefined;
    consT_STATUS: string | undefined;
    owneR_TYPE: string | undefined;
    usE_PERIOD: number | undefined;
    persoN_HOLDER: string | undefined;
    reason: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    buY_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    content: string | undefined;
    asseT_NAME: string | undefined;
    brancH_ID: string | undefined;
    brancH_NAME: string | undefined;
    buY_PRICE: number | undefined;
    diV_ID: string | undefined;
    diV_CODE: string | undefined;
    diV_NAME: string | undefined;
    addr: string | undefined;
    reT_STATUS: string | undefined;
    usE_FORM: string | undefined;
    usE_FORM_DETAIL: string | undefined;
    usE_SOURCE: string | undefined;
    usE_PERIOD_DT: moment.Moment | undefined;
    owneR_TYPE_DETAIL: string | undefined;
    reT_SAVE_CODE: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfRET_MASTER_ENTITY implements IPagedResultDtoOfRET_MASTER_ENTITY {
    totalCount: number | undefined;
    items: RET_MASTER_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfRET_MASTER_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RET_MASTER_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRET_MASTER_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRET_MASTER_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfRET_MASTER_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRET_MASTER_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRET_MASTER_ENTITY {
    totalCount: number | undefined;
    items: RET_MASTER_ENTITY[] | undefined;
}

export class CM_REGION_ENTITY implements ICM_REGION_ENTITY {
    regioN_ID: string | undefined;
    regioN_CODE: string | undefined;
    regioN_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_REGION_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.regioN_ID = data["regioN_ID"];
            this.regioN_CODE = data["regioN_CODE"];
            this.regioN_NAME = data["regioN_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_REGION_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_REGION_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regioN_ID"] = this.regioN_ID;
        data["regioN_CODE"] = this.regioN_CODE;
        data["regioN_NAME"] = this.regioN_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_REGION_ENTITY {
        const json = this.toJSON();
        let result = new CM_REGION_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_REGION_ENTITY {
    regioN_ID: string | undefined;
    regioN_CODE: string | undefined;
    regioN_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_REGION_ENTITY implements IPagedResultDtoOfCM_REGION_ENTITY {
    totalCount: number | undefined;
    items: CM_REGION_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_REGION_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_REGION_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_REGION_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_REGION_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_REGION_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_REGION_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_REGION_ENTITY {
    totalCount: number | undefined;
    items: CM_REGION_ENTITY[] | undefined;
}

export class CM_REJECT_LOG_ENTITY implements ICM_REJECT_LOG_ENTITY {
    loG_ID: string | undefined;
    stage: string | undefined;
    trN_ID: string | undefined;
    trN_TYPE: string | undefined;
    loG_DT: moment.Moment | undefined;
    autH_STAT: string | undefined;
    reason: string | undefined;
    iS_LATEST: string | undefined;
    rejecteD_BY: string | undefined;
    rejecteD_DT: moment.Moment | undefined;
    lasteD_REASON: string | undefined;
    emP_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_REJECT_LOG_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.loG_ID = data["loG_ID"];
            this.stage = data["stage"];
            this.trN_ID = data["trN_ID"];
            this.trN_TYPE = data["trN_TYPE"];
            this.loG_DT = data["loG_DT"] ? moment(data["loG_DT"].toString()) : <any>undefined;
            this.autH_STAT = data["autH_STAT"];
            this.reason = data["reason"];
            this.iS_LATEST = data["iS_LATEST"];
            this.rejecteD_BY = data["rejecteD_BY"];
            this.rejecteD_DT = data["rejecteD_DT"] ? moment(data["rejecteD_DT"].toString()) : <any>undefined;
            this.lasteD_REASON = data["lasteD_REASON"];
            this.emP_NAME = data["emP_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_REJECT_LOG_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_REJECT_LOG_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loG_ID"] = this.loG_ID;
        data["stage"] = this.stage;
        data["trN_ID"] = this.trN_ID;
        data["trN_TYPE"] = this.trN_TYPE;
        data["loG_DT"] = this.loG_DT ? this.loG_DT.toISOString() : <any>undefined;
        data["autH_STAT"] = this.autH_STAT;
        data["reason"] = this.reason;
        data["iS_LATEST"] = this.iS_LATEST;
        data["rejecteD_BY"] = this.rejecteD_BY;
        data["rejecteD_DT"] = this.rejecteD_DT ? this.rejecteD_DT.toISOString() : <any>undefined;
        data["lasteD_REASON"] = this.lasteD_REASON;
        data["emP_NAME"] = this.emP_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_REJECT_LOG_ENTITY {
        const json = this.toJSON();
        let result = new CM_REJECT_LOG_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_REJECT_LOG_ENTITY {
    loG_ID: string | undefined;
    stage: string | undefined;
    trN_ID: string | undefined;
    trN_TYPE: string | undefined;
    loG_DT: moment.Moment | undefined;
    autH_STAT: string | undefined;
    reason: string | undefined;
    iS_LATEST: string | undefined;
    rejecteD_BY: string | undefined;
    rejecteD_DT: moment.Moment | undefined;
    lasteD_REASON: string | undefined;
    emP_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_REJECT_LOG_ENTITY implements IPagedResultDtoOfCM_REJECT_LOG_ENTITY {
    totalCount: number | undefined;
    items: CM_REJECT_LOG_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_REJECT_LOG_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_REJECT_LOG_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_REJECT_LOG_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_REJECT_LOG_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_REJECT_LOG_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_REJECT_LOG_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_REJECT_LOG_ENTITY {
    totalCount: number | undefined;
    items: CM_REJECT_LOG_ENTITY[] | undefined;
}

export class CM_REPORT_TEMPLATE_ENTITY implements ICM_REPORT_TEMPLATE_ENTITY {
    reporT_TEMPLATE_ID: string | undefined;
    reporT_TEMPLATE_NAME: string | undefined;
    reporT_TEMPLATE_STORE: string | undefined;
    reporT_TEMPLATE_CODE: string | undefined;
    notes: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    reporT_TEMPLATE_DETAILs: CM_REPORT_TEMPLATE_DETAIL_ENTITY[] | undefined;
    reporT_TEMPLATE_DETAIL_XML: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_REPORT_TEMPLATE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reporT_TEMPLATE_ID = data["reporT_TEMPLATE_ID"];
            this.reporT_TEMPLATE_NAME = data["reporT_TEMPLATE_NAME"];
            this.reporT_TEMPLATE_STORE = data["reporT_TEMPLATE_STORE"];
            this.reporT_TEMPLATE_CODE = data["reporT_TEMPLATE_CODE"];
            this.notes = data["notes"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS = data["recorD_STATUS"];
            if (data["reporT_TEMPLATE_DETAILs"] && data["reporT_TEMPLATE_DETAILs"].constructor === Array) {
                this.reporT_TEMPLATE_DETAILs = [];
                for (let item of data["reporT_TEMPLATE_DETAILs"])
                    this.reporT_TEMPLATE_DETAILs.push(CM_REPORT_TEMPLATE_DETAIL_ENTITY.fromJS(item));
            }
            this.reporT_TEMPLATE_DETAIL_XML = data["reporT_TEMPLATE_DETAIL_XML"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_REPORT_TEMPLATE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_REPORT_TEMPLATE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reporT_TEMPLATE_ID"] = this.reporT_TEMPLATE_ID;
        data["reporT_TEMPLATE_NAME"] = this.reporT_TEMPLATE_NAME;
        data["reporT_TEMPLATE_STORE"] = this.reporT_TEMPLATE_STORE;
        data["reporT_TEMPLATE_CODE"] = this.reporT_TEMPLATE_CODE;
        data["notes"] = this.notes;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS"] = this.recorD_STATUS;
        if (this.reporT_TEMPLATE_DETAILs && this.reporT_TEMPLATE_DETAILs.constructor === Array) {
            data["reporT_TEMPLATE_DETAILs"] = [];
            for (let item of this.reporT_TEMPLATE_DETAILs)
                data["reporT_TEMPLATE_DETAILs"].push(item.toJSON());
        }
        data["reporT_TEMPLATE_DETAIL_XML"] = this.reporT_TEMPLATE_DETAIL_XML;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_REPORT_TEMPLATE_ENTITY {
        const json = this.toJSON();
        let result = new CM_REPORT_TEMPLATE_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_REPORT_TEMPLATE_ENTITY {
    reporT_TEMPLATE_ID: string | undefined;
    reporT_TEMPLATE_NAME: string | undefined;
    reporT_TEMPLATE_STORE: string | undefined;
    reporT_TEMPLATE_CODE: string | undefined;
    notes: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    reporT_TEMPLATE_DETAILs: CM_REPORT_TEMPLATE_DETAIL_ENTITY[] | undefined;
    reporT_TEMPLATE_DETAIL_XML: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class CM_REPORT_TEMPLATE_DETAIL_ENTITY implements ICM_REPORT_TEMPLATE_DETAIL_ENTITY {
    reporT_TEMPLATE_DETAIL_ID: string | undefined;
    reporT_TEMPLATE_DETAIL_CONTENT: string | undefined;
    reporT_TEMPLATE_ID: string | undefined;
    reporT_TEMPLATE_DETAIL_CODE: string | undefined;
    pagE_SIZE: string | undefined;
    notes: string | undefined;
    isDefault: boolean | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    no: number | undefined;
    page: number | undefined;
    isChecked: boolean | undefined;

    constructor(data?: ICM_REPORT_TEMPLATE_DETAIL_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reporT_TEMPLATE_DETAIL_ID = data["reporT_TEMPLATE_DETAIL_ID"];
            this.reporT_TEMPLATE_DETAIL_CONTENT = data["reporT_TEMPLATE_DETAIL_CONTENT"];
            this.reporT_TEMPLATE_ID = data["reporT_TEMPLATE_ID"];
            this.reporT_TEMPLATE_DETAIL_CODE = data["reporT_TEMPLATE_DETAIL_CODE"];
            this.pagE_SIZE = data["pagE_SIZE"];
            this.notes = data["notes"];
            this.isDefault = data["isDefault"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS = data["recorD_STATUS"];
            this.no = data["no"];
            this.page = data["page"];
            this.isChecked = data["isChecked"];
        }
    }

    static fromJS(data: any): CM_REPORT_TEMPLATE_DETAIL_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_REPORT_TEMPLATE_DETAIL_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reporT_TEMPLATE_DETAIL_ID"] = this.reporT_TEMPLATE_DETAIL_ID;
        data["reporT_TEMPLATE_DETAIL_CONTENT"] = this.reporT_TEMPLATE_DETAIL_CONTENT;
        data["reporT_TEMPLATE_ID"] = this.reporT_TEMPLATE_ID;
        data["reporT_TEMPLATE_DETAIL_CODE"] = this.reporT_TEMPLATE_DETAIL_CODE;
        data["pagE_SIZE"] = this.pagE_SIZE;
        data["notes"] = this.notes;
        data["isDefault"] = this.isDefault;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["no"] = this.no;
        data["page"] = this.page;
        data["isChecked"] = this.isChecked;
        return data; 
    }

    clone(): CM_REPORT_TEMPLATE_DETAIL_ENTITY {
        const json = this.toJSON();
        let result = new CM_REPORT_TEMPLATE_DETAIL_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_REPORT_TEMPLATE_DETAIL_ENTITY {
    reporT_TEMPLATE_DETAIL_ID: string | undefined;
    reporT_TEMPLATE_DETAIL_CONTENT: string | undefined;
    reporT_TEMPLATE_ID: string | undefined;
    reporT_TEMPLATE_DETAIL_CODE: string | undefined;
    pagE_SIZE: string | undefined;
    notes: string | undefined;
    isDefault: boolean | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    no: number | undefined;
    page: number | undefined;
    isChecked: boolean | undefined;
}

export class PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY implements IPagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY {
    totalCount: number | undefined;
    items: CM_REPORT_TEMPLATE_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_REPORT_TEMPLATE_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY {
    totalCount: number | undefined;
    items: CM_REPORT_TEMPLATE_ENTITY[] | undefined;
}

export class REAL_ESTATE_L_C_ENTITY implements IREAL_ESTATE_L_C_ENTITY {
    reT_L_C_ID: string | undefined;
    reT_NAME: string | undefined;
    reT_ADDR: string | undefined;
    reT_DESC: string | undefined;
    reason: string | undefined;
    proC_EXE: string | undefined;
    proC_NEXT: string | undefined;
    brancH_ID: string | undefined;
    brancH_CREATE: string | undefined;
    brancH_LOGIN: string | undefined;
    brancH_CREATE_NAME: string | undefined;
    brancH_NAME: string | undefined;
    enD_DT: moment.Moment | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    autH_STATUS_NAME: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IREAL_ESTATE_L_C_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reT_L_C_ID = data["reT_L_C_ID"];
            this.reT_NAME = data["reT_NAME"];
            this.reT_ADDR = data["reT_ADDR"];
            this.reT_DESC = data["reT_DESC"];
            this.reason = data["reason"];
            this.proC_EXE = data["proC_EXE"];
            this.proC_NEXT = data["proC_NEXT"];
            this.brancH_ID = data["brancH_ID"];
            this.brancH_CREATE = data["brancH_CREATE"];
            this.brancH_LOGIN = data["brancH_LOGIN"];
            this.brancH_CREATE_NAME = data["brancH_CREATE_NAME"];
            this.brancH_NAME = data["brancH_NAME"];
            this.enD_DT = data["enD_DT"] ? moment(data["enD_DT"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): REAL_ESTATE_L_C_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REAL_ESTATE_L_C_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reT_L_C_ID"] = this.reT_L_C_ID;
        data["reT_NAME"] = this.reT_NAME;
        data["reT_ADDR"] = this.reT_ADDR;
        data["reT_DESC"] = this.reT_DESC;
        data["reason"] = this.reason;
        data["proC_EXE"] = this.proC_EXE;
        data["proC_NEXT"] = this.proC_NEXT;
        data["brancH_ID"] = this.brancH_ID;
        data["brancH_CREATE"] = this.brancH_CREATE;
        data["brancH_LOGIN"] = this.brancH_LOGIN;
        data["brancH_CREATE_NAME"] = this.brancH_CREATE_NAME;
        data["brancH_NAME"] = this.brancH_NAME;
        data["enD_DT"] = this.enD_DT ? this.enD_DT.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): REAL_ESTATE_L_C_ENTITY {
        const json = this.toJSON();
        let result = new REAL_ESTATE_L_C_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IREAL_ESTATE_L_C_ENTITY {
    reT_L_C_ID: string | undefined;
    reT_NAME: string | undefined;
    reT_ADDR: string | undefined;
    reT_DESC: string | undefined;
    reason: string | undefined;
    proC_EXE: string | undefined;
    proC_NEXT: string | undefined;
    brancH_ID: string | undefined;
    brancH_CREATE: string | undefined;
    brancH_LOGIN: string | undefined;
    brancH_CREATE_NAME: string | undefined;
    brancH_NAME: string | undefined;
    enD_DT: moment.Moment | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    autH_STATUS_NAME: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfREAL_ESTATE_L_C_ENTITY implements IPagedResultDtoOfREAL_ESTATE_L_C_ENTITY {
    totalCount: number | undefined;
    items: REAL_ESTATE_L_C_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfREAL_ESTATE_L_C_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(REAL_ESTATE_L_C_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfREAL_ESTATE_L_C_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfREAL_ESTATE_L_C_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfREAL_ESTATE_L_C_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfREAL_ESTATE_L_C_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfREAL_ESTATE_L_C_ENTITY {
    totalCount: number | undefined;
    items: REAL_ESTATE_L_C_ENTITY[] | undefined;
}

export class RET_REPAIR_ENTITY implements IRET_REPAIR_ENTITY {
    reT_REPAIR_ID: string | undefined;
    rP_ID: string | undefined;
    reT_ID: string | undefined;
    asseT_ID: string | undefined;
    asseT_NAME: string | undefined;
    offeR_NO: string | undefined;
    offeR_DT: moment.Moment | undefined;
    finisH_DT: moment.Moment | undefined;
    offeR_REP_DIVISION: string | undefined;
    offeR_BRANCH: string | undefined;
    offeR_PERSON: string | undefined;
    offeR_AMT: number | undefined;
    offeR_REASON: string | undefined;
    offeR_CONTENT: string | undefined;
    offeR_NOTE: string | undefined;
    offeR_STATUS: string | undefined;
    repaiR_DT: moment.Moment | undefined;
    repaiR_DIVISION: string | undefined;
    repaiR_AMT: number | undefined;
    invoicE_NO: string | undefined;
    invoicE_DT: moment.Moment | undefined;
    repaiR_CONTENT: string | undefined;
    repaiR_NOTE: string | undefined;
    performance: string | undefined;
    isleaf: string | undefined;
    parenT_ID: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    asseT_CODE: string | undefined;
    diV_CODE: string | undefined;
    diV_NAME: string | undefined;
    addr: string | undefined;
    autH_STATUS_NAME: string | undefined;
    emP_NAME: string | undefined;
    khU_VUC: string | undefined;
    chI_NHANH: string | undefined;
    pgd: string | undefined;
    paiD_AMT: number | undefined;
    searcH_TYPE: string | undefined;
    level: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IRET_REPAIR_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reT_REPAIR_ID = data["reT_REPAIR_ID"];
            this.rP_ID = data["rP_ID"];
            this.reT_ID = data["reT_ID"];
            this.asseT_ID = data["asseT_ID"];
            this.asseT_NAME = data["asseT_NAME"];
            this.offeR_NO = data["offeR_NO"];
            this.offeR_DT = data["offeR_DT"] ? moment(data["offeR_DT"].toString()) : <any>undefined;
            this.finisH_DT = data["finisH_DT"] ? moment(data["finisH_DT"].toString()) : <any>undefined;
            this.offeR_REP_DIVISION = data["offeR_REP_DIVISION"];
            this.offeR_BRANCH = data["offeR_BRANCH"];
            this.offeR_PERSON = data["offeR_PERSON"];
            this.offeR_AMT = data["offeR_AMT"];
            this.offeR_REASON = data["offeR_REASON"];
            this.offeR_CONTENT = data["offeR_CONTENT"];
            this.offeR_NOTE = data["offeR_NOTE"];
            this.offeR_STATUS = data["offeR_STATUS"];
            this.repaiR_DT = data["repaiR_DT"] ? moment(data["repaiR_DT"].toString()) : <any>undefined;
            this.repaiR_DIVISION = data["repaiR_DIVISION"];
            this.repaiR_AMT = data["repaiR_AMT"];
            this.invoicE_NO = data["invoicE_NO"];
            this.invoicE_DT = data["invoicE_DT"] ? moment(data["invoicE_DT"].toString()) : <any>undefined;
            this.repaiR_CONTENT = data["repaiR_CONTENT"];
            this.repaiR_NOTE = data["repaiR_NOTE"];
            this.performance = data["performance"];
            this.isleaf = data["isleaf"];
            this.parenT_ID = data["parenT_ID"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.asseT_CODE = data["asseT_CODE"];
            this.diV_CODE = data["diV_CODE"];
            this.diV_NAME = data["diV_NAME"];
            this.addr = data["addr"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.emP_NAME = data["emP_NAME"];
            this.khU_VUC = data["khU_VUC"];
            this.chI_NHANH = data["chI_NHANH"];
            this.pgd = data["pgd"];
            this.paiD_AMT = data["paiD_AMT"];
            this.searcH_TYPE = data["searcH_TYPE"];
            this.level = data["level"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): RET_REPAIR_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new RET_REPAIR_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reT_REPAIR_ID"] = this.reT_REPAIR_ID;
        data["rP_ID"] = this.rP_ID;
        data["reT_ID"] = this.reT_ID;
        data["asseT_ID"] = this.asseT_ID;
        data["asseT_NAME"] = this.asseT_NAME;
        data["offeR_NO"] = this.offeR_NO;
        data["offeR_DT"] = this.offeR_DT ? this.offeR_DT.toISOString() : <any>undefined;
        data["finisH_DT"] = this.finisH_DT ? this.finisH_DT.toISOString() : <any>undefined;
        data["offeR_REP_DIVISION"] = this.offeR_REP_DIVISION;
        data["offeR_BRANCH"] = this.offeR_BRANCH;
        data["offeR_PERSON"] = this.offeR_PERSON;
        data["offeR_AMT"] = this.offeR_AMT;
        data["offeR_REASON"] = this.offeR_REASON;
        data["offeR_CONTENT"] = this.offeR_CONTENT;
        data["offeR_NOTE"] = this.offeR_NOTE;
        data["offeR_STATUS"] = this.offeR_STATUS;
        data["repaiR_DT"] = this.repaiR_DT ? this.repaiR_DT.toISOString() : <any>undefined;
        data["repaiR_DIVISION"] = this.repaiR_DIVISION;
        data["repaiR_AMT"] = this.repaiR_AMT;
        data["invoicE_NO"] = this.invoicE_NO;
        data["invoicE_DT"] = this.invoicE_DT ? this.invoicE_DT.toISOString() : <any>undefined;
        data["repaiR_CONTENT"] = this.repaiR_CONTENT;
        data["repaiR_NOTE"] = this.repaiR_NOTE;
        data["performance"] = this.performance;
        data["isleaf"] = this.isleaf;
        data["parenT_ID"] = this.parenT_ID;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["asseT_CODE"] = this.asseT_CODE;
        data["diV_CODE"] = this.diV_CODE;
        data["diV_NAME"] = this.diV_NAME;
        data["addr"] = this.addr;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["emP_NAME"] = this.emP_NAME;
        data["khU_VUC"] = this.khU_VUC;
        data["chI_NHANH"] = this.chI_NHANH;
        data["pgd"] = this.pgd;
        data["paiD_AMT"] = this.paiD_AMT;
        data["searcH_TYPE"] = this.searcH_TYPE;
        data["level"] = this.level;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): RET_REPAIR_ENTITY {
        const json = this.toJSON();
        let result = new RET_REPAIR_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IRET_REPAIR_ENTITY {
    reT_REPAIR_ID: string | undefined;
    rP_ID: string | undefined;
    reT_ID: string | undefined;
    asseT_ID: string | undefined;
    asseT_NAME: string | undefined;
    offeR_NO: string | undefined;
    offeR_DT: moment.Moment | undefined;
    finisH_DT: moment.Moment | undefined;
    offeR_REP_DIVISION: string | undefined;
    offeR_BRANCH: string | undefined;
    offeR_PERSON: string | undefined;
    offeR_AMT: number | undefined;
    offeR_REASON: string | undefined;
    offeR_CONTENT: string | undefined;
    offeR_NOTE: string | undefined;
    offeR_STATUS: string | undefined;
    repaiR_DT: moment.Moment | undefined;
    repaiR_DIVISION: string | undefined;
    repaiR_AMT: number | undefined;
    invoicE_NO: string | undefined;
    invoicE_DT: moment.Moment | undefined;
    repaiR_CONTENT: string | undefined;
    repaiR_NOTE: string | undefined;
    performance: string | undefined;
    isleaf: string | undefined;
    parenT_ID: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    asseT_CODE: string | undefined;
    diV_CODE: string | undefined;
    diV_NAME: string | undefined;
    addr: string | undefined;
    autH_STATUS_NAME: string | undefined;
    emP_NAME: string | undefined;
    khU_VUC: string | undefined;
    chI_NHANH: string | undefined;
    pgd: string | undefined;
    paiD_AMT: number | undefined;
    searcH_TYPE: string | undefined;
    level: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfRET_REPAIR_ENTITY implements IPagedResultDtoOfRET_REPAIR_ENTITY {
    totalCount: number | undefined;
    items: RET_REPAIR_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfRET_REPAIR_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RET_REPAIR_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRET_REPAIR_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRET_REPAIR_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfRET_REPAIR_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRET_REPAIR_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRET_REPAIR_ENTITY {
    totalCount: number | undefined;
    items: RET_REPAIR_ENTITY[] | undefined;
}

export class REAL_ESTATE_R_H_ENTITY implements IREAL_ESTATE_R_H_ENTITY {
    reT_R_H_ID: string | undefined;
    brancH_MANAGE: string | undefined;
    brancH_USE: string | undefined;
    brancH_CREATE: string | undefined;
    brancH_MANAGE_NAME: string | undefined;
    brancH_USE_NAME: string | undefined;
    brancH_CREATE_NAME: string | undefined;
    reT_ADDR: string | undefined;
    reT_R_H_TIME: number | undefined;
    starT_DT: moment.Moment | undefined;
    enD_DT: moment.Moment | undefined;
    r_LAND_SQUARE: number | undefined;
    scale: number | undefined;
    construcT_SQUARE: number | undefined;
    r_PRICE: RET_PRICE_ENTITY[] | undefined;
    pricE_DETAIL: string | undefined;
    deposit: string | undefined;
    deposiT_PRICE: number | undefined;
    deposiT_RETURN_DT: moment.Moment | undefined;
    purchasE_EACH_TERM: number | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IREAL_ESTATE_R_H_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reT_R_H_ID = data["reT_R_H_ID"];
            this.brancH_MANAGE = data["brancH_MANAGE"];
            this.brancH_USE = data["brancH_USE"];
            this.brancH_CREATE = data["brancH_CREATE"];
            this.brancH_MANAGE_NAME = data["brancH_MANAGE_NAME"];
            this.brancH_USE_NAME = data["brancH_USE_NAME"];
            this.brancH_CREATE_NAME = data["brancH_CREATE_NAME"];
            this.reT_ADDR = data["reT_ADDR"];
            this.reT_R_H_TIME = data["reT_R_H_TIME"];
            this.starT_DT = data["starT_DT"] ? moment(data["starT_DT"].toString()) : <any>undefined;
            this.enD_DT = data["enD_DT"] ? moment(data["enD_DT"].toString()) : <any>undefined;
            this.r_LAND_SQUARE = data["r_LAND_SQUARE"];
            this.scale = data["scale"];
            this.construcT_SQUARE = data["construcT_SQUARE"];
            if (data["r_PRICE"] && data["r_PRICE"].constructor === Array) {
                this.r_PRICE = [];
                for (let item of data["r_PRICE"])
                    this.r_PRICE.push(RET_PRICE_ENTITY.fromJS(item));
            }
            this.pricE_DETAIL = data["pricE_DETAIL"];
            this.deposit = data["deposit"];
            this.deposiT_PRICE = data["deposiT_PRICE"];
            this.deposiT_RETURN_DT = data["deposiT_RETURN_DT"] ? moment(data["deposiT_RETURN_DT"].toString()) : <any>undefined;
            this.purchasE_EACH_TERM = data["purchasE_EACH_TERM"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): REAL_ESTATE_R_H_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REAL_ESTATE_R_H_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reT_R_H_ID"] = this.reT_R_H_ID;
        data["brancH_MANAGE"] = this.brancH_MANAGE;
        data["brancH_USE"] = this.brancH_USE;
        data["brancH_CREATE"] = this.brancH_CREATE;
        data["brancH_MANAGE_NAME"] = this.brancH_MANAGE_NAME;
        data["brancH_USE_NAME"] = this.brancH_USE_NAME;
        data["brancH_CREATE_NAME"] = this.brancH_CREATE_NAME;
        data["reT_ADDR"] = this.reT_ADDR;
        data["reT_R_H_TIME"] = this.reT_R_H_TIME;
        data["starT_DT"] = this.starT_DT ? this.starT_DT.toISOString() : <any>undefined;
        data["enD_DT"] = this.enD_DT ? this.enD_DT.toISOString() : <any>undefined;
        data["r_LAND_SQUARE"] = this.r_LAND_SQUARE;
        data["scale"] = this.scale;
        data["construcT_SQUARE"] = this.construcT_SQUARE;
        if (this.r_PRICE && this.r_PRICE.constructor === Array) {
            data["r_PRICE"] = [];
            for (let item of this.r_PRICE)
                data["r_PRICE"].push(item.toJSON());
        }
        data["pricE_DETAIL"] = this.pricE_DETAIL;
        data["deposit"] = this.deposit;
        data["deposiT_PRICE"] = this.deposiT_PRICE;
        data["deposiT_RETURN_DT"] = this.deposiT_RETURN_DT ? this.deposiT_RETURN_DT.toISOString() : <any>undefined;
        data["purchasE_EACH_TERM"] = this.purchasE_EACH_TERM;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): REAL_ESTATE_R_H_ENTITY {
        const json = this.toJSON();
        let result = new REAL_ESTATE_R_H_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IREAL_ESTATE_R_H_ENTITY {
    reT_R_H_ID: string | undefined;
    brancH_MANAGE: string | undefined;
    brancH_USE: string | undefined;
    brancH_CREATE: string | undefined;
    brancH_MANAGE_NAME: string | undefined;
    brancH_USE_NAME: string | undefined;
    brancH_CREATE_NAME: string | undefined;
    reT_ADDR: string | undefined;
    reT_R_H_TIME: number | undefined;
    starT_DT: moment.Moment | undefined;
    enD_DT: moment.Moment | undefined;
    r_LAND_SQUARE: number | undefined;
    scale: number | undefined;
    construcT_SQUARE: number | undefined;
    r_PRICE: RET_PRICE_ENTITY[] | undefined;
    pricE_DETAIL: string | undefined;
    deposit: string | undefined;
    deposiT_PRICE: number | undefined;
    deposiT_RETURN_DT: moment.Moment | undefined;
    purchasE_EACH_TERM: number | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class RET_PRICE_ENTITY implements IRET_PRICE_ENTITY {
    reT_PRICE_ID: string | undefined;
    reT_R_H_ID: string | undefined;
    price: number | undefined;
    pricE_DT: moment.Moment | undefined;

    constructor(data?: IRET_PRICE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reT_PRICE_ID = data["reT_PRICE_ID"];
            this.reT_R_H_ID = data["reT_R_H_ID"];
            this.price = data["price"];
            this.pricE_DT = data["pricE_DT"] ? moment(data["pricE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RET_PRICE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new RET_PRICE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reT_PRICE_ID"] = this.reT_PRICE_ID;
        data["reT_R_H_ID"] = this.reT_R_H_ID;
        data["price"] = this.price;
        data["pricE_DT"] = this.pricE_DT ? this.pricE_DT.toISOString() : <any>undefined;
        return data; 
    }

    clone(): RET_PRICE_ENTITY {
        const json = this.toJSON();
        let result = new RET_PRICE_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IRET_PRICE_ENTITY {
    reT_PRICE_ID: string | undefined;
    reT_R_H_ID: string | undefined;
    price: number | undefined;
    pricE_DT: moment.Moment | undefined;
}

export class PagedResultDtoOfREAL_ESTATE_R_H_ENTITY implements IPagedResultDtoOfREAL_ESTATE_R_H_ENTITY {
    totalCount: number | undefined;
    items: REAL_ESTATE_R_H_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfREAL_ESTATE_R_H_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(REAL_ESTATE_R_H_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfREAL_ESTATE_R_H_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfREAL_ESTATE_R_H_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfREAL_ESTATE_R_H_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfREAL_ESTATE_R_H_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfREAL_ESTATE_R_H_ENTITY {
    totalCount: number | undefined;
    items: REAL_ESTATE_R_H_ENTITY[] | undefined;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
    actions: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
            if (data["actions"] && data["actions"].constructor === Array) {
                this.actions = [];
                for (let item of data["actions"])
                    this.actions.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        if (this.actions && this.actions.constructor === Array) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
    actions: string[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): CreateOrUpdateRoleInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateRoleInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class ISession implements IISession {
    isAvailable: boolean | undefined;
    id: string | undefined;
    keys: string[] | undefined;

    constructor(data?: IISession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isAvailable = data["isAvailable"];
            this.id = data["id"];
            if (data["keys"] && data["keys"].constructor === Array) {
                this.keys = [];
                for (let item of data["keys"])
                    this.keys.push(item);
            }
        }
    }

    static fromJS(data: any): ISession {
        data = typeof data === 'object' ? data : {};
        let result = new ISession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        data["id"] = this.id;
        if (this.keys && this.keys.constructor === Array) {
            data["keys"] = [];
            for (let item of this.keys)
                data["keys"].push(item);
        }
        return data; 
    }

    clone(): ISession {
        const json = this.toJSON();
        let result = new ISession();
        result.init(json);
        return result;
    }
}

export interface IISession {
    isAvailable: boolean | undefined;
    id: string | undefined;
    keys: string[] | undefined;
}

export class StringResult implements IStringResult {
    susscessCode: string | undefined;
    result: string | undefined;

    constructor(data?: IStringResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.susscessCode = data["susscessCode"];
            this.result = data["result"];
        }
    }

    static fromJS(data: any): StringResult {
        data = typeof data === 'object' ? data : {};
        let result = new StringResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["susscessCode"] = this.susscessCode;
        data["result"] = this.result;
        return data; 
    }

    clone(): StringResult {
        const json = this.toJSON();
        let result = new StringResult();
        result.init(json);
        return result;
    }
}

export interface IStringResult {
    susscessCode: string | undefined;
    result: string | undefined;
}

export class FileResultDto implements IFileResultDto {
    physicsPath: string | undefined;
    contentType: string | undefined;
    fileName: string | undefined;
    susscessCode: string | undefined;
    result: string | undefined;

    constructor(data?: IFileResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.physicsPath = data["physicsPath"];
            this.contentType = data["contentType"];
            this.fileName = data["fileName"];
            this.susscessCode = data["susscessCode"];
            this.result = data["result"];
        }
    }

    static fromJS(data: any): FileResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["physicsPath"] = this.physicsPath;
        data["contentType"] = this.contentType;
        data["fileName"] = this.fileName;
        data["susscessCode"] = this.susscessCode;
        data["result"] = this.result;
        return data; 
    }

    clone(): FileResultDto {
        const json = this.toJSON();
        let result = new FileResultDto();
        result.init(json);
        return result;
    }
}

export interface IFileResultDto {
    physicsPath: string | undefined;
    contentType: string | undefined;
    fileName: string | undefined;
    susscessCode: string | undefined;
    result: string | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
    application: ApplicationInfoDto | undefined;
    theme: UiCustomizationSettingsDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
            this.theme = data["theme"] ? UiCustomizationSettingsDto.fromJS(data["theme"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["theme"] = this.theme ? this.theme.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
    application: ApplicationInfoDto | undefined;
    theme: UiCustomizationSettingsDto | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    taxNo: string | undefined;
    subbrId: string | undefined;
    branchName: string | undefined;
    branchCode: string | undefined;
    userTenantId: string | undefined;
    employeeCode: string | undefined;
    branchId: number | undefined;
    branch: IUserLoginBranch | undefined;
    id: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.taxNo = data["taxNo"];
            this.subbrId = data["subbrId"];
            this.branchName = data["branchName"];
            this.branchCode = data["branchCode"];
            this.userTenantId = data["userTenantId"];
            this.employeeCode = data["employeeCode"];
            this.branchId = data["branchId"];
            this.branch = data["branch"] ? IUserLoginBranch.fromJS(data["branch"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["taxNo"] = this.taxNo;
        data["subbrId"] = this.subbrId;
        data["branchName"] = this.branchName;
        data["branchCode"] = this.branchCode;
        data["userTenantId"] = this.userTenantId;
        data["employeeCode"] = this.employeeCode;
        data["branchId"] = this.branchId;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    taxNo: string | undefined;
    subbrId: string | undefined;
    branchName: string | undefined;
    branchCode: string | undefined;
    userTenantId: string | undefined;
    employeeCode: string | undefined;
    branchId: number | undefined;
    branch: IUserLoginBranch | undefined;
    id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    subscriptionPaymentType: SubscriptionPaymentType | undefined;
    edition: EditionInfoDto | undefined;
    creationTime: moment.Moment | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.logoId = data["logoId"];
            this.logoFileType = data["logoFileType"];
            this.customCssId = data["customCssId"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.subscriptionPaymentType = data["subscriptionPaymentType"];
            this.edition = data["edition"] ? EditionInfoDto.fromJS(data["edition"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionDateString = data["subscriptionDateString"];
            this.creationTimeString = data["creationTimeString"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["subscriptionPaymentType"] = this.subscriptionPaymentType;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    subscriptionPaymentType: SubscriptionPaymentType | undefined;
    edition: EditionInfoDto | undefined;
    creationTime: moment.Moment | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    currency: string | undefined;
    currencySign: string | undefined;
    allowTenantsToChangeEmailSettings: boolean | undefined;
    features: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            this.currency = data["currency"];
            this.currencySign = data["currencySign"];
            this.allowTenantsToChangeEmailSettings = data["allowTenantsToChangeEmailSettings"];
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["currencySign"] = this.currencySign;
        data["allowTenantsToChangeEmailSettings"] = this.allowTenantsToChangeEmailSettings;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    currency: string | undefined;
    currencySign: string | undefined;
    allowTenantsToChangeEmailSettings: boolean | undefined;
    features: { [key: string] : boolean; } | undefined;
}

export class UiCustomizationSettingsDto implements IUiCustomizationSettingsDto {
    baseSettings: ThemeSettingsDto | undefined;
    isLeftMenuUsed: boolean | undefined;
    isTopMenuUsed: boolean | undefined;
    isTabMenuUsed: boolean | undefined;
    allowMenuScroll: boolean | undefined;

    constructor(data?: IUiCustomizationSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.baseSettings = data["baseSettings"] ? ThemeSettingsDto.fromJS(data["baseSettings"]) : <any>undefined;
            this.isLeftMenuUsed = data["isLeftMenuUsed"];
            this.isTopMenuUsed = data["isTopMenuUsed"];
            this.isTabMenuUsed = data["isTabMenuUsed"];
            this.allowMenuScroll = data["allowMenuScroll"];
        }
    }

    static fromJS(data: any): UiCustomizationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseSettings"] = this.baseSettings ? this.baseSettings.toJSON() : <any>undefined;
        data["isLeftMenuUsed"] = this.isLeftMenuUsed;
        data["isTopMenuUsed"] = this.isTopMenuUsed;
        data["isTabMenuUsed"] = this.isTabMenuUsed;
        data["allowMenuScroll"] = this.allowMenuScroll;
        return data; 
    }

    clone(): UiCustomizationSettingsDto {
        const json = this.toJSON();
        let result = new UiCustomizationSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IUiCustomizationSettingsDto {
    baseSettings: ThemeSettingsDto | undefined;
    isLeftMenuUsed: boolean | undefined;
    isTopMenuUsed: boolean | undefined;
    isTabMenuUsed: boolean | undefined;
    allowMenuScroll: boolean | undefined;
}

export class IUserLoginBranch implements IIUserLoginBranch {
    addr: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    brancH_CODE: string | undefined;
    brancH_NAME: string | undefined;
    brancH_TYPE: string | undefined;
    checkeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    daO_CODE: string | undefined;
    daO_NAME: string | undefined;
    fatheR_ID: string | undefined;
    id: string | undefined;
    iS_POTENTIAL: string | undefined;
    isApprove: boolean | undefined;
    makeR_ID: string | undefined;
    notes: string | undefined;
    provice: string | undefined;
    recorD_STATUS: string | undefined;
    regioN_ID: string | undefined;
    taX_NO: string | undefined;
    tel: string | undefined;

    constructor(data?: IIUserLoginBranch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.addr = data["addr"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.brancH_CODE = data["brancH_CODE"];
            this.brancH_NAME = data["brancH_NAME"];
            this.brancH_TYPE = data["brancH_TYPE"];
            this.checkeR_ID = data["checkeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.daO_CODE = data["daO_CODE"];
            this.daO_NAME = data["daO_NAME"];
            this.fatheR_ID = data["fatheR_ID"];
            this.id = data["id"];
            this.iS_POTENTIAL = data["iS_POTENTIAL"];
            this.isApprove = data["isApprove"];
            this.makeR_ID = data["makeR_ID"];
            this.notes = data["notes"];
            this.provice = data["provice"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.regioN_ID = data["regioN_ID"];
            this.taX_NO = data["taX_NO"];
            this.tel = data["tel"];
        }
    }

    static fromJS(data: any): IUserLoginBranch {
        data = typeof data === 'object' ? data : {};
        let result = new IUserLoginBranch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addr"] = this.addr;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["brancH_CODE"] = this.brancH_CODE;
        data["brancH_NAME"] = this.brancH_NAME;
        data["brancH_TYPE"] = this.brancH_TYPE;
        data["checkeR_ID"] = this.checkeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["daO_CODE"] = this.daO_CODE;
        data["daO_NAME"] = this.daO_NAME;
        data["fatheR_ID"] = this.fatheR_ID;
        data["id"] = this.id;
        data["iS_POTENTIAL"] = this.iS_POTENTIAL;
        data["isApprove"] = this.isApprove;
        data["makeR_ID"] = this.makeR_ID;
        data["notes"] = this.notes;
        data["provice"] = this.provice;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["regioN_ID"] = this.regioN_ID;
        data["taX_NO"] = this.taX_NO;
        data["tel"] = this.tel;
        return data; 
    }

    clone(): IUserLoginBranch {
        const json = this.toJSON();
        let result = new IUserLoginBranch();
        result.init(json);
        return result;
    }
}

export interface IIUserLoginBranch {
    addr: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    brancH_CODE: string | undefined;
    brancH_NAME: string | undefined;
    brancH_TYPE: string | undefined;
    checkeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    daO_CODE: string | undefined;
    daO_NAME: string | undefined;
    fatheR_ID: string | undefined;
    id: string | undefined;
    iS_POTENTIAL: string | undefined;
    isApprove: boolean | undefined;
    makeR_ID: string | undefined;
    notes: string | undefined;
    provice: string | undefined;
    recorD_STATUS: string | undefined;
    regioN_ID: string | undefined;
    taX_NO: string | undefined;
    tel: string | undefined;
}

export enum SubscriptionPaymentType {
    Manual = 0, 
    RecurringAutomatic = 1, 
    RecurringManual = 2, 
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean | undefined;
    isFree: boolean | undefined;
    id: number | undefined;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.trialDayCount = data["trialDayCount"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.isHighestEdition = data["isHighestEdition"];
            this.isFree = data["isFree"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data; 
    }

    clone(): EditionInfoDto {
        const json = this.toJSON();
        let result = new EditionInfoDto();
        result.init(json);
        return result;
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean | undefined;
    isFree: boolean | undefined;
    id: number | undefined;
}

export class ThemeSettingsDto implements IThemeSettingsDto {
    theme: string | undefined;
    layout: ThemeLayoutSettingsDto | undefined;
    header: ThemeHeaderSettingsDto | undefined;
    menu: ThemeMenuSettingsDto | undefined;
    footer: ThemeFooterSettingsDto | undefined;

    constructor(data?: IThemeSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
            this.layout = data["layout"] ? ThemeLayoutSettingsDto.fromJS(data["layout"]) : <any>undefined;
            this.header = data["header"] ? ThemeHeaderSettingsDto.fromJS(data["header"]) : <any>undefined;
            this.menu = data["menu"] ? ThemeMenuSettingsDto.fromJS(data["menu"]) : <any>undefined;
            this.footer = data["footer"] ? ThemeFooterSettingsDto.fromJS(data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThemeSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ThemeSettingsDto {
        const json = this.toJSON();
        let result = new ThemeSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IThemeSettingsDto {
    theme: string | undefined;
    layout: ThemeLayoutSettingsDto | undefined;
    header: ThemeHeaderSettingsDto | undefined;
    menu: ThemeMenuSettingsDto | undefined;
    footer: ThemeFooterSettingsDto | undefined;
}

export class ThemeLayoutSettingsDto implements IThemeLayoutSettingsDto {
    layoutType: string | undefined;
    contentSkin: string | undefined;
    themeColor: string | undefined;
    fixedBody: boolean | undefined;
    mobileFixedBody: boolean | undefined;

    constructor(data?: IThemeLayoutSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layoutType = data["layoutType"];
            this.contentSkin = data["contentSkin"];
            this.themeColor = data["themeColor"];
            this.fixedBody = data["fixedBody"];
            this.mobileFixedBody = data["mobileFixedBody"];
        }
    }

    static fromJS(data: any): ThemeLayoutSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeLayoutSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        data["contentSkin"] = this.contentSkin;
        data["themeColor"] = this.themeColor;
        data["fixedBody"] = this.fixedBody;
        data["mobileFixedBody"] = this.mobileFixedBody;
        return data; 
    }

    clone(): ThemeLayoutSettingsDto {
        const json = this.toJSON();
        let result = new ThemeLayoutSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IThemeLayoutSettingsDto {
    layoutType: string | undefined;
    contentSkin: string | undefined;
    themeColor: string | undefined;
    fixedBody: boolean | undefined;
    mobileFixedBody: boolean | undefined;
}

export class ThemeHeaderSettingsDto implements IThemeHeaderSettingsDto {
    desktopFixedHeader: boolean | undefined;
    mobileFixedHeader: boolean | undefined;
    headerSkin: string | undefined;

    constructor(data?: IThemeHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.desktopFixedHeader = data["desktopFixedHeader"];
            this.mobileFixedHeader = data["mobileFixedHeader"];
            this.headerSkin = data["headerSkin"];
        }
    }

    static fromJS(data: any): ThemeHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["headerSkin"] = this.headerSkin;
        return data; 
    }

    clone(): ThemeHeaderSettingsDto {
        const json = this.toJSON();
        let result = new ThemeHeaderSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IThemeHeaderSettingsDto {
    desktopFixedHeader: boolean | undefined;
    mobileFixedHeader: boolean | undefined;
    headerSkin: string | undefined;
}

export class ThemeMenuSettingsDto implements IThemeMenuSettingsDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean | undefined;
    allowAsideMinimizing: boolean | undefined;
    defaultMinimizedAside: boolean | undefined;
    allowAsideHiding: boolean | undefined;
    defaultHiddenAside: boolean | undefined;
    submenuToggle: string | undefined;

    constructor(data?: IThemeMenuSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.position = data["position"];
            this.asideSkin = data["asideSkin"];
            this.fixedAside = data["fixedAside"];
            this.allowAsideMinimizing = data["allowAsideMinimizing"];
            this.defaultMinimizedAside = data["defaultMinimizedAside"];
            this.allowAsideHiding = data["allowAsideHiding"];
            this.defaultHiddenAside = data["defaultHiddenAside"];
            this.submenuToggle = data["submenuToggle"];
        }
    }

    static fromJS(data: any): ThemeMenuSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeMenuSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["allowAsideHiding"] = this.allowAsideHiding;
        data["defaultHiddenAside"] = this.defaultHiddenAside;
        data["submenuToggle"] = this.submenuToggle;
        return data; 
    }

    clone(): ThemeMenuSettingsDto {
        const json = this.toJSON();
        let result = new ThemeMenuSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IThemeMenuSettingsDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean | undefined;
    allowAsideMinimizing: boolean | undefined;
    defaultMinimizedAside: boolean | undefined;
    allowAsideHiding: boolean | undefined;
    defaultHiddenAside: boolean | undefined;
    submenuToggle: string | undefined;
}

export class ThemeFooterSettingsDto implements IThemeFooterSettingsDto {
    fixedFooter: boolean | undefined;

    constructor(data?: IThemeFooterSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedFooter = data["fixedFooter"];
        }
    }

    static fromJS(data: any): ThemeFooterSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeFooterSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data; 
    }

    clone(): ThemeFooterSettingsDto {
        const json = this.toJSON();
        let result = new ThemeFooterSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IThemeFooterSettingsDto {
    fixedFooter: boolean | undefined;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.encodedUserId = data["encodedUserId"];
            this.encodedTenantId = data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }

    clone(): UpdateUserSignInTokenOutput {
        const json = this.toJSON();
        let result = new UpdateUserSignInTokenOutput();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class SettingDto implements ISettingDto {
    defaultRecordsCountPerPage: number | undefined;
    resizableColumns: boolean | undefined;
    isResponsive: boolean | undefined;
    predefinedRecordsCountPerPage: string | undefined;

    constructor(data?: ISettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultRecordsCountPerPage = data["defaultRecordsCountPerPage"];
            this.resizableColumns = data["resizableColumns"];
            this.isResponsive = data["isResponsive"];
            this.predefinedRecordsCountPerPage = data["predefinedRecordsCountPerPage"];
        }
    }

    static fromJS(data: any): SettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultRecordsCountPerPage"] = this.defaultRecordsCountPerPage;
        data["resizableColumns"] = this.resizableColumns;
        data["isResponsive"] = this.isResponsive;
        data["predefinedRecordsCountPerPage"] = this.predefinedRecordsCountPerPage;
        return data; 
    }

    clone(): SettingDto {
        const json = this.toJSON();
        let result = new SettingDto();
        result.init(json);
        return result;
    }
}

export interface ISettingDto {
    defaultRecordsCountPerPage: number | undefined;
    resizableColumns: boolean | undefined;
    isResponsive: boolean | undefined;
    predefinedRecordsCountPerPage: string | undefined;
}

export class StripeConfirmPaymentInput implements IStripeConfirmPaymentInput {
    paymentId: number | undefined;
    stripeToken: string | undefined;

    constructor(data?: IStripeConfirmPaymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.stripeToken = data["stripeToken"];
        }
    }

    static fromJS(data: any): StripeConfirmPaymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfirmPaymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["stripeToken"] = this.stripeToken;
        return data; 
    }

    clone(): StripeConfirmPaymentInput {
        const json = this.toJSON();
        let result = new StripeConfirmPaymentInput();
        result.init(json);
        return result;
    }
}

export interface IStripeConfirmPaymentInput {
    paymentId: number | undefined;
    stripeToken: string | undefined;
}

export class StripeCreateSubscriptionInput implements IStripeCreateSubscriptionInput {
    paymentId: number | undefined;
    stripeToken: string | undefined;

    constructor(data?: IStripeCreateSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.stripeToken = data["stripeToken"];
        }
    }

    static fromJS(data: any): StripeCreateSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCreateSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["stripeToken"] = this.stripeToken;
        return data; 
    }

    clone(): StripeCreateSubscriptionInput {
        const json = this.toJSON();
        let result = new StripeCreateSubscriptionInput();
        result.init(json);
        return result;
    }
}

export interface IStripeCreateSubscriptionInput {
    paymentId: number | undefined;
    stripeToken: string | undefined;
}

export class StripeUpdateSubscriptionInput implements IStripeUpdateSubscriptionInput {
    paymentId: number | undefined;

    constructor(data?: IStripeUpdateSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
        }
    }

    static fromJS(data: any): StripeUpdateSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeUpdateSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        return data; 
    }

    clone(): StripeUpdateSubscriptionInput {
        const json = this.toJSON();
        let result = new StripeUpdateSubscriptionInput();
        result.init(json);
        return result;
    }
}

export interface IStripeUpdateSubscriptionInput {
    paymentId: number | undefined;
}

export class StripeConfigurationDto implements IStripeConfigurationDto {
    publishableKey: string | undefined;

    constructor(data?: IStripeConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.publishableKey = data["publishableKey"];
        }
    }

    static fromJS(data: any): StripeConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publishableKey"] = this.publishableKey;
        return data; 
    }

    clone(): StripeConfigurationDto {
        const json = this.toJSON();
        let result = new StripeConfigurationDto();
        result.init(json);
        return result;
    }
}

export interface IStripeConfigurationDto {
    publishableKey: string | undefined;
}

export class CM_SUPPLIER_ENTITY implements ICM_SUPPLIER_ENTITY {
    suP_ID: string | undefined;
    suP_CODE: string | undefined;
    suP_NAME: string | undefined;
    suP_TYPE_ID: string | undefined;
    suP_TYPE_NAME: string | undefined;
    regioN_ID: string | undefined;
    regioN_NAME: string | undefined;
    addr: string | undefined;
    email: string | undefined;
    taX_NO: string | undefined;
    tel: string | undefined;
    contacT_PERSON: string | undefined;
    disciplines: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    contracT_ID: string | undefined;
    contracT_CODE: string | undefined;
    contracT_NAME: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    disciplineS_NAME: string | undefined;
    lasT_RATE_AVG: number | undefined;
    lasT_RATE_DT: moment.Moment | undefined;
    isChecked: boolean | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_SUPPLIER_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.suP_ID = data["suP_ID"];
            this.suP_CODE = data["suP_CODE"];
            this.suP_NAME = data["suP_NAME"];
            this.suP_TYPE_ID = data["suP_TYPE_ID"];
            this.suP_TYPE_NAME = data["suP_TYPE_NAME"];
            this.regioN_ID = data["regioN_ID"];
            this.regioN_NAME = data["regioN_NAME"];
            this.addr = data["addr"];
            this.email = data["email"];
            this.taX_NO = data["taX_NO"];
            this.tel = data["tel"];
            this.contacT_PERSON = data["contacT_PERSON"];
            this.disciplines = data["disciplines"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.contracT_ID = data["contracT_ID"];
            this.contracT_CODE = data["contracT_CODE"];
            this.contracT_NAME = data["contracT_NAME"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.disciplineS_NAME = data["disciplineS_NAME"];
            this.lasT_RATE_AVG = data["lasT_RATE_AVG"];
            this.lasT_RATE_DT = data["lasT_RATE_DT"] ? moment(data["lasT_RATE_DT"].toString()) : <any>undefined;
            this.isChecked = data["isChecked"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_SUPPLIER_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_SUPPLIER_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["suP_ID"] = this.suP_ID;
        data["suP_CODE"] = this.suP_CODE;
        data["suP_NAME"] = this.suP_NAME;
        data["suP_TYPE_ID"] = this.suP_TYPE_ID;
        data["suP_TYPE_NAME"] = this.suP_TYPE_NAME;
        data["regioN_ID"] = this.regioN_ID;
        data["regioN_NAME"] = this.regioN_NAME;
        data["addr"] = this.addr;
        data["email"] = this.email;
        data["taX_NO"] = this.taX_NO;
        data["tel"] = this.tel;
        data["contacT_PERSON"] = this.contacT_PERSON;
        data["disciplines"] = this.disciplines;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["contracT_ID"] = this.contracT_ID;
        data["contracT_CODE"] = this.contracT_CODE;
        data["contracT_NAME"] = this.contracT_NAME;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["disciplineS_NAME"] = this.disciplineS_NAME;
        data["lasT_RATE_AVG"] = this.lasT_RATE_AVG;
        data["lasT_RATE_DT"] = this.lasT_RATE_DT ? this.lasT_RATE_DT.toISOString() : <any>undefined;
        data["isChecked"] = this.isChecked;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_SUPPLIER_ENTITY {
        const json = this.toJSON();
        let result = new CM_SUPPLIER_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_SUPPLIER_ENTITY {
    suP_ID: string | undefined;
    suP_CODE: string | undefined;
    suP_NAME: string | undefined;
    suP_TYPE_ID: string | undefined;
    suP_TYPE_NAME: string | undefined;
    regioN_ID: string | undefined;
    regioN_NAME: string | undefined;
    addr: string | undefined;
    email: string | undefined;
    taX_NO: string | undefined;
    tel: string | undefined;
    contacT_PERSON: string | undefined;
    disciplines: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    contracT_ID: string | undefined;
    contracT_CODE: string | undefined;
    contracT_NAME: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    disciplineS_NAME: string | undefined;
    lasT_RATE_AVG: number | undefined;
    lasT_RATE_DT: moment.Moment | undefined;
    isChecked: boolean | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_SUPPLIER_ENTITY implements IPagedResultDtoOfCM_SUPPLIER_ENTITY {
    totalCount: number | undefined;
    items: CM_SUPPLIER_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_SUPPLIER_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_SUPPLIER_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_SUPPLIER_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_SUPPLIER_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_SUPPLIER_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_SUPPLIER_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_SUPPLIER_ENTITY {
    totalCount: number | undefined;
    items: CM_SUPPLIER_ENTITY[] | undefined;
}

export class CM_SUPPLIERTYPE_ENTITY implements ICM_SUPPLIERTYPE_ENTITY {
    suP_TYPE_ID: string | undefined;
    suP_TYPE_CODE: string | undefined;
    suP_TYPE_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_SUPPLIERTYPE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.suP_TYPE_ID = data["suP_TYPE_ID"];
            this.suP_TYPE_CODE = data["suP_TYPE_CODE"];
            this.suP_TYPE_NAME = data["suP_TYPE_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_SUPPLIERTYPE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_SUPPLIERTYPE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["suP_TYPE_ID"] = this.suP_TYPE_ID;
        data["suP_TYPE_CODE"] = this.suP_TYPE_CODE;
        data["suP_TYPE_NAME"] = this.suP_TYPE_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_SUPPLIERTYPE_ENTITY {
        const json = this.toJSON();
        let result = new CM_SUPPLIERTYPE_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_SUPPLIERTYPE_ENTITY {
    suP_TYPE_ID: string | undefined;
    suP_TYPE_CODE: string | undefined;
    suP_TYPE_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY implements IPagedResultDtoOfCM_SUPPLIERTYPE_ENTITY {
    totalCount: number | undefined;
    items: CM_SUPPLIERTYPE_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_SUPPLIERTYPE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_SUPPLIERTYPE_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_SUPPLIERTYPE_ENTITY {
    totalCount: number | undefined;
    items: CM_SUPPLIERTYPE_ENTITY[] | undefined;
}

export class SYS_PARAMETERS_ENTITY implements ISYS_PARAMETERS_ENTITY {
    id: number | undefined;
    paraKey: string | undefined;
    paraValue: string | undefined;
    dataType: string | undefined;
    description: string | undefined;
    recorD_STATUS: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ISYS_PARAMETERS_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.paraKey = data["paraKey"];
            this.paraValue = data["paraValue"];
            this.dataType = data["dataType"];
            this.description = data["description"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): SYS_PARAMETERS_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new SYS_PARAMETERS_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paraKey"] = this.paraKey;
        data["paraValue"] = this.paraValue;
        data["dataType"] = this.dataType;
        data["description"] = this.description;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): SYS_PARAMETERS_ENTITY {
        const json = this.toJSON();
        let result = new SYS_PARAMETERS_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ISYS_PARAMETERS_ENTITY {
    id: number | undefined;
    paraKey: string | undefined;
    paraValue: string | undefined;
    dataType: string | undefined;
    description: string | undefined;
    recorD_STATUS: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfSYS_PARAMETERS_ENTITY implements IPagedResultDtoOfSYS_PARAMETERS_ENTITY {
    totalCount: number | undefined;
    items: SYS_PARAMETERS_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfSYS_PARAMETERS_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SYS_PARAMETERS_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSYS_PARAMETERS_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSYS_PARAMETERS_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfSYS_PARAMETERS_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfSYS_PARAMETERS_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfSYS_PARAMETERS_ENTITY {
    totalCount: number | undefined;
    items: SYS_PARAMETERS_ENTITY[] | undefined;
}

export class HR_TEMPLATE_ENTITY implements IHR_TEMPLATE_ENTITY {
    template_Id: string | undefined;
    template_Code: string | undefined;
    template_Ten: string | undefined;
    template_Link: string | undefined;
    ghiChu: string | undefined;
    ghiChu_NAME: string | undefined;
    noiDung: string | undefined;
    maCTY: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    checkeR_ID: string | undefined;
    tenant_Id: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IHR_TEMPLATE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.template_Id = data["template_Id"];
            this.template_Code = data["template_Code"];
            this.template_Ten = data["template_Ten"];
            this.template_Link = data["template_Link"];
            this.ghiChu = data["ghiChu"];
            this.ghiChu_NAME = data["ghiChu_NAME"];
            this.noiDung = data["noiDung"];
            this.maCTY = data["maCTY"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.checkeR_ID = data["checkeR_ID"];
            this.tenant_Id = data["tenant_Id"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): HR_TEMPLATE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HR_TEMPLATE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template_Id"] = this.template_Id;
        data["template_Code"] = this.template_Code;
        data["template_Ten"] = this.template_Ten;
        data["template_Link"] = this.template_Link;
        data["ghiChu"] = this.ghiChu;
        data["ghiChu_NAME"] = this.ghiChu_NAME;
        data["noiDung"] = this.noiDung;
        data["maCTY"] = this.maCTY;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["checkeR_ID"] = this.checkeR_ID;
        data["tenant_Id"] = this.tenant_Id;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): HR_TEMPLATE_ENTITY {
        const json = this.toJSON();
        let result = new HR_TEMPLATE_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHR_TEMPLATE_ENTITY {
    template_Id: string | undefined;
    template_Code: string | undefined;
    template_Ten: string | undefined;
    template_Link: string | undefined;
    ghiChu: string | undefined;
    ghiChu_NAME: string | undefined;
    noiDung: string | undefined;
    maCTY: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    checkeR_ID: string | undefined;
    tenant_Id: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfHR_TEMPLATE_ENTITY implements IPagedResultDtoOfHR_TEMPLATE_ENTITY {
    totalCount: number | undefined;
    items: HR_TEMPLATE_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfHR_TEMPLATE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(HR_TEMPLATE_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfHR_TEMPLATE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfHR_TEMPLATE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfHR_TEMPLATE_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfHR_TEMPLATE_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfHR_TEMPLATE_ENTITY {
    totalCount: number | undefined;
    items: HR_TEMPLATE_ENTITY[] | undefined;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount: number | undefined;
    items: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTenantListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTenantListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number | undefined;
    items: TenantListDto[] | undefined;
}

export class TenantListDto implements ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.editionDisplayName = data["editionDisplayName"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = data["editionId"];
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantListDto {
        const json = this.toJSON();
        let result = new TenantListDto();
        result.init(json);
        return result;
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.connectionString = data["connectionString"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }

    clone(): CreateTenantInput {
        const json = this.toJSON();
        let result = new CreateTenantInput();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantEditDto {
        const json = this.toJSON();
        let result = new TenantEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetTenantFeaturesEditOutput {
        const json = this.toJSON();
        let result = new GetTenantFeaturesEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id: number | undefined;
    featureValues: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdateTenantFeaturesInput {
        const json = this.toJSON();
        let result = new UpdateTenantFeaturesInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number | undefined;
    featureValues: NameValueDto[];
}

export class EntityDto implements IEntityDto {
    id: number | undefined;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDto {
        const json = this.toJSON();
        let result = new EntityDto();
        result.init(json);
        return result;
    }
}

export interface IEntityDto {
    id: number | undefined;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["memberActivities"] && data["memberActivities"].constructor === Array) {
                this.memberActivities = [];
                for (let item of data["memberActivities"])
                    this.memberActivities.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.memberActivities && this.memberActivities.constructor === Array) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetMemberActivityOutput {
        const json = this.toJSON();
        let result = new GetMemberActivityOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;
}

export class MemberActivity implements IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number | undefined;
    closed: number | undefined;
    rate: string | undefined;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.earnings = data["earnings"];
            this.cases = data["cases"];
            this.closed = data["closed"];
            this.rate = data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data; 
    }

    clone(): MemberActivity {
        const json = this.toJSON();
        let result = new MemberActivity();
        result.init(json);
        return result;
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number | undefined;
    closed: number | undefined;
    rate: string | undefined;
}

export enum SalesSummaryDatePeriod {
    Daily = 1, 
    Weekly = 2, 
    Monthly = 3, 
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit: number | undefined;
    newFeedbacks: number | undefined;
    newOrders: number | undefined;
    newUsers: number | undefined;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number | undefined;
    revenue: number | undefined;
    expenses: number | undefined;
    growth: number | undefined;
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalProfit = data["totalProfit"];
            this.newFeedbacks = data["newFeedbacks"];
            this.newOrders = data["newOrders"];
            this.newUsers = data["newUsers"];
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [];
                for (let item of data["salesSummary"])
                    this.salesSummary.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = data["totalSales"];
            this.revenue = data["revenue"];
            this.expenses = data["expenses"];
            this.growth = data["growth"];
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
            if (data["dailySales"] && data["dailySales"].constructor === Array) {
                this.dailySales = [];
                for (let item of data["dailySales"])
                    this.dailySales.push(item);
            }
            if (data["profitShares"] && data["profitShares"].constructor === Array) {
                this.profitShares = [];
                for (let item of data["profitShares"])
                    this.profitShares.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (this.dailySales && this.dailySales.constructor === Array) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (this.profitShares && this.profitShares.constructor === Array) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }

    clone(): GetDashboardDataOutput {
        const json = this.toJSON();
        let result = new GetDashboardDataOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number | undefined;
    newFeedbacks: number | undefined;
    newOrders: number | undefined;
    newUsers: number | undefined;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number | undefined;
    revenue: number | undefined;
    expenses: number | undefined;
    growth: number | undefined;
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;
}

export class SalesSummaryData implements ISalesSummaryData {
    period: string | undefined;
    sales: number | undefined;
    profit: number | undefined;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"];
            this.sales = data["sales"];
            this.profit = data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data; 
    }

    clone(): SalesSummaryData {
        const json = this.toJSON();
        let result = new SalesSummaryData();
        result.init(json);
        return result;
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number | undefined;
    profit: number | undefined;
}

export class GetTopStatsOutput implements IGetTopStatsOutput {
    totalProfit: number | undefined;
    newFeedbacks: number | undefined;
    newOrders: number | undefined;
    newUsers: number | undefined;

    constructor(data?: IGetTopStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalProfit = data["totalProfit"];
            this.newFeedbacks = data["newFeedbacks"];
            this.newOrders = data["newOrders"];
            this.newUsers = data["newUsers"];
        }
    }

    static fromJS(data: any): GetTopStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTopStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        return data; 
    }

    clone(): GetTopStatsOutput {
        const json = this.toJSON();
        let result = new GetTopStatsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTopStatsOutput {
    totalProfit: number | undefined;
    newFeedbacks: number | undefined;
    newOrders: number | undefined;
    newUsers: number | undefined;
}

export class GetProfitShareOutput implements IGetProfitShareOutput {
    profitShares: number[] | undefined;

    constructor(data?: IGetProfitShareOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["profitShares"] && data["profitShares"].constructor === Array) {
                this.profitShares = [];
                for (let item of data["profitShares"])
                    this.profitShares.push(item);
            }
        }
    }

    static fromJS(data: any): GetProfitShareOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfitShareOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.profitShares && this.profitShares.constructor === Array) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }

    clone(): GetProfitShareOutput {
        const json = this.toJSON();
        let result = new GetProfitShareOutput();
        result.init(json);
        return result;
    }
}

export interface IGetProfitShareOutput {
    profitShares: number[] | undefined;
}

export class GetDailySalesOutput implements IGetDailySalesOutput {
    dailySales: number[] | undefined;

    constructor(data?: IGetDailySalesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["dailySales"] && data["dailySales"].constructor === Array) {
                this.dailySales = [];
                for (let item of data["dailySales"])
                    this.dailySales.push(item);
            }
        }
    }

    static fromJS(data: any): GetDailySalesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDailySalesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.dailySales && this.dailySales.constructor === Array) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        return data; 
    }

    clone(): GetDailySalesOutput {
        const json = this.toJSON();
        let result = new GetDailySalesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDailySalesOutput {
    dailySales: number[] | undefined;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    totalSales: number | undefined;
    revenue: number | undefined;
    expenses: number | undefined;
    growth: number | undefined;
    salesSummary: SalesSummaryData[] | undefined;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalSales = data["totalSales"];
            this.revenue = data["revenue"];
            this.expenses = data["expenses"];
            this.growth = data["growth"];
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [];
                for (let item of data["salesSummary"])
                    this.salesSummary.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetSalesSummaryOutput {
        const json = this.toJSON();
        let result = new GetSalesSummaryOutput();
        result.init(json);
        return result;
    }
}

export interface IGetSalesSummaryOutput {
    totalSales: number | undefined;
    revenue: number | undefined;
    expenses: number | undefined;
    growth: number | undefined;
    salesSummary: SalesSummaryData[] | undefined;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["stats"] && data["stats"].constructor === Array) {
                this.stats = [];
                for (let item of data["stats"])
                    this.stats.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.stats && this.stats.constructor === Array) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetRegionalStatsOutput {
        const json = this.toJSON();
        let result = new GetRegionalStatsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName: string | undefined;
    sales: number | undefined;
    change: number[] | undefined;
    averagePrice: number | undefined;
    totalPrice: number | undefined;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryName = data["countryName"];
            this.sales = data["sales"];
            if (data["change"] && data["change"].constructor === Array) {
                this.change = [];
                for (let item of data["change"])
                    this.change.push(item);
            }
            this.averagePrice = data["averagePrice"];
            this.totalPrice = data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (this.change && this.change.constructor === Array) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data; 
    }

    clone(): RegionalStatCountry {
        const json = this.toJSON();
        let result = new RegionalStatCountry();
        result.init(json);
        return result;
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number | undefined;
    change: number[] | undefined;
    averagePrice: number | undefined;
    totalPrice: number | undefined;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data; 
    }

    clone(): GetGeneralStatsOutput {
        const json = this.toJSON();
        let result = new GetGeneralStatsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType | undefined;
    editionId: number | undefined;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.captchaResponse = data["captchaResponse"];
            this.subscriptionStartType = data["subscriptionStartType"];
            this.editionId = data["editionId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["editionId"] = this.editionId;
        return data; 
    }

    clone(): RegisterTenantInput {
        const json = this.toJSON();
        let result = new RegisterTenantInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType | undefined;
    editionId: number | undefined;
}

export enum SubscriptionStartType {
    Free = 1, 
    Trial = 2, 
    Paid = 3, 
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean | undefined;
    isActive: boolean | undefined;
    isEmailConfirmationRequired: boolean | undefined;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.isTenantActive = data["isTenantActive"];
            this.isActive = data["isActive"];
            this.isEmailConfirmationRequired = data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data; 
    }

    clone(): RegisterTenantOutput {
        const json = this.toJSON();
        let result = new RegisterTenantOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterTenantOutput {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean | undefined;
    isActive: boolean | undefined;
    isEmailConfirmationRequired: boolean | undefined;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
    tenantEditionId: number | undefined;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allFeatures"] && data["allFeatures"].constructor === Array) {
                this.allFeatures = [];
                for (let item of data["allFeatures"])
                    this.allFeatures.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (data["editionsWithFeatures"] && data["editionsWithFeatures"].constructor === Array) {
                this.editionsWithFeatures = [];
                for (let item of data["editionsWithFeatures"])
                    this.editionsWithFeatures.push(EditionWithFeaturesDto.fromJS(item));
            }
            this.tenantEditionId = data["tenantEditionId"];
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allFeatures && this.allFeatures.constructor === Array) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (this.editionsWithFeatures && this.editionsWithFeatures.constructor === Array) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        data["tenantEditionId"] = this.tenantEditionId;
        return data; 
    }

    clone(): EditionsSelectOutput {
        const json = this.toJSON();
        let result = new EditionsSelectOutput();
        result.init(json);
        return result;
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
    tenantEditionId: number | undefined;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType | undefined;
    textHtmlColor: string | undefined;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? IInputType.fromJS(data["inputType"]) : <any>undefined;
            this.textHtmlColor = data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data; 
    }

    clone(): FlatFeatureSelectDto {
        const json = this.toJSON();
        let result = new FlatFeatureSelectDto();
        result.init(json);
        return result;
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType | undefined;
    textHtmlColor: string | undefined;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition: EditionSelectDto | undefined;
    featureValues: NameValueDto[] | undefined;

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EditionWithFeaturesDto {
        const json = this.toJSON();
        let result = new EditionWithFeaturesDto();
        result.init(json);
        return result;
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto | undefined;
    featureValues: NameValueDto[] | undefined;
}

export class IInputType implements IIInputType {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data; 
    }

    clone(): IInputType {
        const json = this.toJSON();
        let result = new IInputType();
        result.init(json);
        return result;
    }
}

export interface IIInputType {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general: GeneralSettingsEditDto | undefined;
    userManagement: TenantUserManagementSettingsEditDto;
    email: TenantEmailSettingsEditDto | undefined;
    ldap: LdapSettingsEditDto | undefined;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto | undefined;
    otherSettings: TenantOtherSettingsEditDto | undefined;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : <any>undefined;
            this.userManagement = data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = data["email"] ? TenantEmailSettingsEditDto.fromJS(data["email"]) : <any>undefined;
            this.ldap = data["ldap"] ? LdapSettingsEditDto.fromJS(data["ldap"]) : <any>undefined;
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? TenantBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
            this.otherSettings = data["otherSettings"] ? TenantOtherSettingsEditDto.fromJS(data["otherSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TenantSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto | undefined;
    userManagement: TenantUserManagementSettingsEditDto;
    email: TenantEmailSettingsEditDto | undefined;
    ldap: LdapSettingsEditDto | undefined;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto | undefined;
    otherSettings: TenantOtherSettingsEditDto | undefined;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredUserActiveByDefault: boolean | undefined;
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    isCookieConsentEnabled: boolean | undefined;
    isQuickThemeSelectEnabled: boolean | undefined;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }

    clone(): TenantUserManagementSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantUserManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredUserActiveByDefault: boolean | undefined;
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    isCookieConsentEnabled: boolean | undefined;
    isQuickThemeSelectEnabled: boolean | undefined;
}

export class TenantEmailSettingsEditDto implements ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings: boolean | undefined;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;

    constructor(data?: ITenantEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useHostDefaultEmailSettings = data["useHostDefaultEmailSettings"];
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): TenantEmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useHostDefaultEmailSettings"] = this.useHostDefaultEmailSettings;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }

    clone(): TenantEmailSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantEmailSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings: boolean | undefined;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled: boolean | undefined;
    isEnabled: boolean | undefined;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isModuleEnabled = data["isModuleEnabled"];
            this.isEnabled = data["isEnabled"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }

    clone(): LdapSettingsEditDto {
        const json = this.toJSON();
        let result = new LdapSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean | undefined;
    isEnabled: boolean | undefined;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }

    clone(): TenantBillingSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantBillingSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class TenantOtherSettingsEditDto implements ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean | undefined;

    constructor(data?: ITenantOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantOtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantOtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }

    clone(): TenantOtherSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantOtherSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean | undefined;
}

export class CM_TERM_ENTITY implements ICM_TERM_ENTITY {
    terM_ID: string | undefined;
    terM_CODE: string | undefined;
    terM_NAME: string | undefined;
    terM_DATE: moment.Moment | undefined;
    notes: string | undefined;
    brancH_CREATE: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_TERM_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.terM_ID = data["terM_ID"];
            this.terM_CODE = data["terM_CODE"];
            this.terM_NAME = data["terM_NAME"];
            this.terM_DATE = data["terM_DATE"] ? moment(data["terM_DATE"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.brancH_CREATE = data["brancH_CREATE"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_TERM_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_TERM_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["terM_ID"] = this.terM_ID;
        data["terM_CODE"] = this.terM_CODE;
        data["terM_NAME"] = this.terM_NAME;
        data["terM_DATE"] = this.terM_DATE ? this.terM_DATE.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["brancH_CREATE"] = this.brancH_CREATE;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_TERM_ENTITY {
        const json = this.toJSON();
        let result = new CM_TERM_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_TERM_ENTITY {
    terM_ID: string | undefined;
    terM_CODE: string | undefined;
    terM_NAME: string | undefined;
    terM_DATE: moment.Moment | undefined;
    notes: string | undefined;
    brancH_CREATE: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_TERM_ENTITY implements IPagedResultDtoOfCM_TERM_ENTITY {
    totalCount: number | undefined;
    items: CM_TERM_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_TERM_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_TERM_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_TERM_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_TERM_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_TERM_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_TERM_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_TERM_ENTITY {
    totalCount: number | undefined;
    items: CM_TERM_ENTITY[] | undefined;
}

export enum SettingScopes {
    Application = 1, 
    Tenant = 2, 
    User = 4, 
    All = 7, 
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfNameValueDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfNameValueDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class PagedResultDtoOfDM_TINHTHANH_ENTITY implements IPagedResultDtoOfDM_TINHTHANH_ENTITY {
    totalCount: number | undefined;
    items: DM_TINHTHANH_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfDM_TINHTHANH_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DM_TINHTHANH_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDM_TINHTHANH_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDM_TINHTHANH_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDM_TINHTHANH_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDM_TINHTHANH_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDM_TINHTHANH_ENTITY {
    totalCount: number | undefined;
    items: DM_TINHTHANH_ENTITY[] | undefined;
}

export class TL_USER_ENTITY implements ITL_USER_ENTITY {
    tlid: string | undefined;
    tlnanme: string | undefined;
    password: string | undefined;
    tlFullName: string | undefined;
    tlsubbrid: string | undefined;
    branchId: string | undefined;
    brancH_NAME: string | undefined;
    brancH_ID: string | undefined;
    brancH_TYPE: string | undefined;
    employeeCode: string | undefined;
    rolE_ID: string | undefined;
    roleName: string | undefined;
    email: string | undefined;
    level: string | undefined;
    address: string | undefined;
    phone: string | undefined;
    autH_STATUS: string | undefined;
    markeR_ID: string | undefined;
    autH_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    isapprove: string | undefined;
    birthday: moment.Moment | undefined;
    isfirsttime: string | undefined;
    secuR_CODE: string | undefined;
    accessFailedCount: number | undefined;
    authenticationSource: string | undefined;
    concurrencyStamp: string | undefined;
    creatorUserId: number | undefined;
    deleterUserId: number | undefined;
    emailAddress: string | undefined;
    emailConfirmationCode: string | undefined;
    isActive: boolean | undefined;
    isDeleted: boolean | undefined;
    isEmailConfirmed: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    lastModifierUserId: number | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    name: string | undefined;
    normalizedEmailAddress: string | undefined;
    normalizedUserName: string | undefined;
    passwordResetCode: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    securityStamp: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    surname: string | undefined;
    tenantId: number | undefined;
    signInToken: string | undefined;
    signInTokenExpireTimeUtc: moment.Moment | undefined;
    googleAuthenticatorKey: string | undefined;
    sendActivationEmail: boolean | undefined;
    id: number | undefined;
    deP_ID: string | undefined;
    creationTime: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    brancH_CODE: string | undefined;
    khU_VUC: string | undefined;
    chI_NHANH: string | undefined;
    pgd: string | undefined;
    taX_NO: string | undefined;
    assignedRoleNames: string[] | undefined;
    setRandomPassword: boolean | undefined;
    passwordRepeat: string | undefined;
    totalCount: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ITL_USER_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tlid = data["tlid"];
            this.tlnanme = data["tlnanme"];
            this.password = data["password"];
            this.tlFullName = data["tlFullName"];
            this.tlsubbrid = data["tlsubbrid"];
            this.branchId = data["branchId"];
            this.brancH_NAME = data["brancH_NAME"];
            this.brancH_ID = data["brancH_ID"];
            this.brancH_TYPE = data["brancH_TYPE"];
            this.employeeCode = data["employeeCode"];
            this.rolE_ID = data["rolE_ID"];
            this.roleName = data["roleName"];
            this.email = data["email"];
            this.level = data["level"];
            this.address = data["address"];
            this.phone = data["phone"];
            this.autH_STATUS = data["autH_STATUS"];
            this.markeR_ID = data["markeR_ID"];
            this.autH_ID = data["autH_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.isapprove = data["isapprove"];
            this.birthday = data["birthday"] ? moment(data["birthday"].toString()) : <any>undefined;
            this.isfirsttime = data["isfirsttime"];
            this.secuR_CODE = data["secuR_CODE"];
            this.accessFailedCount = data["accessFailedCount"];
            this.authenticationSource = data["authenticationSource"];
            this.concurrencyStamp = data["concurrencyStamp"];
            this.creatorUserId = data["creatorUserId"];
            this.deleterUserId = data["deleterUserId"];
            this.emailAddress = data["emailAddress"];
            this.emailConfirmationCode = data["emailConfirmationCode"];
            this.isActive = data["isActive"];
            this.isDeleted = data["isDeleted"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.lastModifierUserId = data["lastModifierUserId"];
            this.lockoutEndDateUtc = data["lockoutEndDateUtc"] ? moment(data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.name = data["name"];
            this.normalizedEmailAddress = data["normalizedEmailAddress"];
            this.normalizedUserName = data["normalizedUserName"];
            this.passwordResetCode = data["passwordResetCode"];
            this.phoneNumber = data["phoneNumber"];
            this.profilePictureId = data["profilePictureId"];
            this.securityStamp = data["securityStamp"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.surname = data["surname"];
            this.tenantId = data["tenantId"];
            this.signInToken = data["signInToken"];
            this.signInTokenExpireTimeUtc = data["signInTokenExpireTimeUtc"] ? moment(data["signInTokenExpireTimeUtc"].toString()) : <any>undefined;
            this.googleAuthenticatorKey = data["googleAuthenticatorKey"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.id = data["id"];
            this.deP_ID = data["deP_ID"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.brancH_CODE = data["brancH_CODE"];
            this.khU_VUC = data["khU_VUC"];
            this.chI_NHANH = data["chI_NHANH"];
            this.pgd = data["pgd"];
            this.taX_NO = data["taX_NO"];
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [];
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            this.setRandomPassword = data["setRandomPassword"];
            this.passwordRepeat = data["passwordRepeat"];
            this.totalCount = data["totalCount"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.checkeR_ID = data["checkeR_ID"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): TL_USER_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new TL_USER_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tlid"] = this.tlid;
        data["tlnanme"] = this.tlnanme;
        data["password"] = this.password;
        data["tlFullName"] = this.tlFullName;
        data["tlsubbrid"] = this.tlsubbrid;
        data["branchId"] = this.branchId;
        data["brancH_NAME"] = this.brancH_NAME;
        data["brancH_ID"] = this.brancH_ID;
        data["brancH_TYPE"] = this.brancH_TYPE;
        data["employeeCode"] = this.employeeCode;
        data["rolE_ID"] = this.rolE_ID;
        data["roleName"] = this.roleName;
        data["email"] = this.email;
        data["level"] = this.level;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["autH_STATUS"] = this.autH_STATUS;
        data["markeR_ID"] = this.markeR_ID;
        data["autH_ID"] = this.autH_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["isapprove"] = this.isapprove;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["isfirsttime"] = this.isfirsttime;
        data["secuR_CODE"] = this.secuR_CODE;
        data["accessFailedCount"] = this.accessFailedCount;
        data["authenticationSource"] = this.authenticationSource;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["creatorUserId"] = this.creatorUserId;
        data["deleterUserId"] = this.deleterUserId;
        data["emailAddress"] = this.emailAddress;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["normalizedUserName"] = this.normalizedUserName;
        data["passwordResetCode"] = this.passwordResetCode;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["securityStamp"] = this.securityStamp;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["surname"] = this.surname;
        data["tenantId"] = this.tenantId;
        data["signInToken"] = this.signInToken;
        data["signInTokenExpireTimeUtc"] = this.signInTokenExpireTimeUtc ? this.signInTokenExpireTimeUtc.toISOString() : <any>undefined;
        data["googleAuthenticatorKey"] = this.googleAuthenticatorKey;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["id"] = this.id;
        data["deP_ID"] = this.deP_ID;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["brancH_CODE"] = this.brancH_CODE;
        data["khU_VUC"] = this.khU_VUC;
        data["chI_NHANH"] = this.chI_NHANH;
        data["pgd"] = this.pgd;
        data["taX_NO"] = this.taX_NO;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["setRandomPassword"] = this.setRandomPassword;
        data["passwordRepeat"] = this.passwordRepeat;
        data["totalCount"] = this.totalCount;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["checkeR_ID"] = this.checkeR_ID;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): TL_USER_ENTITY {
        const json = this.toJSON();
        let result = new TL_USER_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ITL_USER_ENTITY {
    tlid: string | undefined;
    tlnanme: string | undefined;
    password: string | undefined;
    tlFullName: string | undefined;
    tlsubbrid: string | undefined;
    branchId: string | undefined;
    brancH_NAME: string | undefined;
    brancH_ID: string | undefined;
    brancH_TYPE: string | undefined;
    employeeCode: string | undefined;
    rolE_ID: string | undefined;
    roleName: string | undefined;
    email: string | undefined;
    level: string | undefined;
    address: string | undefined;
    phone: string | undefined;
    autH_STATUS: string | undefined;
    markeR_ID: string | undefined;
    autH_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    isapprove: string | undefined;
    birthday: moment.Moment | undefined;
    isfirsttime: string | undefined;
    secuR_CODE: string | undefined;
    accessFailedCount: number | undefined;
    authenticationSource: string | undefined;
    concurrencyStamp: string | undefined;
    creatorUserId: number | undefined;
    deleterUserId: number | undefined;
    emailAddress: string | undefined;
    emailConfirmationCode: string | undefined;
    isActive: boolean | undefined;
    isDeleted: boolean | undefined;
    isEmailConfirmed: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    lastModifierUserId: number | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    name: string | undefined;
    normalizedEmailAddress: string | undefined;
    normalizedUserName: string | undefined;
    passwordResetCode: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    securityStamp: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    surname: string | undefined;
    tenantId: number | undefined;
    signInToken: string | undefined;
    signInTokenExpireTimeUtc: moment.Moment | undefined;
    googleAuthenticatorKey: string | undefined;
    sendActivationEmail: boolean | undefined;
    id: number | undefined;
    deP_ID: string | undefined;
    creationTime: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    brancH_CODE: string | undefined;
    khU_VUC: string | undefined;
    chI_NHANH: string | undefined;
    pgd: string | undefined;
    taX_NO: string | undefined;
    assignedRoleNames: string[] | undefined;
    setRandomPassword: boolean | undefined;
    passwordRepeat: string | undefined;
    totalCount: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfTL_USER_ENTITY implements IPagedResultDtoOfTL_USER_ENTITY {
    totalCount: number | undefined;
    items: TL_USER_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfTL_USER_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TL_USER_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTL_USER_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTL_USER_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTL_USER_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTL_USER_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTL_USER_ENTITY {
    totalCount: number | undefined;
    items: TL_USER_ENTITY[] | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    userId: number | undefined;
    requiresTwoFactorVerification: boolean | undefined;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    isLoginNoPassword: boolean | undefined;
    impersonateOutput: ImpersonateOutput | undefined;
    tenCty: string | undefined;
    hoVaTen: string | undefined;
    maChamCong: number | undefined;
    email: string | undefined;
    maHoSo: string | undefined;
    branchId: number | undefined;
    branchType: string | undefined;
    branchCode: string | undefined;
    image: string | undefined;
    hrUserGroups: string[] | undefined;
    hrUserDepartments: string[] | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.requiresTwoFactorVerification = data["requiresTwoFactorVerification"];
            if (data["twoFactorAuthProviders"] && data["twoFactorAuthProviders"].constructor === Array) {
                this.twoFactorAuthProviders = [];
                for (let item of data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders.push(item);
            }
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.returnUrl = data["returnUrl"];
            this.refreshToken = data["refreshToken"];
            this.isLoginNoPassword = data["isLoginNoPassword"];
            this.impersonateOutput = data["impersonateOutput"] ? ImpersonateOutput.fromJS(data["impersonateOutput"]) : <any>undefined;
            this.tenCty = data["tenCty"];
            this.hoVaTen = data["hoVaTen"];
            this.maChamCong = data["maChamCong"];
            this.email = data["email"];
            this.maHoSo = data["maHoSo"];
            this.branchId = data["branchId"];
            this.branchType = data["branchType"];
            this.branchCode = data["branchCode"];
            this.image = data["image"];
            if (data["hrUserGroups"] && data["hrUserGroups"].constructor === Array) {
                this.hrUserGroups = [];
                for (let item of data["hrUserGroups"])
                    this.hrUserGroups.push(item);
            }
            if (data["hrUserDepartments"] && data["hrUserDepartments"].constructor === Array) {
                this.hrUserDepartments = [];
                for (let item of data["hrUserDepartments"])
                    this.hrUserDepartments.push(item);
            }
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (this.twoFactorAuthProviders && this.twoFactorAuthProviders.constructor === Array) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        data["isLoginNoPassword"] = this.isLoginNoPassword;
        data["impersonateOutput"] = this.impersonateOutput ? this.impersonateOutput.toJSON() : <any>undefined;
        data["tenCty"] = this.tenCty;
        data["hoVaTen"] = this.hoVaTen;
        data["maChamCong"] = this.maChamCong;
        data["email"] = this.email;
        data["maHoSo"] = this.maHoSo;
        data["branchId"] = this.branchId;
        data["branchType"] = this.branchType;
        data["branchCode"] = this.branchCode;
        data["image"] = this.image;
        if (this.hrUserGroups && this.hrUserGroups.constructor === Array) {
            data["hrUserGroups"] = [];
            for (let item of this.hrUserGroups)
                data["hrUserGroups"].push(item);
        }
        if (this.hrUserDepartments && this.hrUserDepartments.constructor === Array) {
            data["hrUserDepartments"] = [];
            for (let item of this.hrUserDepartments)
                data["hrUserDepartments"].push(item);
        }
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    userId: number | undefined;
    requiresTwoFactorVerification: boolean | undefined;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    isLoginNoPassword: boolean | undefined;
    impersonateOutput: ImpersonateOutput | undefined;
    tenCty: string | undefined;
    hoVaTen: string | undefined;
    maChamCong: number | undefined;
    email: string | undefined;
    maHoSo: string | undefined;
    branchId: number | undefined;
    branchType: string | undefined;
    branchCode: string | undefined;
    image: string | undefined;
    hrUserGroups: string[] | undefined;
    hrUserDepartments: string[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean | undefined;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
    token: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.twoFactorVerificationCode = data["twoFactorVerificationCode"];
            this.rememberClient = data["rememberClient"];
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.singleSignIn = data["singleSignIn"];
            this.returnUrl = data["returnUrl"];
            this.token = data["token"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        data["token"] = this.token;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean | undefined;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
    token: string | undefined;
}

export class TL_USER_SearchResult implements ITL_USER_SearchResult {
    tlnanme: string | undefined;
    approvE_DT: moment.Moment | undefined;
    tlFullName: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    result: string | undefined;

    constructor(data?: ITL_USER_SearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tlnanme = data["tlnanme"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.tlFullName = data["tlFullName"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.address = data["address"];
            this.result = data["result"];
        }
    }

    static fromJS(data: any): TL_USER_SearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new TL_USER_SearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tlnanme"] = this.tlnanme;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["tlFullName"] = this.tlFullName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["result"] = this.result;
        return data; 
    }

    clone(): TL_USER_SearchResult {
        const json = this.toJSON();
        let result = new TL_USER_SearchResult();
        result.init(json);
        return result;
    }
}

export interface ITL_USER_SearchResult {
    tlnanme: string | undefined;
    approvE_DT: moment.Moment | undefined;
    tlFullName: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    result: string | undefined;
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken: string | undefined;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        return data; 
    }

    clone(): RefreshTokenResult {
        const json = this.toJSON();
        let result = new RefreshTokenResult();
        result.init(json);
        return result;
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId: number | undefined;
    provider: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.provider = data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data; 
    }

    clone(): SendTwoFactorAuthCodeModel {
        const json = this.toJSON();
        let result = new SendTwoFactorAuthCodeModel();
        result.init(json);
        return result;
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number | undefined;
    provider: string;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }

    clone(): ImpersonatedAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }

    clone(): SwitchedAccountAuthenticateResultModel {
        const json = this.toJSON();
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string] : string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
            if (data["additionalParams"]) {
                this.additionalParams = {};
                for (let key in data["additionalParams"]) {
                    if (data["additionalParams"].hasOwnProperty(key))
                        this.additionalParams[key] = data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    data["additionalParams"][key] = this.additionalParams[key];
            }
        }
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string] : string; } | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
    returnUrl: string | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
    returnUrl: string | undefined;
}

export class CM_UNIT_ENTITY implements ICM_UNIT_ENTITY {
    uniT_ID: string | undefined;
    uniT_CODE: string | undefined;
    uniT_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_UNIT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.uniT_ID = data["uniT_ID"];
            this.uniT_CODE = data["uniT_CODE"];
            this.uniT_NAME = data["uniT_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_UNIT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_UNIT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniT_ID"] = this.uniT_ID;
        data["uniT_CODE"] = this.uniT_CODE;
        data["uniT_NAME"] = this.uniT_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_UNIT_ENTITY {
        const json = this.toJSON();
        let result = new CM_UNIT_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_UNIT_ENTITY {
    uniT_ID: string | undefined;
    uniT_CODE: string | undefined;
    uniT_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfCM_UNIT_ENTITY implements IPagedResultDtoOfCM_UNIT_ENTITY {
    totalCount: number | undefined;
    items: CM_UNIT_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_UNIT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_UNIT_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_UNIT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_UNIT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_UNIT_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_UNIT_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_UNIT_ENTITY {
    totalCount: number | undefined;
    items: CM_UNIT_ENTITY[] | undefined;
}

export class HR_UngVien_ENTITY implements IHR_UngVien_ENTITY {
    ungVien_Id: string | undefined;
    ungVien_Code: string | undefined;
    ungVien_Ten: string | undefined;
    donViCongTac_Id: string | undefined;
    viTriUngTuyen_Id: string | undefined;
    kenhTuyenDung_Id: string | undefined;
    gioiTinh_Code: string | undefined;
    ngaySinh: moment.Moment | undefined;
    soCmnd: string | undefined;
    ngayCap: moment.Moment | undefined;
    noiCap: string | undefined;
    tinhThanh_Id: string | undefined;
    tinhTrangHonNhan_Code: string | undefined;
    trinhDoDaoTao_Code: string | undefined;
    trinhDoVanHoa: string | undefined;
    noiDaoTao_Id: string | undefined;
    khoa: string | undefined;
    chuyenNganh: string | undefined;
    xepLoai_Code: string | undefined;
    namTotNghiep: number | undefined;
    trangThai_Code: string | undefined;
    tienDoTuyenDung_Code: string | undefined;
    tepDinhKem: string | undefined;
    dienThoai: string | undefined;
    diaChi: string | undefined;
    email: string | undefined;
    time1: string | undefined;
    time2: string | undefined;
    time3: string | undefined;
    day1: moment.Moment | undefined;
    day2: moment.Moment | undefined;
    day3: moment.Moment | undefined;
    notes: string | undefined;
    tenCty: string | undefined;
    xepLoai: string | undefined;
    ngayPheDuyet: moment.Moment | undefined;
    duongLuong: string | undefined;
    tieuDe: string | undefined;
    nvPhuTrach_Id: string | undefined;
    maNguoiPheDuyet: string | undefined;
    isDeleted: string | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    updatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    congTy: string | undefined;
    viTriCongViec: string | undefined;
    donViCongTac: string | undefined;
    tienDoTuyenDung: string | undefined;
    kenhTuyenDung: string | undefined;
    trangThaiUT: string | undefined;
    froM_DATE_CREATE: moment.Moment | undefined;
    tO_DATE_CREATE: moment.Moment | undefined;
    froM_DATE_PV1: moment.Moment | undefined;
    tO_DATE_PV1: moment.Moment | undefined;
    froM_DATE_PV2: moment.Moment | undefined;
    tO_DATE_PV2: moment.Moment | undefined;
    froM_DATE_PV3: moment.Moment | undefined;
    tO_DATE_PV3: moment.Moment | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IHR_UngVien_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ungVien_Id = data["ungVien_Id"];
            this.ungVien_Code = data["ungVien_Code"];
            this.ungVien_Ten = data["ungVien_Ten"];
            this.donViCongTac_Id = data["donViCongTac_Id"];
            this.viTriUngTuyen_Id = data["viTriUngTuyen_Id"];
            this.kenhTuyenDung_Id = data["kenhTuyenDung_Id"];
            this.gioiTinh_Code = data["gioiTinh_Code"];
            this.ngaySinh = data["ngaySinh"] ? moment(data["ngaySinh"].toString()) : <any>undefined;
            this.soCmnd = data["soCmnd"];
            this.ngayCap = data["ngayCap"] ? moment(data["ngayCap"].toString()) : <any>undefined;
            this.noiCap = data["noiCap"];
            this.tinhThanh_Id = data["tinhThanh_Id"];
            this.tinhTrangHonNhan_Code = data["tinhTrangHonNhan_Code"];
            this.trinhDoDaoTao_Code = data["trinhDoDaoTao_Code"];
            this.trinhDoVanHoa = data["trinhDoVanHoa"];
            this.noiDaoTao_Id = data["noiDaoTao_Id"];
            this.khoa = data["khoa"];
            this.chuyenNganh = data["chuyenNganh"];
            this.xepLoai_Code = data["xepLoai_Code"];
            this.namTotNghiep = data["namTotNghiep"];
            this.trangThai_Code = data["trangThai_Code"];
            this.tienDoTuyenDung_Code = data["tienDoTuyenDung_Code"];
            this.tepDinhKem = data["tepDinhKem"];
            this.dienThoai = data["dienThoai"];
            this.diaChi = data["diaChi"];
            this.email = data["email"];
            this.time1 = data["time1"];
            this.time2 = data["time2"];
            this.time3 = data["time3"];
            this.day1 = data["day1"] ? moment(data["day1"].toString()) : <any>undefined;
            this.day2 = data["day2"] ? moment(data["day2"].toString()) : <any>undefined;
            this.day3 = data["day3"] ? moment(data["day3"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.tenCty = data["tenCty"];
            this.xepLoai = data["xepLoai"];
            this.ngayPheDuyet = data["ngayPheDuyet"] ? moment(data["ngayPheDuyet"].toString()) : <any>undefined;
            this.duongLuong = data["duongLuong"];
            this.tieuDe = data["tieuDe"];
            this.nvPhuTrach_Id = data["nvPhuTrach_Id"];
            this.maNguoiPheDuyet = data["maNguoiPheDuyet"];
            this.isDeleted = data["isDeleted"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.updatE_DT = data["updatE_DT"] ? moment(data["updatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.congTy = data["congTy"];
            this.viTriCongViec = data["viTriCongViec"];
            this.donViCongTac = data["donViCongTac"];
            this.tienDoTuyenDung = data["tienDoTuyenDung"];
            this.kenhTuyenDung = data["kenhTuyenDung"];
            this.trangThaiUT = data["trangThaiUT"];
            this.froM_DATE_CREATE = data["froM_DATE_CREATE"] ? moment(data["froM_DATE_CREATE"].toString()) : <any>undefined;
            this.tO_DATE_CREATE = data["tO_DATE_CREATE"] ? moment(data["tO_DATE_CREATE"].toString()) : <any>undefined;
            this.froM_DATE_PV1 = data["froM_DATE_PV1"] ? moment(data["froM_DATE_PV1"].toString()) : <any>undefined;
            this.tO_DATE_PV1 = data["tO_DATE_PV1"] ? moment(data["tO_DATE_PV1"].toString()) : <any>undefined;
            this.froM_DATE_PV2 = data["froM_DATE_PV2"] ? moment(data["froM_DATE_PV2"].toString()) : <any>undefined;
            this.tO_DATE_PV2 = data["tO_DATE_PV2"] ? moment(data["tO_DATE_PV2"].toString()) : <any>undefined;
            this.froM_DATE_PV3 = data["froM_DATE_PV3"] ? moment(data["froM_DATE_PV3"].toString()) : <any>undefined;
            this.tO_DATE_PV3 = data["tO_DATE_PV3"] ? moment(data["tO_DATE_PV3"].toString()) : <any>undefined;
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): HR_UngVien_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HR_UngVien_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ungVien_Id"] = this.ungVien_Id;
        data["ungVien_Code"] = this.ungVien_Code;
        data["ungVien_Ten"] = this.ungVien_Ten;
        data["donViCongTac_Id"] = this.donViCongTac_Id;
        data["viTriUngTuyen_Id"] = this.viTriUngTuyen_Id;
        data["kenhTuyenDung_Id"] = this.kenhTuyenDung_Id;
        data["gioiTinh_Code"] = this.gioiTinh_Code;
        data["ngaySinh"] = this.ngaySinh ? this.ngaySinh.toISOString() : <any>undefined;
        data["soCmnd"] = this.soCmnd;
        data["ngayCap"] = this.ngayCap ? this.ngayCap.toISOString() : <any>undefined;
        data["noiCap"] = this.noiCap;
        data["tinhThanh_Id"] = this.tinhThanh_Id;
        data["tinhTrangHonNhan_Code"] = this.tinhTrangHonNhan_Code;
        data["trinhDoDaoTao_Code"] = this.trinhDoDaoTao_Code;
        data["trinhDoVanHoa"] = this.trinhDoVanHoa;
        data["noiDaoTao_Id"] = this.noiDaoTao_Id;
        data["khoa"] = this.khoa;
        data["chuyenNganh"] = this.chuyenNganh;
        data["xepLoai_Code"] = this.xepLoai_Code;
        data["namTotNghiep"] = this.namTotNghiep;
        data["trangThai_Code"] = this.trangThai_Code;
        data["tienDoTuyenDung_Code"] = this.tienDoTuyenDung_Code;
        data["tepDinhKem"] = this.tepDinhKem;
        data["dienThoai"] = this.dienThoai;
        data["diaChi"] = this.diaChi;
        data["email"] = this.email;
        data["time1"] = this.time1;
        data["time2"] = this.time2;
        data["time3"] = this.time3;
        data["day1"] = this.day1 ? this.day1.toISOString() : <any>undefined;
        data["day2"] = this.day2 ? this.day2.toISOString() : <any>undefined;
        data["day3"] = this.day3 ? this.day3.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["tenCty"] = this.tenCty;
        data["xepLoai"] = this.xepLoai;
        data["ngayPheDuyet"] = this.ngayPheDuyet ? this.ngayPheDuyet.toISOString() : <any>undefined;
        data["duongLuong"] = this.duongLuong;
        data["tieuDe"] = this.tieuDe;
        data["nvPhuTrach_Id"] = this.nvPhuTrach_Id;
        data["maNguoiPheDuyet"] = this.maNguoiPheDuyet;
        data["isDeleted"] = this.isDeleted;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["updatE_DT"] = this.updatE_DT ? this.updatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["congTy"] = this.congTy;
        data["viTriCongViec"] = this.viTriCongViec;
        data["donViCongTac"] = this.donViCongTac;
        data["tienDoTuyenDung"] = this.tienDoTuyenDung;
        data["kenhTuyenDung"] = this.kenhTuyenDung;
        data["trangThaiUT"] = this.trangThaiUT;
        data["froM_DATE_CREATE"] = this.froM_DATE_CREATE ? this.froM_DATE_CREATE.toISOString() : <any>undefined;
        data["tO_DATE_CREATE"] = this.tO_DATE_CREATE ? this.tO_DATE_CREATE.toISOString() : <any>undefined;
        data["froM_DATE_PV1"] = this.froM_DATE_PV1 ? this.froM_DATE_PV1.toISOString() : <any>undefined;
        data["tO_DATE_PV1"] = this.tO_DATE_PV1 ? this.tO_DATE_PV1.toISOString() : <any>undefined;
        data["froM_DATE_PV2"] = this.froM_DATE_PV2 ? this.froM_DATE_PV2.toISOString() : <any>undefined;
        data["tO_DATE_PV2"] = this.tO_DATE_PV2 ? this.tO_DATE_PV2.toISOString() : <any>undefined;
        data["froM_DATE_PV3"] = this.froM_DATE_PV3 ? this.froM_DATE_PV3.toISOString() : <any>undefined;
        data["tO_DATE_PV3"] = this.tO_DATE_PV3 ? this.tO_DATE_PV3.toISOString() : <any>undefined;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): HR_UngVien_ENTITY {
        const json = this.toJSON();
        let result = new HR_UngVien_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHR_UngVien_ENTITY {
    ungVien_Id: string | undefined;
    ungVien_Code: string | undefined;
    ungVien_Ten: string | undefined;
    donViCongTac_Id: string | undefined;
    viTriUngTuyen_Id: string | undefined;
    kenhTuyenDung_Id: string | undefined;
    gioiTinh_Code: string | undefined;
    ngaySinh: moment.Moment | undefined;
    soCmnd: string | undefined;
    ngayCap: moment.Moment | undefined;
    noiCap: string | undefined;
    tinhThanh_Id: string | undefined;
    tinhTrangHonNhan_Code: string | undefined;
    trinhDoDaoTao_Code: string | undefined;
    trinhDoVanHoa: string | undefined;
    noiDaoTao_Id: string | undefined;
    khoa: string | undefined;
    chuyenNganh: string | undefined;
    xepLoai_Code: string | undefined;
    namTotNghiep: number | undefined;
    trangThai_Code: string | undefined;
    tienDoTuyenDung_Code: string | undefined;
    tepDinhKem: string | undefined;
    dienThoai: string | undefined;
    diaChi: string | undefined;
    email: string | undefined;
    time1: string | undefined;
    time2: string | undefined;
    time3: string | undefined;
    day1: moment.Moment | undefined;
    day2: moment.Moment | undefined;
    day3: moment.Moment | undefined;
    notes: string | undefined;
    tenCty: string | undefined;
    xepLoai: string | undefined;
    ngayPheDuyet: moment.Moment | undefined;
    duongLuong: string | undefined;
    tieuDe: string | undefined;
    nvPhuTrach_Id: string | undefined;
    maNguoiPheDuyet: string | undefined;
    isDeleted: string | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    updatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    congTy: string | undefined;
    viTriCongViec: string | undefined;
    donViCongTac: string | undefined;
    tienDoTuyenDung: string | undefined;
    kenhTuyenDung: string | undefined;
    trangThaiUT: string | undefined;
    froM_DATE_CREATE: moment.Moment | undefined;
    tO_DATE_CREATE: moment.Moment | undefined;
    froM_DATE_PV1: moment.Moment | undefined;
    tO_DATE_PV1: moment.Moment | undefined;
    froM_DATE_PV2: moment.Moment | undefined;
    tO_DATE_PV2: moment.Moment | undefined;
    froM_DATE_PV3: moment.Moment | undefined;
    tO_DATE_PV3: moment.Moment | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfHR_UngVien_ENTITY implements IPagedResultDtoOfHR_UngVien_ENTITY {
    totalCount: number | undefined;
    items: HR_UngVien_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfHR_UngVien_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(HR_UngVien_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfHR_UngVien_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfHR_UngVien_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfHR_UngVien_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfHR_UngVien_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfHR_UngVien_ENTITY {
    totalCount: number | undefined;
    items: HR_UngVien_ENTITY[] | undefined;
}

export class HR_TieuDeGuiMail_ENTITY implements IHR_TieuDeGuiMail_ENTITY {
    id: number | undefined;
    maCty: number | undefined;
    tenTieuDe: string | undefined;
    noiDungTieuDe: string | undefined;
    ghiChu: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IHR_TieuDeGuiMail_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.maCty = data["maCty"];
            this.tenTieuDe = data["tenTieuDe"];
            this.noiDungTieuDe = data["noiDungTieuDe"];
            this.ghiChu = data["ghiChu"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): HR_TieuDeGuiMail_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HR_TieuDeGuiMail_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["maCty"] = this.maCty;
        data["tenTieuDe"] = this.tenTieuDe;
        data["noiDungTieuDe"] = this.noiDungTieuDe;
        data["ghiChu"] = this.ghiChu;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): HR_TieuDeGuiMail_ENTITY {
        const json = this.toJSON();
        let result = new HR_TieuDeGuiMail_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHR_TieuDeGuiMail_ENTITY {
    id: number | undefined;
    maCty: number | undefined;
    tenTieuDe: string | undefined;
    noiDungTieuDe: string | undefined;
    ghiChu: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class UPDATE_DATE_LIST_ENTITY implements IUPDATE_DATE_LIST_ENTITY {
    upD_DAY_ID: string | undefined;
    upD_DAY_CODE: string | undefined;
    asS_ID: string | undefined;
    asS_CODE: string | undefined;
    hcqT_CREATE_DT: moment.Moment | undefined;
    hcqT_EXP_DT: moment.Moment | undefined;
    hcqT_APP_DT: moment.Moment | undefined;
    kT_CREATE_DT: moment.Moment | undefined;
    kT_EXP_DT: moment.Moment | undefined;
    kT_APP_DT: moment.Moment | undefined;
    requesT_NAME: string | undefined;
    reason: string | undefined;
    requesT_DT: moment.Moment | undefined;
    brancH_ID: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    notes: string | undefined;
    autH_STATUS_NAME: string | undefined;
    asseT_NAME: string | undefined;
    level: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IUPDATE_DATE_LIST_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.upD_DAY_ID = data["upD_DAY_ID"];
            this.upD_DAY_CODE = data["upD_DAY_CODE"];
            this.asS_ID = data["asS_ID"];
            this.asS_CODE = data["asS_CODE"];
            this.hcqT_CREATE_DT = data["hcqT_CREATE_DT"] ? moment(data["hcqT_CREATE_DT"].toString()) : <any>undefined;
            this.hcqT_EXP_DT = data["hcqT_EXP_DT"] ? moment(data["hcqT_EXP_DT"].toString()) : <any>undefined;
            this.hcqT_APP_DT = data["hcqT_APP_DT"] ? moment(data["hcqT_APP_DT"].toString()) : <any>undefined;
            this.kT_CREATE_DT = data["kT_CREATE_DT"] ? moment(data["kT_CREATE_DT"].toString()) : <any>undefined;
            this.kT_EXP_DT = data["kT_EXP_DT"] ? moment(data["kT_EXP_DT"].toString()) : <any>undefined;
            this.kT_APP_DT = data["kT_APP_DT"] ? moment(data["kT_APP_DT"].toString()) : <any>undefined;
            this.requesT_NAME = data["requesT_NAME"];
            this.reason = data["reason"];
            this.requesT_DT = data["requesT_DT"] ? moment(data["requesT_DT"].toString()) : <any>undefined;
            this.brancH_ID = data["brancH_ID"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.autH_STATUS = data["autH_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.asseT_NAME = data["asseT_NAME"];
            this.level = data["level"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): UPDATE_DATE_LIST_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new UPDATE_DATE_LIST_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["upD_DAY_ID"] = this.upD_DAY_ID;
        data["upD_DAY_CODE"] = this.upD_DAY_CODE;
        data["asS_ID"] = this.asS_ID;
        data["asS_CODE"] = this.asS_CODE;
        data["hcqT_CREATE_DT"] = this.hcqT_CREATE_DT ? this.hcqT_CREATE_DT.toISOString() : <any>undefined;
        data["hcqT_EXP_DT"] = this.hcqT_EXP_DT ? this.hcqT_EXP_DT.toISOString() : <any>undefined;
        data["hcqT_APP_DT"] = this.hcqT_APP_DT ? this.hcqT_APP_DT.toISOString() : <any>undefined;
        data["kT_CREATE_DT"] = this.kT_CREATE_DT ? this.kT_CREATE_DT.toISOString() : <any>undefined;
        data["kT_EXP_DT"] = this.kT_EXP_DT ? this.kT_EXP_DT.toISOString() : <any>undefined;
        data["kT_APP_DT"] = this.kT_APP_DT ? this.kT_APP_DT.toISOString() : <any>undefined;
        data["requesT_NAME"] = this.requesT_NAME;
        data["reason"] = this.reason;
        data["requesT_DT"] = this.requesT_DT ? this.requesT_DT.toISOString() : <any>undefined;
        data["brancH_ID"] = this.brancH_ID;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["autH_STATUS"] = this.autH_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["asseT_NAME"] = this.asseT_NAME;
        data["level"] = this.level;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): UPDATE_DATE_LIST_ENTITY {
        const json = this.toJSON();
        let result = new UPDATE_DATE_LIST_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IUPDATE_DATE_LIST_ENTITY {
    upD_DAY_ID: string | undefined;
    upD_DAY_CODE: string | undefined;
    asS_ID: string | undefined;
    asS_CODE: string | undefined;
    hcqT_CREATE_DT: moment.Moment | undefined;
    hcqT_EXP_DT: moment.Moment | undefined;
    hcqT_APP_DT: moment.Moment | undefined;
    kT_CREATE_DT: moment.Moment | undefined;
    kT_EXP_DT: moment.Moment | undefined;
    kT_APP_DT: moment.Moment | undefined;
    requesT_NAME: string | undefined;
    reason: string | undefined;
    requesT_DT: moment.Moment | undefined;
    brancH_ID: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    notes: string | undefined;
    autH_STATUS_NAME: string | undefined;
    asseT_NAME: string | undefined;
    level: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfUPDATE_DATE_LIST_ENTITY implements IPagedResultDtoOfUPDATE_DATE_LIST_ENTITY {
    totalCount: number | undefined;
    items: UPDATE_DATE_LIST_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfUPDATE_DATE_LIST_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UPDATE_DATE_LIST_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUPDATE_DATE_LIST_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUPDATE_DATE_LIST_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfUPDATE_DATE_LIST_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUPDATE_DATE_LIST_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUPDATE_DATE_LIST_ENTITY {
    totalCount: number | undefined;
    items: UPDATE_DATE_LIST_ENTITY[] | undefined;
}

export class GetUsersInput implements IGetUsersInput {
    filter: string | undefined;
    permission: string | undefined;
    role: number | undefined;
    onlyLockedUsers: boolean | undefined;
    userName: string | undefined;
    autH_STATUS: string | undefined;
    subbrId: string | undefined;
    independentUnit: boolean | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.permission = data["permission"];
            this.role = data["role"];
            this.onlyLockedUsers = data["onlyLockedUsers"];
            this.userName = data["userName"];
            this.autH_STATUS = data["autH_STATUS"];
            this.subbrId = data["subbrId"];
            this.independentUnit = data["independentUnit"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["permission"] = this.permission;
        data["role"] = this.role;
        data["onlyLockedUsers"] = this.onlyLockedUsers;
        data["userName"] = this.userName;
        data["autH_STATUS"] = this.autH_STATUS;
        data["subbrId"] = this.subbrId;
        data["independentUnit"] = this.independentUnit;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetUsersInput {
        const json = this.toJSON();
        let result = new GetUsersInput();
        result.init(json);
        return result;
    }
}

export interface IGetUsersInput {
    filter: string | undefined;
    permission: string | undefined;
    role: number | undefined;
    onlyLockedUsers: boolean | undefined;
    userName: string | undefined;
    autH_STATUS: string | undefined;
    subbrId: string | undefined;
    independentUnit: boolean | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount: number | undefined;
    items: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfUserListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number | undefined;
    items: UserListDto[] | undefined;
}

export class UserListDto implements IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    subbrName: string | undefined;
    deptName: string | undefined;
    phoneNumber: string | undefined;
    authStatusName: string | undefined;
    authStatus: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean | undefined;
    roles: UserListRoleDto[] | undefined;
    isActive: boolean | undefined;
    markerId: string | undefined;
    creationTime: moment.Moment | undefined;
    isChecked: boolean | undefined;
    id: number | undefined;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.subbrName = data["subbrName"];
            this.deptName = data["deptName"];
            this.phoneNumber = data["phoneNumber"];
            this.authStatusName = data["authStatusName"];
            this.authStatus = data["authStatus"];
            this.profilePictureId = data["profilePictureId"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserListRoleDto.fromJS(item));
            }
            this.isActive = data["isActive"];
            this.markerId = data["markerId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.isChecked = data["isChecked"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["subbrName"] = this.subbrName;
        data["deptName"] = this.deptName;
        data["phoneNumber"] = this.phoneNumber;
        data["authStatusName"] = this.authStatusName;
        data["authStatus"] = this.authStatus;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["markerId"] = this.markerId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isChecked"] = this.isChecked;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserListDto {
        const json = this.toJSON();
        let result = new UserListDto();
        result.init(json);
        return result;
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    subbrName: string | undefined;
    deptName: string | undefined;
    phoneNumber: string | undefined;
    authStatusName: string | undefined;
    authStatus: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean | undefined;
    roles: UserListRoleDto[] | undefined;
    isActive: boolean | undefined;
    markerId: string | undefined;
    creationTime: moment.Moment | undefined;
    isChecked: boolean | undefined;
    id: number | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserRoleDto.fromJS(item));
            }
            if (data["allOrganizationUnits"] && data["allOrganizationUnits"].constructor === Array) {
                this.allOrganizationUnits = [];
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits.push(OrganizationUnitDto.fromJS(item));
            }
            if (data["memberedOrganizationUnits"] && data["memberedOrganizationUnits"].constructor === Array) {
                this.memberedOrganizationUnits = [];
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.allOrganizationUnits && this.allOrganizationUnits.constructor === Array) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (this.memberedOrganizationUnits && this.memberedOrganizationUnits.constructor === Array) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data; 
    }

    clone(): GetUserForEditOutput {
        const json = this.toJSON();
        let result = new GetUserForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class UserEditDto implements IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string | undefined;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    passwordRepeat: string | undefined;
    isActive: boolean | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
    subbrId: string | undefined;
    deP_ID: string | undefined;
    markerId: string | undefined;
    userTenantId: string | undefined;
    employeeCode: string | undefined;
    branchId: number | undefined;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.passwordRepeat = data["passwordRepeat"];
            this.isActive = data["isActive"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
            this.subbrId = data["subbrId"];
            this.deP_ID = data["deP_ID"];
            this.markerId = data["markerId"];
            this.userTenantId = data["userTenantId"];
            this.employeeCode = data["employeeCode"];
            this.branchId = data["branchId"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["passwordRepeat"] = this.passwordRepeat;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["subbrId"] = this.subbrId;
        data["deP_ID"] = this.deP_ID;
        data["markerId"] = this.markerId;
        data["userTenantId"] = this.userTenantId;
        data["employeeCode"] = this.employeeCode;
        data["branchId"] = this.branchId;
        return data; 
    }

    clone(): UserEditDto {
        const json = this.toJSON();
        let result = new UserEditDto();
        result.init(json);
        return result;
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string | undefined;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    passwordRepeat: string | undefined;
    isActive: boolean | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
    subbrId: string | undefined;
    deP_ID: string | undefined;
    markerId: string | undefined;
    userTenantId: string | undefined;
    employeeCode: string | undefined;
    branchId: number | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleDisplayName = data["roleDisplayName"];
            this.isAssigned = data["isAssigned"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        return data; 
    }

    clone(): UserRoleDto {
        const json = this.toJSON();
        let result = new UserRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUserRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetUserPermissionsForEditOutput {
        const json = this.toJSON();
        let result = new GetUserPermissionsForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id: number | undefined;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDtoOfInt64 {
        const json = this.toJSON();
        let result = new EntityDtoOfInt64();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfInt64 {
    id: number | undefined;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): UpdateUserPermissionsInput {
        const json = this.toJSON();
        let result = new UpdateUserPermissionsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserPermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean | undefined;
    setRandomPassword: boolean | undefined;
    makerId: string | undefined;
    organizationUnits: number[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : new UserEditDto();
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [];
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            this.sendActivationEmail = data["sendActivationEmail"];
            this.setRandomPassword = data["setRandomPassword"];
            this.makerId = data["makerId"];
            if (data["organizationUnits"] && data["organizationUnits"].constructor === Array) {
                this.organizationUnits = [];
                for (let item of data["organizationUnits"])
                    this.organizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        data["makerId"] = this.makerId;
        if (this.organizationUnits && this.organizationUnits.constructor === Array) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data; 
    }

    clone(): CreateOrUpdateUserInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateUserInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean | undefined;
    setRandomPassword: boolean | undefined;
    makerId: string | undefined;
    organizationUnits: number[] | undefined;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.usernameOrEmailAddress = data["usernameOrEmailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }

    clone(): LinkToUserInput {
        const json = this.toJSON();
        let result = new LinkToUserInput();
        result.init(json);
        return result;
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount: number | undefined;
    items: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfLinkedUserDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number | undefined;
    items: LinkedUserDto[] | undefined;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number | undefined;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.username = data["username"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["id"] = this.id;
        return data; 
    }

    clone(): LinkedUserDto {
        const json = this.toJSON();
        let result = new LinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfLinkedUserDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number | undefined;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): UnlinkUserInput {
        const json = this.toJSON();
        let result = new UnlinkUserInput();
        result.init(json);
        return result;
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfUserLoginAttemptDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment | undefined;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userNameOrEmail = data["userNameOrEmail"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): UserLoginAttemptDto {
        const json = this.toJSON();
        let result = new UserLoginAttemptDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["latestWebLogLines"] && data["latestWebLogLines"].constructor === Array) {
                this.latestWebLogLines = [];
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.latestWebLogLines && this.latestWebLogLines.constructor === Array) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }

    clone(): GetLatestWebLogsOutput {
        const json = this.toJSON();
        let result = new GetLatestWebLogsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class WfDefinitionParam implements IWfDefinitionParam {
    functioN_ID: string | undefined;
    reF_ID: string | undefined;
    menU_ID: number | undefined;
    amt: number | undefined;
    wF_VALUE: string | undefined;
    useR_ID: string | undefined;

    constructor(data?: IWfDefinitionParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.functioN_ID = data["functioN_ID"];
            this.reF_ID = data["reF_ID"];
            this.menU_ID = data["menU_ID"];
            this.amt = data["amt"];
            this.wF_VALUE = data["wF_VALUE"];
            this.useR_ID = data["useR_ID"];
        }
    }

    static fromJS(data: any): WfDefinitionParam {
        data = typeof data === 'object' ? data : {};
        let result = new WfDefinitionParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["functioN_ID"] = this.functioN_ID;
        data["reF_ID"] = this.reF_ID;
        data["menU_ID"] = this.menU_ID;
        data["amt"] = this.amt;
        data["wF_VALUE"] = this.wF_VALUE;
        data["useR_ID"] = this.useR_ID;
        return data; 
    }

    clone(): WfDefinitionParam {
        const json = this.toJSON();
        let result = new WfDefinitionParam();
        result.init(json);
        return result;
    }
}

export interface IWfDefinitionParam {
    functioN_ID: string | undefined;
    reF_ID: string | undefined;
    menU_ID: number | undefined;
    amt: number | undefined;
    wF_VALUE: string | undefined;
    useR_ID: string | undefined;
}

export class WidgetItemSearchDto implements IWidgetItemSearchDto {
    widgetLayoutName: string | undefined;
    widgetLayoutId: number | undefined;
    name: string | undefined;
    descriptions: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IWidgetItemSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.widgetLayoutName = data["widgetLayoutName"];
            this.widgetLayoutId = data["widgetLayoutId"];
            this.name = data["name"];
            this.descriptions = data["descriptions"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WidgetItemSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetItemSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetLayoutName"] = this.widgetLayoutName;
        data["widgetLayoutId"] = this.widgetLayoutId;
        data["name"] = this.name;
        data["descriptions"] = this.descriptions;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WidgetItemSearchDto {
        const json = this.toJSON();
        let result = new WidgetItemSearchDto();
        result.init(json);
        return result;
    }
}

export interface IWidgetItemSearchDto {
    widgetLayoutName: string | undefined;
    widgetLayoutId: number | undefined;
    name: string | undefined;
    descriptions: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class WidgetMapDto implements IWidgetMapDto {
    widgetItemId: number | undefined;
    name: string | undefined;
    descriptions: string | undefined;
    pageId: number | undefined;
    positionX: number | undefined;
    positionY: number | undefined;
    height: number | undefined;
    width: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IWidgetMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.widgetItemId = data["widgetItemId"];
            this.name = data["name"];
            this.descriptions = data["descriptions"];
            this.pageId = data["pageId"];
            this.positionX = data["positionX"];
            this.positionY = data["positionY"];
            this.height = data["height"];
            this.width = data["width"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WidgetMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetItemId"] = this.widgetItemId;
        data["name"] = this.name;
        data["descriptions"] = this.descriptions;
        data["pageId"] = this.pageId;
        data["positionX"] = this.positionX;
        data["positionY"] = this.positionY;
        data["height"] = this.height;
        data["width"] = this.width;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WidgetMapDto {
        const json = this.toJSON();
        let result = new WidgetMapDto();
        result.init(json);
        return result;
    }
}

export interface IWidgetMapDto {
    widgetItemId: number | undefined;
    name: string | undefined;
    descriptions: string | undefined;
    pageId: number | undefined;
    positionX: number | undefined;
    positionY: number | undefined;
    height: number | undefined;
    width: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class WidgetItemDto implements IWidgetItemDto {
    widgetLayoutId: number | undefined;
    name: string | undefined;
    descriptions: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IWidgetItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.widgetLayoutId = data["widgetLayoutId"];
            this.name = data["name"];
            this.descriptions = data["descriptions"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WidgetItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetLayoutId"] = this.widgetLayoutId;
        data["name"] = this.name;
        data["descriptions"] = this.descriptions;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WidgetItemDto {
        const json = this.toJSON();
        let result = new WidgetItemDto();
        result.init(json);
        return result;
    }
}

export interface IWidgetItemDto {
    widgetLayoutId: number | undefined;
    name: string | undefined;
    descriptions: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class WidgetValueConfigDto implements IWidgetValueConfigDto {
    key: string | undefined;
    name: string | undefined;
    value: string | undefined;
    widgetItemId: number | undefined;
    isDelete: boolean | undefined;
    descriptions: string | undefined;
    id: number | undefined;

    constructor(data?: IWidgetValueConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.name = data["name"];
            this.value = data["value"];
            this.widgetItemId = data["widgetItemId"];
            this.isDelete = data["isDelete"];
            this.descriptions = data["descriptions"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WidgetValueConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetValueConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["name"] = this.name;
        data["value"] = this.value;
        data["widgetItemId"] = this.widgetItemId;
        data["isDelete"] = this.isDelete;
        data["descriptions"] = this.descriptions;
        data["id"] = this.id;
        return data; 
    }

    clone(): WidgetValueConfigDto {
        const json = this.toJSON();
        let result = new WidgetValueConfigDto();
        result.init(json);
        return result;
    }
}

export interface IWidgetValueConfigDto {
    key: string | undefined;
    name: string | undefined;
    value: string | undefined;
    widgetItemId: number | undefined;
    isDelete: boolean | undefined;
    descriptions: string | undefined;
    id: number | undefined;
}

export class CM_WORKFLOW_ENTITY implements ICM_WORKFLOW_ENTITY {
    workfloW_ID: string | undefined;
    functioN_ID: string | undefined;
    menU_NAME: string | undefined;
    approvE_LEVEL: string | undefined;
    steP_NUMBERS: number | undefined;
    nexT_LEVEL: string | undefined;
    limiT_VALUE_FROM: number | undefined;
    limiT_VALUE_FROM_FROM: number | undefined;
    limiT_VALUE_FROM_TO: number | undefined;
    limiT_VALUE_TO: number | undefined;
    limiT_VALUE_TO_FROM: number | undefined;
    limiT_VALUE_TO_TO: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    workfloW_ASSIGNs: CM_WORKFLOW_ASSIGN_ENTITY[] | undefined;
    workfloW_ASSIGN_XML: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: ICM_WORKFLOW_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workfloW_ID = data["workfloW_ID"];
            this.functioN_ID = data["functioN_ID"];
            this.menU_NAME = data["menU_NAME"];
            this.approvE_LEVEL = data["approvE_LEVEL"];
            this.steP_NUMBERS = data["steP_NUMBERS"];
            this.nexT_LEVEL = data["nexT_LEVEL"];
            this.limiT_VALUE_FROM = data["limiT_VALUE_FROM"];
            this.limiT_VALUE_FROM_FROM = data["limiT_VALUE_FROM_FROM"];
            this.limiT_VALUE_FROM_TO = data["limiT_VALUE_FROM_TO"];
            this.limiT_VALUE_TO = data["limiT_VALUE_TO"];
            this.limiT_VALUE_TO_FROM = data["limiT_VALUE_TO_FROM"];
            this.limiT_VALUE_TO_TO = data["limiT_VALUE_TO_TO"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            if (data["workfloW_ASSIGNs"] && data["workfloW_ASSIGNs"].constructor === Array) {
                this.workfloW_ASSIGNs = [];
                for (let item of data["workfloW_ASSIGNs"])
                    this.workfloW_ASSIGNs.push(CM_WORKFLOW_ASSIGN_ENTITY.fromJS(item));
            }
            this.workfloW_ASSIGN_XML = data["workfloW_ASSIGN_XML"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_WORKFLOW_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_WORKFLOW_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workfloW_ID"] = this.workfloW_ID;
        data["functioN_ID"] = this.functioN_ID;
        data["menU_NAME"] = this.menU_NAME;
        data["approvE_LEVEL"] = this.approvE_LEVEL;
        data["steP_NUMBERS"] = this.steP_NUMBERS;
        data["nexT_LEVEL"] = this.nexT_LEVEL;
        data["limiT_VALUE_FROM"] = this.limiT_VALUE_FROM;
        data["limiT_VALUE_FROM_FROM"] = this.limiT_VALUE_FROM_FROM;
        data["limiT_VALUE_FROM_TO"] = this.limiT_VALUE_FROM_TO;
        data["limiT_VALUE_TO"] = this.limiT_VALUE_TO;
        data["limiT_VALUE_TO_FROM"] = this.limiT_VALUE_TO_FROM;
        data["limiT_VALUE_TO_TO"] = this.limiT_VALUE_TO_TO;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        if (this.workfloW_ASSIGNs && this.workfloW_ASSIGNs.constructor === Array) {
            data["workfloW_ASSIGNs"] = [];
            for (let item of this.workfloW_ASSIGNs)
                data["workfloW_ASSIGNs"].push(item.toJSON());
        }
        data["workfloW_ASSIGN_XML"] = this.workfloW_ASSIGN_XML;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): CM_WORKFLOW_ENTITY {
        const json = this.toJSON();
        let result = new CM_WORKFLOW_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_WORKFLOW_ENTITY {
    workfloW_ID: string | undefined;
    functioN_ID: string | undefined;
    menU_NAME: string | undefined;
    approvE_LEVEL: string | undefined;
    steP_NUMBERS: number | undefined;
    nexT_LEVEL: string | undefined;
    limiT_VALUE_FROM: number | undefined;
    limiT_VALUE_FROM_FROM: number | undefined;
    limiT_VALUE_FROM_TO: number | undefined;
    limiT_VALUE_TO: number | undefined;
    limiT_VALUE_TO_FROM: number | undefined;
    limiT_VALUE_TO_TO: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    workfloW_ASSIGNs: CM_WORKFLOW_ASSIGN_ENTITY[] | undefined;
    workfloW_ASSIGN_XML: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class CM_WORKFLOW_ASSIGN_ENTITY implements ICM_WORKFLOW_ASSIGN_ENTITY {
    wF_ASSIGN_ID: string | undefined;
    workfloW_ID: string | undefined;
    workfloW_STEP: number | undefined;
    assigns: string | undefined;
    limiT_VALUE_FROM: number | undefined;
    limiT_VALUE_TO: number | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    no: number | undefined;
    page: number | undefined;
    isChecked: boolean | undefined;

    constructor(data?: ICM_WORKFLOW_ASSIGN_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wF_ASSIGN_ID = data["wF_ASSIGN_ID"];
            this.workfloW_ID = data["workfloW_ID"];
            this.workfloW_STEP = data["workfloW_STEP"];
            this.assigns = data["assigns"];
            this.limiT_VALUE_FROM = data["limiT_VALUE_FROM"];
            this.limiT_VALUE_TO = data["limiT_VALUE_TO"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS = data["recorD_STATUS"];
            this.no = data["no"];
            this.page = data["page"];
            this.isChecked = data["isChecked"];
        }
    }

    static fromJS(data: any): CM_WORKFLOW_ASSIGN_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_WORKFLOW_ASSIGN_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wF_ASSIGN_ID"] = this.wF_ASSIGN_ID;
        data["workfloW_ID"] = this.workfloW_ID;
        data["workfloW_STEP"] = this.workfloW_STEP;
        data["assigns"] = this.assigns;
        data["limiT_VALUE_FROM"] = this.limiT_VALUE_FROM;
        data["limiT_VALUE_TO"] = this.limiT_VALUE_TO;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["no"] = this.no;
        data["page"] = this.page;
        data["isChecked"] = this.isChecked;
        return data; 
    }

    clone(): CM_WORKFLOW_ASSIGN_ENTITY {
        const json = this.toJSON();
        let result = new CM_WORKFLOW_ASSIGN_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_WORKFLOW_ASSIGN_ENTITY {
    wF_ASSIGN_ID: string | undefined;
    workfloW_ID: string | undefined;
    workfloW_STEP: number | undefined;
    assigns: string | undefined;
    limiT_VALUE_FROM: number | undefined;
    limiT_VALUE_TO: number | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    no: number | undefined;
    page: number | undefined;
    isChecked: boolean | undefined;
}

export class PagedResultDtoOfCM_WORKFLOW_ENTITY implements IPagedResultDtoOfCM_WORKFLOW_ENTITY {
    totalCount: number | undefined;
    items: CM_WORKFLOW_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_WORKFLOW_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_WORKFLOW_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_WORKFLOW_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_WORKFLOW_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCM_WORKFLOW_ENTITY {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCM_WORKFLOW_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCM_WORKFLOW_ENTITY {
    totalCount: number | undefined;
    items: CM_WORKFLOW_ENTITY[] | undefined;
}

export class CM_WORKFLOW_REJECT_MODEL implements ICM_WORKFLOW_REJECT_MODEL {
    modeL_ID: string | undefined;
    checkeR_ID: string | undefined;
    functioN_ID: string | undefined;
    notes: string | undefined;
    tlsubbrid: string | undefined;
    tablE_NAME: string | undefined;
    primarY_KEY_NAME: string | undefined;

    constructor(data?: ICM_WORKFLOW_REJECT_MODEL) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.modeL_ID = data["modeL_ID"];
            this.checkeR_ID = data["checkeR_ID"];
            this.functioN_ID = data["functioN_ID"];
            this.notes = data["notes"];
            this.tlsubbrid = data["tlsubbrid"];
            this.tablE_NAME = data["tablE_NAME"];
            this.primarY_KEY_NAME = data["primarY_KEY_NAME"];
        }
    }

    static fromJS(data: any): CM_WORKFLOW_REJECT_MODEL {
        data = typeof data === 'object' ? data : {};
        let result = new CM_WORKFLOW_REJECT_MODEL();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modeL_ID"] = this.modeL_ID;
        data["checkeR_ID"] = this.checkeR_ID;
        data["functioN_ID"] = this.functioN_ID;
        data["notes"] = this.notes;
        data["tlsubbrid"] = this.tlsubbrid;
        data["tablE_NAME"] = this.tablE_NAME;
        data["primarY_KEY_NAME"] = this.primarY_KEY_NAME;
        return data; 
    }

    clone(): CM_WORKFLOW_REJECT_MODEL {
        const json = this.toJSON();
        let result = new CM_WORKFLOW_REJECT_MODEL();
        result.init(json);
        return result;
    }
}

export interface ICM_WORKFLOW_REJECT_MODEL {
    modeL_ID: string | undefined;
    checkeR_ID: string | undefined;
    functioN_ID: string | undefined;
    notes: string | undefined;
    tlsubbrid: string | undefined;
    tablE_NAME: string | undefined;
    primarY_KEY_NAME: string | undefined;
}

export class CM_WORKFLOW_REJECT_DETAIL_ENTITY implements ICM_WORKFLOW_REJECT_DETAIL_ENTITY {
    transactioN_ID: string | undefined;
    checkeR_ID: string | undefined;
    brancH_NAME: string | undefined;
    notes: string | undefined;
    rejecT_DT: moment.Moment | undefined;
    fullname: string | undefined;
    totalCount: number | undefined;

    constructor(data?: ICM_WORKFLOW_REJECT_DETAIL_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactioN_ID = data["transactioN_ID"];
            this.checkeR_ID = data["checkeR_ID"];
            this.brancH_NAME = data["brancH_NAME"];
            this.notes = data["notes"];
            this.rejecT_DT = data["rejecT_DT"] ? moment(data["rejecT_DT"].toString()) : <any>undefined;
            this.fullname = data["fullname"];
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): CM_WORKFLOW_REJECT_DETAIL_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_WORKFLOW_REJECT_DETAIL_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactioN_ID"] = this.transactioN_ID;
        data["checkeR_ID"] = this.checkeR_ID;
        data["brancH_NAME"] = this.brancH_NAME;
        data["notes"] = this.notes;
        data["rejecT_DT"] = this.rejecT_DT ? this.rejecT_DT.toISOString() : <any>undefined;
        data["fullname"] = this.fullname;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone(): CM_WORKFLOW_REJECT_DETAIL_ENTITY {
        const json = this.toJSON();
        let result = new CM_WORKFLOW_REJECT_DETAIL_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ICM_WORKFLOW_REJECT_DETAIL_ENTITY {
    transactioN_ID: string | undefined;
    checkeR_ID: string | undefined;
    brancH_NAME: string | undefined;
    notes: string | undefined;
    rejecT_DT: moment.Moment | undefined;
    fullname: string | undefined;
    totalCount: number | undefined;
}

export class HrWorkTimeRequest_ENTITY implements IHrWorkTimeRequest_ENTITY {
    creatorUserId: number | undefined;
    tenCty: string | undefined;
    hoVaTen: string | undefined;
    image: string | undefined;
    email: string | undefined;
    documentType: string | undefined;
    timeFrom: string | undefined;
    timeTo: string | undefined;
    status: number | undefined;
    totalMinutes: number | undefined;
    reasons: string | undefined;
    notes: string | undefined;
    attachment: IFormFile | undefined;
    approverId: number | undefined;
    nextApproverId: number | undefined;
    approveTime: string | undefined;
    truongNhomId: number | undefined;
    truongPhongId: number | undefined;
    giamDocKhoiId: number | undefined;
    tcnsId: number | undefined;
    giamDocDieuHanhId: number | undefined;
    loaiNghiPhep: string | undefined;
    nghiCoLuong: boolean | undefined;
    id: number | undefined;

    constructor(data?: IHrWorkTimeRequest_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.creatorUserId = data["creatorUserId"];
            this.tenCty = data["tenCty"];
            this.hoVaTen = data["hoVaTen"];
            this.image = data["image"];
            this.email = data["email"];
            this.documentType = data["documentType"];
            this.timeFrom = data["timeFrom"];
            this.timeTo = data["timeTo"];
            this.status = data["status"];
            this.totalMinutes = data["totalMinutes"];
            this.reasons = data["reasons"];
            this.notes = data["notes"];
            this.attachment = data["attachment"] ? IFormFile.fromJS(data["attachment"]) : <any>undefined;
            this.approverId = data["approverId"];
            this.nextApproverId = data["nextApproverId"];
            this.approveTime = data["approveTime"];
            this.truongNhomId = data["truongNhomId"];
            this.truongPhongId = data["truongPhongId"];
            this.giamDocKhoiId = data["giamDocKhoiId"];
            this.tcnsId = data["tcnsId"];
            this.giamDocDieuHanhId = data["giamDocDieuHanhId"];
            this.loaiNghiPhep = data["loaiNghiPhep"];
            this.nghiCoLuong = data["nghiCoLuong"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HrWorkTimeRequest_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HrWorkTimeRequest_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creatorUserId"] = this.creatorUserId;
        data["tenCty"] = this.tenCty;
        data["hoVaTen"] = this.hoVaTen;
        data["image"] = this.image;
        data["email"] = this.email;
        data["documentType"] = this.documentType;
        data["timeFrom"] = this.timeFrom;
        data["timeTo"] = this.timeTo;
        data["status"] = this.status;
        data["totalMinutes"] = this.totalMinutes;
        data["reasons"] = this.reasons;
        data["notes"] = this.notes;
        data["attachment"] = this.attachment ? this.attachment.toJSON() : <any>undefined;
        data["approverId"] = this.approverId;
        data["nextApproverId"] = this.nextApproverId;
        data["approveTime"] = this.approveTime;
        data["truongNhomId"] = this.truongNhomId;
        data["truongPhongId"] = this.truongPhongId;
        data["giamDocKhoiId"] = this.giamDocKhoiId;
        data["tcnsId"] = this.tcnsId;
        data["giamDocDieuHanhId"] = this.giamDocDieuHanhId;
        data["loaiNghiPhep"] = this.loaiNghiPhep;
        data["nghiCoLuong"] = this.nghiCoLuong;
        data["id"] = this.id;
        return data; 
    }

    clone(): HrWorkTimeRequest_ENTITY {
        const json = this.toJSON();
        let result = new HrWorkTimeRequest_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHrWorkTimeRequest_ENTITY {
    creatorUserId: number | undefined;
    tenCty: string | undefined;
    hoVaTen: string | undefined;
    image: string | undefined;
    email: string | undefined;
    documentType: string | undefined;
    timeFrom: string | undefined;
    timeTo: string | undefined;
    status: number | undefined;
    totalMinutes: number | undefined;
    reasons: string | undefined;
    notes: string | undefined;
    attachment: IFormFile | undefined;
    approverId: number | undefined;
    nextApproverId: number | undefined;
    approveTime: string | undefined;
    truongNhomId: number | undefined;
    truongPhongId: number | undefined;
    giamDocKhoiId: number | undefined;
    tcnsId: number | undefined;
    giamDocDieuHanhId: number | undefined;
    loaiNghiPhep: string | undefined;
    nghiCoLuong: boolean | undefined;
    id: number | undefined;
}

export class LstRegisterInput_ENTITY implements ILstRegisterInput_ENTITY {
    truongNhom: RegisterInput_ENTITY | undefined;
    truongPhong: RegisterInput_ENTITY | undefined;
    giamDocKhoi: RegisterInput_ENTITY | undefined;
    tcns: RegisterInput_ENTITY | undefined;
    giamDocDieuHanh: RegisterInput_ENTITY | undefined;

    constructor(data?: ILstRegisterInput_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.truongNhom = data["truongNhom"] ? RegisterInput_ENTITY.fromJS(data["truongNhom"]) : <any>undefined;
            this.truongPhong = data["truongPhong"] ? RegisterInput_ENTITY.fromJS(data["truongPhong"]) : <any>undefined;
            this.giamDocKhoi = data["giamDocKhoi"] ? RegisterInput_ENTITY.fromJS(data["giamDocKhoi"]) : <any>undefined;
            this.tcns = data["tcns"] ? RegisterInput_ENTITY.fromJS(data["tcns"]) : <any>undefined;
            this.giamDocDieuHanh = data["giamDocDieuHanh"] ? RegisterInput_ENTITY.fromJS(data["giamDocDieuHanh"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LstRegisterInput_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new LstRegisterInput_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["truongNhom"] = this.truongNhom ? this.truongNhom.toJSON() : <any>undefined;
        data["truongPhong"] = this.truongPhong ? this.truongPhong.toJSON() : <any>undefined;
        data["giamDocKhoi"] = this.giamDocKhoi ? this.giamDocKhoi.toJSON() : <any>undefined;
        data["tcns"] = this.tcns ? this.tcns.toJSON() : <any>undefined;
        data["giamDocDieuHanh"] = this.giamDocDieuHanh ? this.giamDocDieuHanh.toJSON() : <any>undefined;
        return data; 
    }

    clone(): LstRegisterInput_ENTITY {
        const json = this.toJSON();
        let result = new LstRegisterInput_ENTITY();
        result.init(json);
        return result;
    }
}

export interface ILstRegisterInput_ENTITY {
    truongNhom: RegisterInput_ENTITY | undefined;
    truongPhong: RegisterInput_ENTITY | undefined;
    giamDocKhoi: RegisterInput_ENTITY | undefined;
    tcns: RegisterInput_ENTITY | undefined;
    giamDocDieuHanh: RegisterInput_ENTITY | undefined;
}

export class RegisterInput_ENTITY implements IRegisterInput_ENTITY {
    id: string | undefined;
    maChamCong: string | undefined;
    name: string | undefined;
    username: string | undefined;

    constructor(data?: IRegisterInput_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.maChamCong = data["maChamCong"];
            this.name = data["name"];
            this.username = data["username"];
        }
    }

    static fromJS(data: any): RegisterInput_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["maChamCong"] = this.maChamCong;
        data["name"] = this.name;
        data["username"] = this.username;
        return data; 
    }

    clone(): RegisterInput_ENTITY {
        const json = this.toJSON();
        let result = new RegisterInput_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput_ENTITY {
    id: string | undefined;
    maChamCong: string | undefined;
    name: string | undefined;
    username: string | undefined;
}

export class HrWorkTime implements IHrWorkTime {
    documentType: string | undefined;
    timeFrom: moment.Moment | undefined;
    timeTo: moment.Moment | undefined;
    totalMinutes: number | undefined;
    reasons: string | undefined;
    notes: string | undefined;
    attachment: string | undefined;
    status: number | undefined;
    approverId: number | undefined;
    nextApproverId: number | undefined;
    approveTime: moment.Moment | undefined;
    truongNhomId: number | undefined;
    truongPhongId: number | undefined;
    giamDocKhoiId: number | undefined;
    tcnsId: number | undefined;
    giamDocDieuHanhId: number | undefined;
    emailAddress: string | undefined;
    hoVaTen: string | undefined;
    loaiNghiPhep: string | undefined;
    nghiCoLuong: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IHrWorkTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.documentType = data["documentType"];
            this.timeFrom = data["timeFrom"] ? moment(data["timeFrom"].toString()) : <any>undefined;
            this.timeTo = data["timeTo"] ? moment(data["timeTo"].toString()) : <any>undefined;
            this.totalMinutes = data["totalMinutes"];
            this.reasons = data["reasons"];
            this.notes = data["notes"];
            this.attachment = data["attachment"];
            this.status = data["status"];
            this.approverId = data["approverId"];
            this.nextApproverId = data["nextApproverId"];
            this.approveTime = data["approveTime"] ? moment(data["approveTime"].toString()) : <any>undefined;
            this.truongNhomId = data["truongNhomId"];
            this.truongPhongId = data["truongPhongId"];
            this.giamDocKhoiId = data["giamDocKhoiId"];
            this.tcnsId = data["tcnsId"];
            this.giamDocDieuHanhId = data["giamDocDieuHanhId"];
            this.emailAddress = data["emailAddress"];
            this.hoVaTen = data["hoVaTen"];
            this.loaiNghiPhep = data["loaiNghiPhep"];
            this.nghiCoLuong = data["nghiCoLuong"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HrWorkTime {
        data = typeof data === 'object' ? data : {};
        let result = new HrWorkTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType;
        data["timeFrom"] = this.timeFrom ? this.timeFrom.toISOString() : <any>undefined;
        data["timeTo"] = this.timeTo ? this.timeTo.toISOString() : <any>undefined;
        data["totalMinutes"] = this.totalMinutes;
        data["reasons"] = this.reasons;
        data["notes"] = this.notes;
        data["attachment"] = this.attachment;
        data["status"] = this.status;
        data["approverId"] = this.approverId;
        data["nextApproverId"] = this.nextApproverId;
        data["approveTime"] = this.approveTime ? this.approveTime.toISOString() : <any>undefined;
        data["truongNhomId"] = this.truongNhomId;
        data["truongPhongId"] = this.truongPhongId;
        data["giamDocKhoiId"] = this.giamDocKhoiId;
        data["tcnsId"] = this.tcnsId;
        data["giamDocDieuHanhId"] = this.giamDocDieuHanhId;
        data["emailAddress"] = this.emailAddress;
        data["hoVaTen"] = this.hoVaTen;
        data["loaiNghiPhep"] = this.loaiNghiPhep;
        data["nghiCoLuong"] = this.nghiCoLuong;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): HrWorkTime {
        const json = this.toJSON();
        let result = new HrWorkTime();
        result.init(json);
        return result;
    }
}

export interface IHrWorkTime {
    documentType: string | undefined;
    timeFrom: moment.Moment | undefined;
    timeTo: moment.Moment | undefined;
    totalMinutes: number | undefined;
    reasons: string | undefined;
    notes: string | undefined;
    attachment: string | undefined;
    status: number | undefined;
    approverId: number | undefined;
    nextApproverId: number | undefined;
    approveTime: moment.Moment | undefined;
    truongNhomId: number | undefined;
    truongPhongId: number | undefined;
    giamDocKhoiId: number | undefined;
    tcnsId: number | undefined;
    giamDocDieuHanhId: number | undefined;
    emailAddress: string | undefined;
    hoVaTen: string | undefined;
    loaiNghiPhep: string | undefined;
    nghiCoLuong: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class HrWorkTime_ENTITY implements IHrWorkTime_ENTITY {
    tenCty: string | undefined;
    hoVaTen: string | undefined;
    image: string | undefined;
    email: string | undefined;
    userName: string | undefined;
    documentType: string | undefined;
    timeFrom: string | undefined;
    timeTo: string | undefined;
    totalMinutes: number | undefined;
    reasons: string | undefined;
    notes: string | undefined;
    attachment: string | undefined;
    status: number | undefined;
    approverId: number | undefined;
    nextApproverId: number | undefined;
    approveTime: moment.Moment | undefined;
    truongNhomId: number | undefined;
    truongPhongId: number | undefined;
    giamDocKhoiId: number | undefined;
    tcnsId: number | undefined;
    giamDocDieuHanhId: number | undefined;
    loaiNghiPhep: string | undefined;
    nghiCoLuong: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IHrWorkTime_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenCty = data["tenCty"];
            this.hoVaTen = data["hoVaTen"];
            this.image = data["image"];
            this.email = data["email"];
            this.userName = data["userName"];
            this.documentType = data["documentType"];
            this.timeFrom = data["timeFrom"];
            this.timeTo = data["timeTo"];
            this.totalMinutes = data["totalMinutes"];
            this.reasons = data["reasons"];
            this.notes = data["notes"];
            this.attachment = data["attachment"];
            this.status = data["status"];
            this.approverId = data["approverId"];
            this.nextApproverId = data["nextApproverId"];
            this.approveTime = data["approveTime"] ? moment(data["approveTime"].toString()) : <any>undefined;
            this.truongNhomId = data["truongNhomId"];
            this.truongPhongId = data["truongPhongId"];
            this.giamDocKhoiId = data["giamDocKhoiId"];
            this.tcnsId = data["tcnsId"];
            this.giamDocDieuHanhId = data["giamDocDieuHanhId"];
            this.loaiNghiPhep = data["loaiNghiPhep"];
            this.nghiCoLuong = data["nghiCoLuong"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HrWorkTime_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new HrWorkTime_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenCty"] = this.tenCty;
        data["hoVaTen"] = this.hoVaTen;
        data["image"] = this.image;
        data["email"] = this.email;
        data["userName"] = this.userName;
        data["documentType"] = this.documentType;
        data["timeFrom"] = this.timeFrom;
        data["timeTo"] = this.timeTo;
        data["totalMinutes"] = this.totalMinutes;
        data["reasons"] = this.reasons;
        data["notes"] = this.notes;
        data["attachment"] = this.attachment;
        data["status"] = this.status;
        data["approverId"] = this.approverId;
        data["nextApproverId"] = this.nextApproverId;
        data["approveTime"] = this.approveTime ? this.approveTime.toISOString() : <any>undefined;
        data["truongNhomId"] = this.truongNhomId;
        data["truongPhongId"] = this.truongPhongId;
        data["giamDocKhoiId"] = this.giamDocKhoiId;
        data["tcnsId"] = this.tcnsId;
        data["giamDocDieuHanhId"] = this.giamDocDieuHanhId;
        data["loaiNghiPhep"] = this.loaiNghiPhep;
        data["nghiCoLuong"] = this.nghiCoLuong;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): HrWorkTime_ENTITY {
        const json = this.toJSON();
        let result = new HrWorkTime_ENTITY();
        result.init(json);
        return result;
    }
}

export interface IHrWorkTime_ENTITY {
    tenCty: string | undefined;
    hoVaTen: string | undefined;
    image: string | undefined;
    email: string | undefined;
    userName: string | undefined;
    documentType: string | undefined;
    timeFrom: string | undefined;
    timeTo: string | undefined;
    totalMinutes: number | undefined;
    reasons: string | undefined;
    notes: string | undefined;
    attachment: string | undefined;
    status: number | undefined;
    approverId: number | undefined;
    nextApproverId: number | undefined;
    approveTime: moment.Moment | undefined;
    truongNhomId: number | undefined;
    truongPhongId: number | undefined;
    giamDocKhoiId: number | undefined;
    tcnsId: number | undefined;
    giamDocDieuHanhId: number | undefined;
    loaiNghiPhep: string | undefined;
    nghiCoLuong: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class AdditionalData implements IAdditionalData {
    paypal: { [key: string] : string; } | undefined;
    stripe: { [key: string] : string; } | undefined;

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Paypal"]) {
                this.paypal = {};
                for (let key in data["Paypal"]) {
                    if (data["Paypal"].hasOwnProperty(key))
                        this.paypal[key] = data["Paypal"][key];
                }
            }
            if (data["Stripe"]) {
                this.stripe = {};
                for (let key in data["Stripe"]) {
                    if (data["Stripe"].hasOwnProperty(key))
                        this.stripe[key] = data["Stripe"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    data["Paypal"][key] = this.paypal[key];
            }
        }
        if (this.stripe) {
            data["Stripe"] = {};
            for (let key in this.stripe) {
                if (this.stripe.hasOwnProperty(key))
                    data["Stripe"][key] = this.stripe[key];
            }
        }
        return data; 
    }

    clone(): AdditionalData {
        const json = this.toJSON();
        let result = new AdditionalData();
        result.init(json);
        return result;
    }
}

export interface IAdditionalData {
    paypal: { [key: string] : string; } | undefined;
    stripe: { [key: string] : string; } | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}